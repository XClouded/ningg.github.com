<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>NingG.github.com</title>
   <link href="http://ningg.github.com/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://ningg.github.com" rel="alternate" type="text/html" />
   <updated>2014-05-09T22:53:46+08:00</updated>
   <id>http://ningg.github.com</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>Pig解析中文文档</title>
     <link href="http://ningg.github.com/pig-deal-with-chinese"/>
     <updated>2014-05-09T00:00:00+08:00</updated>
     <id>http://ningg.github.com/pig-deal-with-chinese</id>
     <content type="html">&lt;p&gt;&lt;code&gt;Pig&lt;/code&gt;处理文档时，&lt;code&gt;LOAD&lt;/code&gt;和&lt;code&gt;STORE&lt;/code&gt;默认数据是&lt;code&gt;UTF-8&lt;/code&gt;编码格式（参考来源？官方文档/源码）。因此，包含中文字符的数据文档，应以&lt;code&gt;UTF-8&lt;/code&gt;格式存储；相应的包含中文字符的pig脚本，也应以&lt;code&gt;UTF-8&lt;/code&gt;格式存储。&lt;/p&gt;

&lt;p&gt;本文简介：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;中文文档如何转码，特别是&lt;code&gt;Linux&lt;/code&gt;下利用&lt;code&gt;iconv&lt;/code&gt;命令转码时的注意事项；&lt;/li&gt;
  &lt;li&gt;使用&lt;code&gt;SecuryCRT&lt;/code&gt;/&lt;code&gt;putty&lt;/code&gt;客户端连接服务器时，中文文档显示乱码的解决办法；&lt;/li&gt;
  &lt;li&gt;Pig脚本解析中文文档的步骤；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;utf-8&quot;&gt;将文档存储为UTF-8格式&lt;/h2&gt;

&lt;p&gt;在&lt;code&gt;windows&lt;/code&gt;下，可以使用&lt;code&gt;notepad++&lt;/code&gt;来进行文档转码：
&lt;code&gt;Encoding&lt;/code&gt;–&lt;code&gt;Convert to UTF-8 without BOM&lt;/code&gt;，则当前文档转换为&lt;code&gt;UTF-8&lt;/code&gt;编码方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/pig-deal-with-chinese/convert-utf8.png&quot; alt=&quot;convert-utf8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（思考：文档编码格式转换的原理？在linux下有没有类似的转换工具/命令？）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;下使用&lt;code&gt;iconv&lt;/code&gt;可以进行编码格式转换，具体操作如下：&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;查看文档编码方式：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;file –i origin.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/pig-deal-with-chinese/file-i.png&quot; alt=&quot;file-i&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;对文档转码：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 下面命令中 origin.txt.utf8为输出文件。
iconv –f ISO-8859-1 –t UTF-8 &amp;lt; origin.txt &amp;gt; origin.txt.utf8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;特别说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;如果&lt;code&gt;iconv&lt;/code&gt;转码命令，出现&lt;code&gt;iconv: illegal input sequence at position 42&lt;/code&gt;错误信息，则可以使用如下命令进行转码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iconv –f gbk –t UTF-8 &amp;lt; origin.txt &amp;gt; origin.txt.gbk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（思考：上面的原因是否是&lt;code&gt;file&lt;/code&gt;命令查询结果不精确，查询文件的编码方式，&lt;code&gt;linux&lt;/code&gt;下还有其他的命令吗？）&lt;/p&gt;

&lt;p&gt;（思考：不同的编码格式的差异？为什么有多种编码？对应的应用场景？）&lt;/p&gt;

&lt;h3 id=&quot;iconv&quot;&gt;iconv转码出错[重要]&lt;/h3&gt;

&lt;p&gt;当对&lt;code&gt;1G&lt;/code&gt;以上的大文件，进行转码时：如果按照如下命令进行转码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 下面命令中 origin.txt.utf8为输出文件。
iconv –f gbk –t UTF-8 &amp;lt; origin.txt &amp;gt; origin.txt.utf8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能仍然会出错：&lt;code&gt;iconv: illegal input sequence at position 91401042&lt;/code&gt;，查看&lt;code&gt;origin.txt.utf8&lt;/code&gt;文件，其内中文已经正常显示，只是原始文件在某个位置出现问题，没能完成整个文档的转码。&lt;/p&gt;

&lt;p&gt;原因排查：是否是原始文件中真的有字符无法转码？还是文件过大？&lt;/p&gt;

&lt;p&gt;排查措施：使用&lt;code&gt;split&lt;/code&gt;、&lt;code&gt;head&lt;/code&gt;等命令对文件分割之后，在相应位置仍然出错；&lt;/p&gt;

&lt;p&gt;原因确定：是原始文件有非法字符，&lt;code&gt;GBK&lt;/code&gt;中不存在的编码，&lt;code&gt;GBK&lt;/code&gt;自己无法识别，因此无法转码。&lt;/p&gt;

&lt;p&gt;解决途径：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;删除有乱码的行？（使用wc –l 、 sed –i 等命令；） &lt;/li&gt;
  &lt;li&gt;跳过有乱码的几个字符？&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;iconv&lt;/code&gt;有没有强制转换，忽略/跳过错误？（尼玛，恭喜你，猜对了，有这么个机制）&lt;/li&gt;
  &lt;li&gt;使用 &lt;code&gt;man iconv&lt;/code&gt;查询不到，应该使用&lt;code&gt;iconv –help&lt;/code&gt;，查看命令的帮助。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最终命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iconv –f gbk –t utf-8//IGNORE &amp;lt; input &amp;gt; output 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搞定。&lt;/p&gt;

&lt;p&gt;参考来源：&lt;/p&gt;

&lt;p&gt;[1]	http://www.aiezu.com/system/linux/linux_iconv_code.html
[2] http://www.linuxquestions.org/questions/linux-newbie-8/usr-bin-iconv-illegal-input-sequence-at-position-905152/&lt;/p&gt;

&lt;h2 id=&quot;linux&quot;&gt;将文档传到远端linux服务器&lt;/h2&gt;

&lt;p&gt;注意：在传输过程中，应尽量保持文档的属性/编码方式保持不变。
仅仅是将&lt;code&gt;windows&lt;/code&gt;下文档传递到远端linux服务器上，方法很多：&lt;code&gt;fileZilla&lt;/code&gt;、&lt;code&gt;WinSCP&lt;/code&gt;等，下面说一种不需要安装软件的方法（亲，不要想错了，需要下载软件的，只是软件很小，不需要安装）。
下载&lt;code&gt;PSCP&lt;/code&gt;，文件300k，果真很小；现在工具有了，如何利用&lt;code&gt;PSCP&lt;/code&gt;来向远端&lt;code&gt;linux&lt;/code&gt;传送文件呢？操作如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//-p : preserve file attributes.（传送过程中，保持文件属性不变）
scp –p originalFile user@ip:/home/user/destFold
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面命令会将本地&lt;code&gt;originalFile&lt;/code&gt;文件，无失真传送到服务器&lt;code&gt;/home/user/destFold&lt;/code&gt;目录下。&lt;/p&gt;

&lt;p&gt;在远端&lt;code&gt;linux&lt;/code&gt;服务器上，如何查看文档的具体编码方式呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file –i filename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用上述命令来确认文件的编码方式。&lt;/p&gt;

&lt;p&gt;现在按照&lt;code&gt;utf-8&lt;/code&gt;编码的文件，已经在服务器上了，那原材料就齐全了，开始处理吧。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;远端服务器上，中文显示乱码&lt;/h2&gt;

&lt;p&gt;既然要操作远端&lt;code&gt;linux&lt;/code&gt;服务器，最好要建立持久的连接，常用的方式：&lt;code&gt;putty&lt;/code&gt;、&lt;code&gt;secureCRT&lt;/code&gt;。然而，查看服务器上的中文文档时，可能出现乱码。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;服务器的基本环境&lt;/h3&gt;

&lt;p&gt;针对上述情况，需要先检查一下服务器上设置的语言环境。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $LANG
// 上述输出结果为：en_US.UTF-8

更进一步，查看3个文件，看LANG具体如何配置的：
cat /etc/sysconfig/i18n
//上述输出结果为：LANG=”en_US.UTF-8”

cat ~/.bash_profile
//上述输出结果中，没有LANG的配置

cat ~//.bashrc
//上述输出结果中，没有LANG的配置
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（思考：LANG的配置有什么用？LANG不就是个环境变量吗？）&lt;/p&gt;

&lt;h3 id=&quot;putty&quot;&gt;Putty连接服务器&lt;/h3&gt;

&lt;p&gt;设置方式：
&lt;code&gt;Window&lt;/code&gt;–&lt;code&gt;Translation&lt;/code&gt;–&lt;code&gt;Character set translation&lt;/code&gt;–&lt;code&gt;Remote character set&lt;/code&gt;，选中“UTF-8”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/pig-deal-with-chinese/putty-utf8.png&quot; alt=&quot;putty-utf8.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Window&lt;/code&gt;–&lt;code&gt;Appearance&lt;/code&gt;–&lt;code&gt;Font settings&lt;/code&gt;–&lt;code&gt;Font used in terminal window&lt;/code&gt;，选中&lt;code&gt;Courier New&lt;/code&gt;（尝试其他字体也可以解决中文乱码）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/pig-deal-with-chinese/putty-appearance.png&quot; alt=&quot;putty-appearance&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;securecrt&quot;&gt;SecureCRT连接服务器&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;选项&lt;/code&gt;–&lt;code&gt;会话选项&lt;/code&gt;–&lt;code&gt;终端&lt;/code&gt;–&lt;code&gt;外观&lt;/code&gt;–&lt;code&gt;字体&lt;/code&gt;，&lt;code&gt;字符编码&lt;/code&gt;选中&lt;code&gt;UTF-8&lt;/code&gt;；
&lt;code&gt;标准字体&lt;/code&gt;选中&lt;code&gt;幼圆&lt;/code&gt;（宋体等其他也可以）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/pig-deal-with-chinese/securecrt-appearance.png&quot; alt=&quot;securecrt-appearance&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/pig-deal-with-chinese/securecrt-font.png&quot; alt=&quot;securecrt-font&quot; /&gt;&lt;/p&gt;

&lt;p&gt;OK，到现在位置，使用&lt;code&gt;putty&lt;/code&gt;/&lt;code&gt;secureCRT&lt;/code&gt;连接远程服务器，再查看&lt;code&gt;UTF-8&lt;/code&gt;编码的中文文档时，就不会出现乱码了。下面测试一下效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;less filename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/pig-deal-with-chinese/less.png&quot; alt=&quot;less.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;pig&quot;&gt;Pig脚本解析中文文档&lt;/h2&gt;

&lt;p&gt;千呼万唤始出来、犹抱琵琶半遮面，使用pig来解析中文文档是本文的重点，却姗姗来迟。好的，先来回顾一下前面的工作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将pig脚本&lt;code&gt;select_rows.pig&lt;/code&gt;使用UTF-8格式编码、待分析的文档&lt;code&gt;sfzf.log&lt;/code&gt;也使用&lt;code&gt;UTF-8&lt;/code&gt;格式编码；&lt;/li&gt;
  &lt;li&gt;将两个文件传送到linux服务器上，并且使用&lt;code&gt;file –i filename&lt;/code&gt; 命令查看，确保其都为&lt;code&gt;UTF-8&lt;/code&gt;的编码格式；&lt;/li&gt;
  &lt;li&gt;设置&lt;code&gt;secureCRT&lt;/code&gt;或者&lt;code&gt;putty&lt;/code&gt;，保证其查阅中文文档时，无乱码；&lt;/li&gt;
  &lt;li&gt;到这一步了，直接运行pig脚本&lt;code&gt;select_rows.pig&lt;/code&gt;就可以了~哈哈（对，pig解析中文文档，就这么简单）；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Pig脚本&lt;code&gt;select_rows.pig&lt;/code&gt;内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* 查找输入文档中，包含关键字“时间”的行，并输出 */
A = load &#39;$input&#39; as (col1:chararray);
B = filter A by ($col1 matches &#39;.*时间.*&#39;);

store B into &#39;$output&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pig –x local –param input=sfzf.log –param output=out4 select_rows.pig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/pig-deal-with-chinese/result.png&quot; alt=&quot;result&quot; /&gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>Pig入门1h</title>
     <link href="http://ningg.github.com/introduction-to-pig"/>
     <updated>2014-05-08T00:00:00+08:00</updated>
     <id>http://ningg.github.com/introduction-to-pig</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;开篇先推荐一个PPT：&lt;a href=&quot;/download/pig/introduction-to-pig.pptx&quot; title=&quot;Pig简介，原理，简要说明&quot;&gt;Pig简介&lt;/a&gt;，简要介绍了Pig的基本原理，重点说明了其与MapReduce的关系。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;副标题&lt;/strong&gt;: Pig入门 &lt;em&gt;_之_&lt;/em&gt; 乱拳打死老师傅&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;从副标题展开说&lt;/h2&gt;

&lt;p&gt;先说一下为什么起这么一个副标题：前几天看电视剧消遣，有个小年轻，被质疑没有经验怎么办的时候，自己吹牛打气，说“我啥也不会，乱拳打死老师傅…”；这个，倒不是说对师傅的不尊敬，而是民间俗语，大概意思是：啥也不会的情况下，受领域内固有思想、规则约束的少，敢打敢拼，敢于突破陈规，往往能够带来新气象。&lt;em&gt;（不是要煽动大家起义、造反，而是，鼓励勇于突破、敢为天下先）。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Pig知识的学习\介绍，大部分人会按照如下思路开展：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pig解决什么问题；&lt;em&gt;（pig产生背景）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Pig Latin语言的基本语法；&lt;em&gt;（配合一些基本操作）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Pig Latin语言的高级语法；&lt;em&gt;（针对一些特有的、容易出错的用法，进行详细介绍）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Pig脚本的调试；&lt;em&gt;（脚本不是一气呵成的，需要一些调试分析手段）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Pig的可扩展部分；&lt;em&gt;（Pig提供的内建函数，无法满足需求时，需要自己动手来实现Pig的对外接口）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Pig性能调优；&lt;em&gt;（上面所有的步骤，都在说如何去使用Pig来完成一件事，现在会说一下如何把事做好、做漂亮）&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要这么多吗？学个东西，有这么复杂吗？&lt;em&gt;（上面开展的思路，是为了循序渐进、由浅入深，让你从原理到操作，能有一个全面的理解和掌握，嗯，一句话：为你好，才这么安排的）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;纳尼？我想说，你能直接一点么？上面&lt;code&gt;1、2、3、4、5、6&lt;/code&gt;，看起来头都大了，唉，我只想使用Pig，不想知道他是怎么来的。&lt;/p&gt;

&lt;p&gt;妥了，是个爽快的人，也算志同道合了，不多说：直接开始一步一步用Pig，让那些乱七八糟的东西见鬼去吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/introduction-to-pig/pig-logo.jpg&quot; alt=&quot;pig-logo&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;pig&quot;&gt;Pig用起来&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;一个例子&lt;/h3&gt;

&lt;p&gt;准备数据文件&lt;code&gt;student&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cat student
Jun L. 	18	3.7
Hhui H.	18	3.8
Ning G.	20	3.6
Hlong G.	22	3.6
Chang W.	21	3.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：上述文件中，姓名、年龄、GPA之间都以TAB键分隔；&lt;/p&gt;

&lt;p&gt;目标：求20岁以下和20岁以上的学生的人数以及gpa平均值&lt;/p&gt;

&lt;p&gt;进入执行Pig 脚本的交互模式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$pig –x local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;逐行输入如下pig脚本(&lt;code&gt;student_avg_gpa.pig&lt;/code&gt;)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;studentInfos = load ’student’ as (name: chararray, age:int, gpa:float);
studentBag = group studentInfos all;
result = foreach studentBag {
  student_younger = filter studentInfos by age &amp;lt;= 20;
  student_older = filter studentInfos by age &amp;gt; 20;
  generate COUNT(studentInfos) as totalNum, AVG(studentInfos.gpa) as avgGPA, 
	COUNT(student_younger) as youngerNum, AVG(student_younger.gpa) as youngerAvgGPA, 
	COUNT(student_older) as olderNum, AVG(student_older.gpa) as olderAvgGPA;
}
dump result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到结果了吗？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(5,3.659999942779541,3,3.699999968210856,2,3.5999999046325684)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;总共6个值（&lt;code&gt;,&lt;/code&gt;逗号分割）。&lt;/p&gt;

&lt;p&gt;对于结果的说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;总共5人；平均GPA：约3.66；&lt;/li&gt;
  &lt;li&gt;20岁以下（包含20岁）3人；平均GPA：约3.70；（pig对于float数据运算有误差）&lt;/li&gt;
  &lt;li&gt;20岁以上2人；平均GPA：约3.60；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;简要说一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; studentInfos = load ‘student’ as (name: chararray, age:int, gpa:float);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;load&lt;/code&gt;为加载数据的关键字，’student’表示数据文件位置，&lt;code&gt;as&lt;/code&gt; 关键字为前面数据文件指定field别名和field类型。&lt;/p&gt;

&lt;p&gt;可以使用如下命令，来查看一个&lt;code&gt;studentInfos&lt;/code&gt;的数据结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; describe studentInfos
studentInfos: {name: chararray,age: int,gpa: float}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用如下命令，查看&lt;code&gt;studentInfos&lt;/code&gt;的具体内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; dump studentInfos;
(Jun L.,18,3.7)
(Hhui H.,18,3.8)
(Ning G.,20,3.6)
(Hlong G.,22,3.6)
(Chang W.,21,3.6)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面 &lt;code&gt;describe&lt;/code&gt;、&lt;code&gt;dump&lt;/code&gt;命令输出的内容到底是什么玩意儿？&lt;/p&gt;

&lt;p&gt;我们来解释一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;studentInfos: {name: chararray,age: int,gpa: float}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示&lt;code&gt;studentInfos&lt;/code&gt;的结构：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;studentInfos&lt;/code&gt;是一个&lt;code&gt;relation&lt;/code&gt;，因为&lt;code&gt;studentInfos:{}&lt;/code&gt;指向&lt;code&gt;{}&lt;/code&gt;花括号；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;studentInfos&lt;/code&gt;内，&lt;code&gt;tuple&lt;/code&gt;的结构为：&lt;code&gt;(name: chararray,age: int,gpa: float)&lt;/code&gt;，即，包含3个字段，依次为&lt;code&gt;name&lt;/code&gt;、&lt;code&gt;age&lt;/code&gt;、&lt;code&gt;gpa&lt;/code&gt;，名字后&lt;code&gt;:&lt;/code&gt;之后为对应的类型；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面提到的&lt;code&gt;relation&lt;/code&gt;、&lt;code&gt;tuple&lt;/code&gt;是什么？从哪冒出来的？客官莫要着急，&lt;code&gt;relation&lt;/code&gt;、&lt;code&gt;tuple&lt;/code&gt;都是&lt;code&gt;Pig&lt;/code&gt;内部的几个概念，且听我慢慢道来。&lt;/p&gt;

&lt;p&gt;Pig定义了几个基本概念，用于描述数据结构：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;field&lt;/code&gt;，字段，某一位置的数据，即，(Jun L.,18,3.7)中包含了3个字段；类似RDBMS中Table中一行数据的一个字段；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;tuple&lt;/code&gt;，元组，是field的有序组合，使用&lt;code&gt;()&lt;/code&gt;来标识，即，&lt;code&gt;(Jun L.,18,3.7)&lt;/code&gt;表示一个tuple；类似RDBMS中Table中一行数据；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;bag&lt;/code&gt;，包，是tuple的无序组合，使用”{}”来标识，即，{(Jun L.,18,3.7),(Hhui H.,18,3.8)}表示包含2个&lt;code&gt;tuple&lt;/code&gt;的一个&lt;code&gt;bag&lt;/code&gt;；类似RDBMS中的一个Table；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;relation&lt;/code&gt;，关系，&lt;code&gt;outer bag&lt;/code&gt;，在此，暂时将&lt;code&gt;relation&lt;/code&gt;与&lt;code&gt;bag&lt;/code&gt;等价看待；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;：&lt;code&gt;field&lt;/code&gt;可以为任何类型，即，&lt;code&gt;tuple&lt;/code&gt;、&lt;code&gt;bag&lt;/code&gt;都可以作为&lt;code&gt;field&lt;/code&gt;，包含在&lt;code&gt;tuple&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;现在再回过头看一下，&lt;code&gt;studentInfos&lt;/code&gt;的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; describe studentInfos
studentInfos: {name: chararray,age: int,gpa: float}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是很明朗了？&lt;em&gt;（什么？还不明朗？把上面的分析读3遍）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;有人问&lt;code&gt;studentInfos: {name: chararray,age: int,gpa: float}&lt;/code&gt;中，&lt;code&gt;studentInfos&lt;/code&gt;这个&lt;code&gt;relation&lt;/code&gt;内部不应该是&lt;code&gt;tuple&lt;/code&gt;吗？&lt;code&gt;tuple&lt;/code&gt;不是应该以&lt;code&gt;()&lt;/code&gt;标识吗？为什么不是&lt;code&gt;studentInfos: {(name: chararray,age: int,gpa: float)}&lt;/code&gt;？这是因为&lt;code&gt;studentInfos&lt;/code&gt;中的&lt;code&gt;tuple&lt;/code&gt;不在一行，是分行输出的，下面会看到如果&lt;code&gt;relation&lt;/code&gt;中&lt;code&gt;tuple&lt;/code&gt;都在一行的情景。&lt;/p&gt;

&lt;p&gt;将&lt;code&gt;studentInfos&lt;/code&gt;按照所有字段进行&lt;code&gt;group&lt;/code&gt;，即使有某2个&lt;code&gt;tuple&lt;/code&gt;内容完全一致，也会统计为2个&lt;code&gt;tuple&lt;/code&gt;，即，本质上&lt;code&gt;group..all&lt;/code&gt;是将多行数据合并为一行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; studentBag = group studentInfos all;

grunt&amp;gt; describe studentBag;
studentBag: {group: chararray,studentInfos: {(name: chararray,age: int,gpa: float)}}

grunt&amp;gt; dump studentBag;
(all,{(Jun L.,18,3.7),(Hhui H.,18,3.8),(Ning G.,20,3.5),(Hlong G.,22,3.6),(Chang W.,21,3.6)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;：&lt;code&gt;group&lt;/code&gt;操作时，会生成一个&lt;code&gt;field&lt;/code&gt;，命名为&lt;code&gt;group&lt;/code&gt;，可以尝试如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; test = group studentInfos by age;

grunt&amp;gt; describe test;
test: {group: int,studentInfos: {(name: chararray,age: int,gpa: float)}}

grunt&amp;gt; dump test;
(18,{(Jun L.,18,3.7),(Hhui H.,18,3.8)})
(20,{(Ning G.,20,3.6)})
(21,{(Chang W.,21,3.6)})
(22,{(Hlong G.,22,3.6)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的命令：&lt;code&gt;load&lt;/code&gt;、&lt;code&gt;group&lt;/code&gt;多少有些过于简单，不刺激，不激动，下面的命令会有点意思：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; result = foreach studentBag {
&amp;gt;&amp;gt;   student_younger = filter studentInfos by age &amp;lt;= 20;
&amp;gt;&amp;gt;   student_older = filter studentInfos by age &amp;gt; 20;
&amp;gt;&amp;gt;   generate COUNT(studentInfos) as totalNum, AVG(studentInfos.gpa) as avgGPA, 
		COUNT(student_younger) as youngerNum, AVG(student_younger.gpa) as youngerAvgGPA, 
		COUNT(student_older) as olderNum, AVG(student_older.gpa) as olderAvgGPA;
&amp;gt;&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有点复杂？稍等，拆解一下，再复杂的命令也会变得简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;student_younger = filter studentInfos by age &amp;lt;= 20;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;filter..by..&lt;/code&gt;是过滤语句，此处，表示按照条件&lt;code&gt;age &amp;lt;= 20&lt;/code&gt;过滤出不到20岁的学生，并且将结果指定给&lt;code&gt;student_younger&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;generate COUNT(studentInfos) as totalNum, AVG(studentInfos.gpa) as avgGPA, 
	COUNT(student_younger) as youngerNum, AVG(student_younger.gpa) as youngerAvgGPA, 
	COUNT(student_older) as olderNum, AVG(student_older.gpa) as olderAvgGPA;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个&lt;code&gt;generate ..&lt;/code&gt;是生成数据的命令，&lt;code&gt;COUNT&lt;/code&gt;、&lt;code&gt;AVG&lt;/code&gt;都是内部提供的聚合函数，如果只调用如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;generate COUNT(studentInfos) as totalNum, AVG(studentInfos.gpa) as avgGPA;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示将&lt;code&gt;studentInfos&lt;/code&gt;中包含的学生个数，以及平均&lt;code&gt;gpa&lt;/code&gt;组合成一个&lt;code&gt;tuple&lt;/code&gt;，赋值个&lt;code&gt;result&lt;/code&gt;;&lt;code&gt;as..&lt;/code&gt; 为这些&lt;code&gt;field&lt;/code&gt;指定名字。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; describe result;
result: {totalNum: long,avgGPA: double,youngerNum: long,youngerAvgGPA: double,olderNum: long,olderAvgGPA: double}

grunt&amp;gt; dump result;
(5,3.6399999618530274,3,3.6666666666666665,2,3.5999999046325684)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;建议&lt;/strong&gt;：把上面的例子，再输入执行2遍，多使用&lt;code&gt;describe&lt;/code&gt;、&lt;code&gt;dump&lt;/code&gt;命令配合查看执行过程。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;练习一下&lt;/h3&gt;

&lt;p&gt;还是上面的&lt;code&gt;student&lt;/code&gt;数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cat student
Jun L. 	18	3.7
Hhui H.	18	3.8
Ning G.	20	3.6
Hlong G.	22	3.6
Chang W.	21	3.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：上述文件中，姓名、年龄、GPA之间都以TAB键分隔；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：20岁以下学生的人数以及gpa平均值，以及这些学生的名字（只要求算出这些，其他东西不要求）。&lt;/p&gt;

&lt;p&gt;这就成了上面问题的一部分，可以使用如下pig脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- 加载数据、设定field名字、设定field类型
studentInfos = load ’student’ as (name: chararray, age:int, gpa:float);

-- 找出20岁以下的学生
student_younger = filter studentInfos by age &amp;lt;= 20;

-- 要调用聚合函数COUNT\AVG必须进行group，将所有列，转换为一行
student_younger_bag = group student_younger all;

-- 输出学生人数、平均GPA，以及学生名单(下一条命令实际为一行)
result = foreach student_younger_bag generate COUNT(student_younger),
 AVG(student_younger.gpa), student_younger.name;

dump result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(3,3.699999968210856,{(Jun L.),(Hhui H.),(Ning G.)})&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;一篇博文&lt;/h2&gt;

&lt;p&gt;推荐codelast的一篇博文&lt;a href=&quot;http://www.codelast.com/?p=3621&quot;&gt;Apache Pig基础概念及用法&lt;/a&gt;, 不要着急，放松放松，CodeLast的这篇博客很轻松，嗯，很适合入门，在此向原博主致敬。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.codelast.com/?p=4550&quot;&gt;codeLast Apache Pig学习系列&lt;/a&gt;
&lt;em&gt;（个人看法：非常不错，适合直接上手写pig脚本；）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/21357721/&quot;&gt;Pig编程指南&lt;/a&gt;（Alan Gates著， 曹坤 译， 2013年2月  第1版） 
&lt;em&gt;(个人看法：有理论、有深度、有广度，每次都有新感觉；)&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://pig.apache.org/docs/r0.12.1/&quot;&gt;Pig documentation&lt;/a&gt;，
&lt;em&gt;(个人看法：特别详细，想要的东西，基本都能从这里找到，而且更新速度很快；)&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于Pig版本迭代速度比较快，所以个人建议，最好能去官网查看文档。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/introduction-to-pig/pig-on-elephant.png&quot; alt=&quot;pig-on-elephant&quot; /&gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>正则表达式（字符串匹配模式）</title>
     <link href="http://ningg.github.com/regular-expression"/>
     <updated>2014-05-04T00:00:00+08:00</updated>
     <id>http://ningg.github.com/regular-expression</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近师兄安排我用Pig解析一下日志文件，在数据装载过程中，需要抽取特定位置的字符串&lt;em&gt;（即使是数字、符号，在程序看来也是字符）。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;回想起之前的团队中，CZW对正则表达式进行过技术分享，深入浅出，反正当时我是听懂了，应该也达到了能用的水平，无奈10月左右的时间，只剩下点滴印象了，&lt;em&gt;（唉，时光已去，曾经掌握的东西，当要用时，又需要重新去学，这正是自己写技术博客的原因之一）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;不多说了，接下来，将整体上对正则表达式来一个梳理。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正则表达式，是什么？&lt;/h2&gt;

&lt;p&gt;正则表达式，英文原名: &lt;code&gt;Regular Expression&lt;/code&gt;（简称：&lt;code&gt;regex&lt;/code&gt;或&lt;code&gt;regexp&lt;/code&gt;），直接翻译：&lt;code&gt;有规律的式子&lt;/code&gt;，或者，可以翻译为&lt;code&gt;描述规律的式子&lt;/code&gt;。&lt;em&gt;(他奶奶的，不知道谁第一个翻译的，取名&lt;code&gt;正则表达式&lt;/code&gt;？忒高大上了，听上去完全不知到干什么的，还是&lt;code&gt;描述规律的式子&lt;/code&gt;容易理解)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/regular-expression/regular-expressions-comics.png&quot; alt=&quot;comics&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决什么问题？&lt;/h3&gt;

&lt;p&gt;通俗的说：查找满足一定规则的字符串。&lt;/p&gt;

&lt;p&gt;可用于文本的查找、替换。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;应用场景举例&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;场景1：仅查找出文本中单词&lt;code&gt;car&lt;/code&gt;，不想找出其他单词&lt;code&gt;scar&lt;/code&gt;、&lt;code&gt;carry&lt;/code&gt;等。&lt;/li&gt;
  &lt;li&gt;场景2：用户在注册页面填写Email时，检查Email地址格式是否正确。&lt;/li&gt;
  &lt;li&gt;场景3：查找指定目录下，文件名中包含&lt;code&gt;application&lt;/code&gt;字样的文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;正式定义&lt;/h3&gt;

&lt;p&gt;正则表达式，给个正式定义：按一定规则查找字符串，并可以进行替换操作。&lt;/p&gt;

&lt;p&gt;正则表达式，几点要注意的内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;有自己的语法规则，即，正则表达式语言；&lt;/li&gt;
  &lt;li&gt;不是正规的（完备的）程序设计语言，没有专门针对正则表达式的软件，来安装和运行；&lt;/li&gt;
  &lt;li&gt;常内置于其他软件/语言中；（即，其他语言实现了正则表达式规则的解析器）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当前，java/Python/PHP/JavaScript等，都支持正则表达式。&lt;/p&gt;

&lt;p&gt;支持正则表达式的语言\工具：&lt;a href=&quot;http://www.regular-expressions.info/tools.html&quot;&gt;Applications and Languages Related with RegEx&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;产生的启发点&lt;/h3&gt;

&lt;p&gt;1950年左右时，数学领域的一些研究工作&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://cns-classes.bu.edu/cn550/Readings/mcculloch-pitts-43.pdf&quot;&gt;A logical calculus of the ideas immanent in nervous activity&lt;/a&gt;, 1943;
Author: McCulloch, Warren S., and Walter Pitts;
简述：神经系统中神经元看作小巧而简单的自动控制单元。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.dlsi.ua.es/~mlf/nnafmc/papers/kleene56representation.pdf&quot;&gt;Representation of Events in Nerve Nets and Finite Automata&lt;/a&gt;, 1956;
Author: Kleene, Stephen C;
简述：“正则集合”的数学符号来描述此模型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;几年后，计算机领域借助上述研究成果，实现perl、grep等工具/语言，正则表达式进入实用阶段。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/regular-expression/regular-expression-introduction.png&quot; alt=&quot;illustration&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;校正&lt;/strong&gt;：上面图片&lt;code&gt;Illustration of Regular Expression&lt;/code&gt;中，&lt;code&gt;Meet c&lt;/code&gt;应该修正为&lt;code&gt;Meet b&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;怎么用？&lt;/h2&gt;

&lt;p&gt;正则表达式，俗称&lt;code&gt;描述规律的式子&lt;/code&gt;，用来查找字符串，基本逻辑是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如何匹配出1个字符；&lt;/li&gt;
  &lt;li&gt;如何匹配出n个字符；&lt;/li&gt;
  &lt;li&gt;如何匹配出特定位置的字符；（特定位置：字符串的开头、结尾）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-7&quot;&gt;匹配1个字符&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;a&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;一个字符&lt;code&gt;a&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[abc]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[..]表示集合内的任意一个字符，在此例中，[abc]表示a、b、c字符中的任意一个&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[^abc]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;除去a、b、c之外的任意一个字符，注意，&lt;code&gt;^&lt;/code&gt;只限于在&lt;code&gt;[^&lt;/code&gt;位置，才表示此含义&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[0123456789]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任意一个数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[a-z]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任意一个消息字母（在[]内&lt;code&gt;-&lt;/code&gt;为特殊字符，代表区间）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[0-9]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任意一个数字，等同于[0123456789]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;.&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任意一个字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\f&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;换页符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\t&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;制表键，tab&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\r&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;回车符，return&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\n&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;换行符，nextLine&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\v&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;垂直制表符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\w&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等价于[a-zA-Z0-9]，任何一个字母（区分大小写）、数字、下划线&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\W&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等价于[^a-zA-Z0-9]，任何一个非字母（区分大小写）、数字、下划线&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\d&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任何一个数字字符,等价于[0-9]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\D&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等价于[^0-9]，任何一个非数字字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\s&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等价于[ \f\n\r\t\v]，任何一个空白字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\S&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等价于[^ \f\n\r\t\v]，任何一个非空白字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\x0A&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;（16进制）对应ASCII字符10，即\n&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\011&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;（8进制）对应ASCII字符9，即\t&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;校正&lt;/strong&gt;：关于&lt;code&gt;\s&lt;/code&gt;,《&lt;a href=&quot;http://book.douban.com/subject/2269648/&quot; title=&quot;《正则表达式必知必会》2007年12月，第1版&quot;&gt;正则表达式必知必会&lt;/a&gt;》 版本信息（2007年12月，第1版），在Page 31中，&lt;code&gt;\s&lt;/code&gt;表示任何一个空白字符，应该包含空格&lt;code&gt; &lt;/code&gt;在内（具体参考：&lt;a href=&quot;http://www.regular-expressions.info/shorthand.html&quot;&gt;Shorthand Character Classes Of Regex&lt;/a&gt;）&lt;/p&gt;

&lt;h3 id=&quot;n&quot;&gt;匹配n个字符&lt;/h3&gt;

&lt;p&gt;匹配&lt;code&gt;n&lt;/code&gt;个字符，就是“匹配一个字符”重复&lt;code&gt;n&lt;/code&gt;次，嗯，很简单，则有：&lt;code&gt;aa&lt;/code&gt;，表示匹配连续两个字符&lt;code&gt;a&lt;/code&gt;；&lt;code&gt;\d\d&lt;/code&gt;,表示匹配2个数字；&lt;code&gt;\n\n\n&lt;/code&gt;,表示匹配3个换行符。&lt;em&gt;(很简单有木有)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;问题来了，假设有如下文本：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I $am$ the $god$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;目标：查找出&lt;code&gt;$..$&lt;/code&gt;间的内容，正则表达式怎么写？(&lt;code&gt;$..$&lt;/code&gt;间字符的个数，不能确定，只知道1个以上)&lt;/p&gt;

&lt;p&gt;我x，不是说要“匹配一个字符”重复&lt;code&gt;n&lt;/code&gt;次就可以么？关键现在&lt;code&gt;n&lt;/code&gt;是几啊？这怎么还是一个范围（&lt;code&gt;n&amp;gt;=1&lt;/code&gt;）？这如何是好？&lt;/p&gt;

&lt;p&gt;莫急莫急，请往下看。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;?&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0次或1次&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;+&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1次以上（a+：表示一个或多个a的连续出现；[0-9]+：表示一个或多个连续出现的数字）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;*&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0次及0次以上&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{3}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3次&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{ ,3}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0次–3次（包含0次和3次）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{1, }&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1次以上&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{1,3}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1次–3次（包含1次和3次）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;到这儿，就可以看出，使用 &lt;code&gt;$.+$&lt;/code&gt;就能匹配上面的内容了。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;匹配特定位置字符&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;在字符串开头&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;$&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;在字符串结尾&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\b&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;单词的边界&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\B&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;非单词的边界&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;匹配出如下文本中的cat单词：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;cat catt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;\bcat\b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;匹配如下文本中的&lt;code&gt;-&lt;/code&gt;，要求：只找出两个字母之间的&lt;code&gt;-&lt;/code&gt;，文本内容：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A-b - ss s- f-  - a-&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;\B-\B&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;过度匹配（贪婪）&lt;/h3&gt;

&lt;p&gt;要匹配文本&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ben@cib.com.cn&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;\w+@\w[\w\.]+\.\w+&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;理论上，可以匹配出：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;ben@baidu.com&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ben@baidu.com.cn&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是，上述匹配结果是2，即&lt;code&gt;ben@cib.com.cn&lt;/code&gt;。原因：&lt;code&gt;+&lt;/code&gt;、&lt;code&gt;*&lt;/code&gt;默认都是贪婪匹配，即找出最长的匹配模式；如果希望匹配出结果1，即&lt;code&gt;ben@cib.com&lt;/code&gt;，惰性匹配，找出最短的匹配模式，需要修改正则表达式：&lt;code&gt;\w+?@\w[\w\.]+?\.\w+?&lt;/code&gt;，即&lt;code&gt;+&lt;/code&gt;替换为&lt;code&gt;+?&lt;/code&gt;，&lt;code&gt;*&lt;/code&gt;替换为&lt;code&gt;*?&lt;/code&gt;。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;贪婪匹配&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;懒惰字符&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;*&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;*?&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;+&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;+?&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{n, }&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{n, }?&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-10&quot;&gt;补充说明&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;转义字符，例如，&lt;code&gt;\.&lt;/code&gt; 表示&lt;code&gt;.&lt;/code&gt;字符本身，单独&lt;code&gt;.&lt;/code&gt;表示匹配任意一个字符；&lt;code&gt;\?&lt;/code&gt;表示&lt;code&gt;?&lt;/code&gt;字符自身&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;表示其前后两种模式的任意一个，例如&lt;code&gt;(19|20)\d{2}&lt;/code&gt;，匹配19xx和20xx，xx表示任意两位数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;子表达式，整体上看作一个独立元素&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;假设有一个文本&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hello, my name is Ben&lt;code&gt;&amp;amp;nbsp;&lt;/code&gt; … Node.js, Linux&lt;code&gt;&amp;amp;nbsp;&amp;amp;nbsp;&lt;/code&gt;, and other tech.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在要匹配出连续的两个&lt;code&gt;&amp;amp;nbsp;&lt;/code&gt;，可以使用&lt;code&gt;&amp;amp;nbsp;&amp;amp;nbsp;&lt;/code&gt;，也可以使用&lt;code&gt;(&amp;amp;nbsp;){2}&lt;/code&gt;，而不能使用&lt;code&gt;&amp;amp;nbsp;{2}&lt;/code&gt;，因为&lt;code&gt;{2}&lt;/code&gt;，表示匹配其前面字符，实际&lt;code&gt;&amp;amp;nbsp;{2}&lt;/code&gt;等价与&lt;code&gt;&amp;amp;nbsp;;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;匹配IP：10.108.210.111&lt;/p&gt;

&lt;p&gt;正则表达式：&lt;code&gt;\d{1,3}\. \d{1,3}\. \d{1,3}\. \d{1,3}\ &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以替换为： &lt;code&gt;(\d{1,3}\.){3}\d{1,3}\ &lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;高级用法&lt;/h2&gt;

&lt;h3 id=&quot;section-12&quot;&gt;子表达式&lt;/h3&gt;

&lt;p&gt;前文提到过，在这儿单独拿出来说，是因为下文要用到。&lt;em&gt;（尼玛，下文难道不会用到前文其他内容么？凭什么单说&lt;code&gt;子表达式&lt;/code&gt;啊；因为，实在是怕你忘了，其他内容你即使忘了，也容易自己查找）&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;引用回溯&lt;/h3&gt;

&lt;p&gt;本质：前后匹配一致；&lt;/p&gt;

&lt;p&gt;技术上实质：后半部分引用前半部分匹配到的子表达式。&lt;/p&gt;

&lt;p&gt;举例：&lt;/p&gt;

&lt;p&gt;匹配如下文档中重复输入的单次：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This is a block of of text, several words here are are repeated, and and they should not be.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;[ ]+(\w+)[ ]+\1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\1&lt;/code&gt;表示&lt;code&gt;(\w+)&lt;/code&gt;中匹配到的内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：回溯引用中&lt;code&gt;\1&lt;/code&gt;,&lt;code&gt;\2&lt;/code&gt;只能一用子表达式（即用&lt;code&gt;()&lt;/code&gt;括起来的部分），&lt;code&gt;\0&lt;/code&gt;代表整个正则表达式匹配的结果。&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;前后查找&lt;/h3&gt;

&lt;p&gt;本质：匹配全部，返回局部；&lt;/p&gt;

&lt;p&gt;技术上实质：将子表达式向前（后）匹配到字符串返回。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;向前查找： 正 向前查找&lt;code&gt;exp2(?=exp1)&lt;/code&gt;， 负 向前查找&lt;code&gt;(exp2(?!exp1))&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;向后查找： 正 向后查找&lt;code&gt;(?&amp;lt;=exp1)exp2&lt;/code&gt;， 负 向后查找&lt;code&gt;(?&amp;lt;!exp1)exp2&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注：上式都是匹配&lt;code&gt;exp1&lt;/code&gt;，返回&lt;code&gt;exp2&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;举例1：&lt;/p&gt;

&lt;p&gt;匹配如下文本中的传输协议&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://www.baidu.com&lt;/p&gt;

  &lt;p&gt;ftp://ftp.baidu.com&lt;/p&gt;

  &lt;p&gt;https://mails.baidu.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;.+(?=:)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;举例2：&lt;/p&gt;

&lt;p&gt;匹配如下文本中的金额&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;abc: $23.01&lt;/p&gt;

  &lt;p&gt;hdc: $899.00&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;(?&amp;lt;=\$)\d[\d.]*\d&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;嵌入条件&lt;/h3&gt;

&lt;p&gt;可以添加逻辑条件，类似if。&lt;/p&gt;

&lt;p&gt;说几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;功能很强大；&lt;/li&gt;
  &lt;li&gt;使用的不是很多；&lt;/li&gt;
  &lt;li&gt;真要了解一下，参考《&lt;a href=&quot;http://book.douban.com/subject/2269648/&quot; title=&quot;《正则表达式必知必会》2007年12月，第1版&quot;&gt;正则表达式必知必会&lt;/a&gt;》&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-16&quot;&gt;元字符？&lt;/h3&gt;

&lt;p&gt;啥？元字符？什么东东？小伙儿，不要激动。正则表达式为了描述匹配哪些位置的字符串，使用了&lt;code&gt;.&lt;/code&gt;,&lt;code&gt;\d&lt;/code&gt;,&lt;code&gt;\s&lt;/code&gt;,&lt;code&gt;\w&lt;/code&gt;,&lt;code&gt;\W&lt;/code&gt;,&lt;code&gt;^&lt;/code&gt;,&lt;code&gt;[]&lt;/code&gt;,&lt;code&gt;()&lt;/code&gt;,&lt;code&gt;|&lt;/code&gt;,&lt;code&gt;$&lt;/code&gt;，来描述正则表达式语言的语法，即，这些字符是表述&lt;code&gt;正则表达式语言&lt;/code&gt;语法规则的字符，成为这个语言的元字符。&lt;/p&gt;

&lt;h2 id=&quot;section-17&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/2269648/&quot; title=&quot;《正则表达式必知必会》2007年12月，第1版&quot;&gt;正则表达式必知必会&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.regular-expressions.info/tutorial.html&quot;&gt;Regex Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-18&quot;&gt;休息一下&lt;/h2&gt;

&lt;p&gt;你能读懂下面这张图片吗？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/regular-expression/regex-example.png&quot; alt=&quot;regex-example&quot; /&gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>GitHub上搭建个人网站</title>
     <link href="http://ningg.github.com/build-blog-with-github"/>
     <updated>2014-05-02T00:00:00+08:00</updated>
     <id>http://ningg.github.com/build-blog-with-github</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;0.背景&lt;/h2&gt;

&lt;p&gt;准备重新捡起博客，记录自己的生活，特别是技术生活&lt;em&gt;（过于私密的东西，也不敢往博客上放不是）。&lt;/em&gt;个人博客有两个途径：a.使用已有的博客网站; b.搭建自己的私人网站。调研了一下国内博客网站，（&lt;a href=&quot;http://www.csdn.net/&quot; title=&quot;CSDN&quot;&gt;CSDN&lt;/a&gt;、&lt;a href=&quot;http://www.iteye.com/&quot; title=&quot;javaEye(现在更名为ITeye)&quot;&gt;javaEye&lt;/a&gt;、&lt;a href=&quot;http://www.oschina.net/&quot; title=&quot;OSCHINA&quot;&gt;OSCHINA&lt;/a&gt;等）普遍文字格式、代码编排样式不是很喜欢&lt;em&gt;（太挑剔了？对，我就是一个挑剔的人），&lt;/em&gt;这让自己转向私人博客。可以预想到，自己搭建要稍微复杂一点，话又说回来了，作为&lt;code&gt;software engineer&lt;/code&gt;折腾网站也算看家本领了&lt;em&gt;（我会告诉你我的目标是&lt;code&gt;scientist&lt;/code&gt;么）。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;既然要搭自己的私人博客，那选定什么框架/方案呢？之前使用&lt;a href=&quot;https://wordpress.org/&quot; title=&quot;WordPress&quot;&gt;WordPress&lt;/a&gt;搭过，但需要购买域名和空间；现在流行在&lt;a href=&quot;https://github.com/about&quot; title=&quot;GitHub&quot;&gt;GitHub&lt;/a&gt;上搭，并且不需要考虑域名和空间的问题，那就他了，上&lt;a href=&quot;https://github.com/about&quot; title=&quot;GitHub&quot;&gt;GitHub&lt;/a&gt;，走起&lt;em&gt;（其实，国内也有一个类似的地方&lt;a href=&quot;https://gitcafe.com/&quot; title=&quot;GitCafe&quot;&gt;GitCafe&lt;/a&gt;，不过，出于装B需要，最终选定了&lt;a href=&quot;https://github.com/about&quot; title=&quot;GitHub&quot;&gt;GitHub&lt;/a&gt;）。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;1.做什么？&lt;/h2&gt;

&lt;p&gt;目标：私人博客、自己搭建。&lt;/p&gt;

&lt;p&gt;方式：&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/build-blog-with-github/blog-or-not.jpg&quot; alt=&quot;blog or not&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;2.怎么做？&lt;/h2&gt;

&lt;p&gt;初步分析，在&lt;a href=&quot;https://github.com/about&quot; title=&quot;GitHub&quot;&gt;GitHub&lt;/a&gt;上搭建博客，实质是：将自己的博客内容上传到GitHub上&lt;em&gt;（因为GitHub提供了空间）；&lt;/em&gt;如果需要修改博客内容，则需要从GitHub上将download/pull下来；接下来就是让外面可以访问GitHub上的博客。总结一下，对应3个必要步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;GitHub上创建工程、并且能够将GitHub上的文件/代码，下载到本地；&lt;/li&gt;
  &lt;li&gt;将本地的文件/代码，上传到GitHub上；&lt;/li&gt;
  &lt;li&gt;配置GitHub，使其对外提供私人博客的访问页面；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;好了，上面是凭空想出来的&lt;em&gt;（任何地方搭建博客，都是上面的逻辑步骤，而不仅限于GitHub）；&lt;/em&gt;那实际如何操作呢？具体分为4个阶段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;熟悉&lt;a href=&quot;https://github.com/about&quot; title=&quot;GitHub&quot;&gt;GitHub&lt;/a&gt;的基本操作（创建工程、上传代码、下载代码）；&lt;/li&gt;
  &lt;li&gt;利用&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;功能，搭建简易网站；&lt;/li&gt;
  &lt;li&gt;利用&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;jekyll&lt;/a&gt;，增强网站功能（除了jekyll，还有其他的方式）；&lt;/li&gt;
  &lt;li&gt;在&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;jekyll&lt;/a&gt;框架下，依照个人偏好，进行定制；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;3.实际操作&lt;/h2&gt;

&lt;h3 id=&quot;github&quot;&gt;3.1GitHub的基本操作&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/set-up-git&quot;&gt;安装使用Git（GitHub上传、下载文件的工具）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/create-a-repo&quot;&gt;GitHub上创建项目（其中包含了，GitHub上传文件的Git命令）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/fork-a-repo&quot;&gt;GitHub上Fork项目（其中包含了，GitHub下载文件的Git命令）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;补充：&lt;a href=&quot;https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line&quot;&gt;上传文件至GitHub&lt;/a&gt;；另外，向GitHub提交代码时，按照上面的操作方式，需要每次都输入GitHub的用户名和密码，可以采用&lt;code&gt;SSH Keys&lt;/code&gt;的方式来解决此问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/build-blog-with-github/git-github.png&quot; alt=&quot;git-github&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;3.2如何搭建博客？&lt;/h3&gt;

&lt;p&gt;GitHub上对于个人博客的支持，实质是利用GitHub Pages功能来实现的，具体操作：&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;,认真读一遍，5mins，一步一步操作下来，简易博客就搭建成功了（一个简单的欢迎页面&lt;code&gt;index.html&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;补充：扩展阅读&lt;a href=&quot;https://help.github.com/categories/20/articles&quot;&gt;GitHub Pages FAQ&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/build-blog-with-github/github-pages.jpg&quot; alt=&quot;github-pages&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;jekyll&quot;&gt;3.3Jekyll增强博客网站功能&lt;/h3&gt;

&lt;p&gt;详细阅读”&lt;strong&gt;3.2如何搭建博客&lt;/strong&gt;“中提到的&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;的童鞋，在&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;页面最下端一定注意到了&lt;a href=&quot;http://jekyllrb.com/docs/quickstart/&quot;&gt;Blogging with Jekyll&lt;/a&gt;，对，就是他，读一遍，操作一下，搞定。&lt;/p&gt;

&lt;p&gt;补充：jekyll用起来倒是用起来了，怎么发表一遍博文呢？这个…额…等到学会 “&lt;strong&gt;3.4 基于jekyll框架，定制博客&lt;/strong&gt;” 再去写博客吧，现在建议把上面的操作反复看两遍，捋一捋逻辑流程。&lt;/p&gt;

&lt;h3 id=&quot;jekyll-1&quot;&gt;3.4基于jekyll框架，定制博客&lt;/h3&gt;

&lt;p&gt;先看一下两个使用jekyll框架的博客：&lt;a href=&quot;http://beiyuu.com/&quot;&gt;BeiYuu&lt;/a&gt; &amp;amp; &lt;a href=&quot;http://havee.me/&quot;&gt;Havee&lt;/a&gt;，他们对应的模版在GitHub上都可以找到：&lt;a href=&quot;https://github.com/beiyuu/beiyuu.github.com&quot;&gt;BeiYuu.com Template of GitHub&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://github.com/Ihavee/ihavee.github.io&quot;&gt;Havee.me Template of GitHub&lt;/a&gt;。 &lt;/p&gt;

&lt;p&gt;先膜拜一下上面两个博客模板，&lt;em&gt;光彩夺目，亮瞎一双狗眼，&lt;/em&gt;好了，我能不能也搭建一个类似的博客？途径有一个：深入学习一下&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll的官方文档&lt;/a&gt;，补充：&lt;a href=&quot;http://jekyllcn.com/&quot;&gt;中文版本&lt;/a&gt;。&lt;em&gt;（基于jekyll，如何定制博客，我将写一篇详细的介绍，敬请期待）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;faq&quot;&gt;4.FAQ&lt;/h2&gt;

&lt;h3 id=&quot;google-analytics&quot;&gt;4.1使用google analytics来统计网站访问情况&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;注册&lt;a href=&quot;http://www.google.com/analytics/&quot;&gt;Google Analytics&lt;/a&gt;账户；&lt;/li&gt;
  &lt;li&gt;在账户下，添加要监控的网站信息，&lt;a href=&quot;http://www.google.com/analytics/&quot;&gt;Google Analytics&lt;/a&gt;会生成跟踪信息的JS片段；&lt;/li&gt;
  &lt;li&gt;将上述JS片段插入到自己想要统计的页面上；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体设置细节：请查看&lt;a href=&quot;http://www.google.com/intl/zh-CN_ALL/analytics/learn/index.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;discus&quot;&gt;4.2如何DISCUS作为评论插件？&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;注册&lt;a href=&quot;http://disqus.com/&quot;&gt;DISQUS&lt;/a&gt;账户；&lt;/li&gt;
  &lt;li&gt;登录后，点击&lt;code&gt;Add Disqus to your site&lt;/code&gt;按钮，操作下去，最终将获得相应的JS片段；&lt;/li&gt;
  &lt;li&gt;将上述JS片段插入到自己想要包含评论的页面即可；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;latex&quot;&gt;4.3配置网站，支持LaTeX语法&lt;/h3&gt;

&lt;p&gt;配置博客，支持&lt;a href=&quot;http://www.latex-project.org/&quot;&gt;LaTeX&lt;/a&gt;公式，此次设置&lt;a href=&quot;http://kramdown.gettalong.org&quot;&gt;kramdown&lt;/a&gt;来解析&lt;a href=&quot;http://daringfireball.net/projects/markdown/syntax&quot;&gt;Markdown&lt;/a&gt;文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
If you have sufficient control over the publishing process
(e.g. you are running Jekyll yourself), an easy solution is
to switch the markdown parser to one that supports TeX.
*/

//For example, using kramdown:
gem install kramdown

//Change the markdown line in _config.yml to
markdown: kramdown

//and add something like
&amp;lt;script type=&quot;text/javascript&quot; 
src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&amp;gt;
&amp;lt;/script&amp;gt;
//to _layouts/default.html. 

//Now you can simply mark any mathematics in your posts with $$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;http://stackoverflow.com/questions/10987992/using-mathjax-with-jekyll&quot;&gt;Using MathJax with Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;4.3遇到的问题&amp;amp;解决办法？&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/dengjianqiang2011/article/details/9260435&quot;&gt;执行Git命令时，出错提示：（fatal: remote origin already exists.）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/migrating-your-pages-site-from-maruku&quot;&gt;GitHub上markdown的解析引擎不同，会造成最终页面效果的差异&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;jekyll serve启动出错提示：（Liquid Exception: invalid byte sequence in GBK）&lt;strong&gt;见下文&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;修改&lt;code&gt;\Ruby200\lib\ruby\gems\2.0.0\gems\jekyll-1.0.3\lib\jekyll&lt;/code&gt;目录下的&lt;code&gt;convertible.rb&lt;/code&gt;文件，将其中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.content = File.read(File.join(base, name))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.content = File.read(File.join(base, name),:encoding=&amp;gt;&quot;utf-8&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果上述修改之后，仍然提示出错，则：&lt;code&gt;...\lib\jekyll\tags&lt;/code&gt;目录下&lt;code&gt;include.rb&lt;/code&gt;文件，类似对于&lt;code&gt;convertible.rb&lt;/code&gt;文件的操作；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/build-blog-with-github/github-social-coding.png&quot; alt=&quot;github-social-coding&quot; /&gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>java 重载 & 重写</title>
     <link href="http://ningg.github.com/override-overload-of-java"/>
     <updated>2014-01-14T00:00:00+08:00</updated>
     <id>http://ningg.github.com/override-overload-of-java</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;问题背景&lt;/h2&gt;

&lt;p&gt;阅读程序时，看到在子类中的各种@Override的注解，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class A{
	public void speak(int i){
		  ...
	}
	...
}
 
public class B extends A{
	@Override
	public void speak(int i){
		  ...
	}
	...
	public static void main(String[] args){
		B b = new B();
		A a1;
		a1 = (A)b;
 
		a1.speak(1);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类&lt;code&gt;B&lt;/code&gt;继承了&lt;code&gt;A&lt;/code&gt;，并且在&lt;code&gt;B&lt;/code&gt;中&lt;code&gt;Override&lt;/code&gt;了方法&lt;code&gt;speak()&lt;/code&gt;;现在问&lt;code&gt;a1.speak(1)&lt;/code&gt;调用的是&lt;code&gt;class A&lt;/code&gt;？&lt;code&gt;class B&lt;/code&gt;？中的&lt;code&gt;speak()&lt;/code&gt;方法？&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分析&lt;/h2&gt;

&lt;p&gt;上面的例子是一个典型的&lt;code&gt;重写&lt;/code&gt;，因为：&lt;code&gt;subclass&lt;/code&gt;中方法的名称、输入参数、返回参数都与&lt;code&gt;supclass&lt;/code&gt;中完全相同。&lt;/p&gt;

&lt;p&gt;现在有一个问题：重写的方法前没有&lt;code&gt;@Override&lt;/code&gt;行不行？&lt;em&gt;(这个问题很好，说明you’re thinking。)&lt;/em&gt;没有&lt;code&gt;@Override&lt;/code&gt;的注解完全可以，只需要满足：&lt;code&gt;subclass&lt;/code&gt;中方法的名称、输入参数、返回参数与&lt;code&gt;supclass&lt;/code&gt;中完全相同即可实现方法的重写。&lt;/p&gt;

&lt;p&gt;现在问题又来了：既然没有&lt;code&gt;@Override&lt;/code&gt;也能实现方法的重写，为什么很多地方都加了&lt;code&gt;@Override&lt;/code&gt;？原因很简单，添加了&lt;code&gt;@Override&lt;/code&gt;，编译器会依照&lt;code&gt;supclass&lt;/code&gt;中方法来进行检查，保证此方法真的实现重写。（避免了因为粗心等造成的&lt;code&gt;bug&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重写（&lt;code&gt;override&lt;/code&gt;）&lt;/strong&gt;：就是覆盖；基于继承的，重写父类的方法，方法名什么都一样，方法体不同。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;相同的名称；&lt;/li&gt;
  &lt;li&gt;相同的返回类型；&lt;/li&gt;
  &lt;li&gt;子类中，重写的方法访问修饰符权限保持一致，或者增大（&lt;code&gt;public&lt;/code&gt;&amp;gt;&lt;code&gt;protected&lt;/code&gt;&amp;gt;&lt;code&gt;default&lt;/code&gt;&amp;gt;&lt;code&gt;private&lt;/code&gt;）；&lt;/li&gt;
  &lt;li&gt;子类中，重写的方法抛出的异常不能变的更宽泛；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;重载（&lt;code&gt;overload&lt;/code&gt;）&lt;/strong&gt;：基于同一个类的，不同的重载方法，主要是参数列表不同&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;相同的名称；&lt;/li&gt;
  &lt;li&gt;必须有不同的参数列表；&lt;/li&gt;
  &lt;li&gt;可以有不同的返回类型，可以有不同的访问修饰符，可以抛出不同的异常；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;重写 &amp;amp; 重载&lt;/strong&gt;：都是多态性的体现，重写是子类与父类间的多态性，重载是同一类中多态性的体现。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参考来源&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/smyhmz/article/details/2716638&quot;&gt;http://blog.csdn.net/smyhmz/article/details/2716638&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/leonardwang/article/details/7046180&quot;&gt;http://blog.csdn.net/leonardwang/article/details/7046180&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>Linux 后台运行命令</title>
     <link href="http://ningg.github.com/linux-cmd-run-in-background"/>
     <updated>2013-01-17T00:00:00+08:00</updated>
     <id>http://ningg.github.com/linux-cmd-run-in-background</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;问题背景&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;SecureCRT&lt;/code&gt;/&lt;code&gt;putty&lt;/code&gt;等客户端，远程连接Linux服务器，并且执行脚本时，由于网络不稳定，有可能导致连接中断，在这种情况下，我担心会影响脚本程序的正常执行（不能肯定是否一定会影响）；因此希望启动一个脚本，让其在后台一直运行，不会随着&lt;code&gt;连接中断&lt;/code&gt;而中断掉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;外加问题&lt;/strong&gt;：现在一个命令的输出信息过多，希望后台运行时，不保存输出信息。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;解决办法&lt;/h2&gt;

&lt;p&gt;先说最终的解决办法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nohup sh collectCloSpan.sh &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行上面命令即可。输出信息在当前路径的&lt;code&gt;nohup.out&lt;/code&gt;文件中。（如果当前路径不允许新建文件，则，输出信息保存在&lt;code&gt;~/nohup.out&lt;/code&gt;文件中）&lt;/p&gt;

&lt;p&gt;好了，现在怎么解决解决&lt;code&gt;nohup.out&lt;/code&gt;文件过大的问题呢？&lt;/p&gt;

&lt;p&gt;经过查询有2个解决思路：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;完全删除输出信息：一点输出信息都不想要；&lt;/li&gt;
  &lt;li&gt;删除过时的输出信息，只保留最近一段时间的输出信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完全删除输出信息：在程序后台运行之后，直接删除文件nohup.out文件即可，除非重新运行程序，否则，不会再有&lt;code&gt;nohup.out&lt;/code&gt;文件；&lt;/p&gt;

&lt;p&gt;删除过时的输出信息（在线清空文件内容）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*执行效率较高*/
cp /dev/null nohup.out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*文件很大时，执行较慢*/
cat /dev/null &amp;gt; nohup.out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于&lt;code&gt;/dev/null&lt;/code&gt;到底是什么，自己&lt;code&gt;google&lt;/code&gt;或者&lt;code&gt;baidu&lt;/code&gt;吧。&lt;/p&gt;

&lt;p&gt;感兴趣的可以具体看下面的详细说明。&lt;em&gt;（不感兴趣的可以直接跳过了）。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;细节分析&lt;/h2&gt;

&lt;p&gt;后台运行脚本，有多种解决方法，此处只说一个比较常用的，具体如下（&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/&quot;&gt;参考1&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nohup ping www.baidu.com &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后等待，出现如下结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux-cmd-run-in-background/linux-cmd-run-in-background.jpg&quot; alt=&quot;LINUX后台运行命令nohup测试&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入命令&lt;code&gt;jobs&lt;/code&gt;可以查看现有的后台程序，如上图；并且可以使用&lt;code&gt;fg 1&lt;/code&gt;命令，将第一个后台程序，调入前台。
输入后台运行命令&lt;code&gt;nohup ping www.baidu.com &amp;amp;&lt;/code&gt;后，如果没有返回到原来的&lt;code&gt;shell&lt;/code&gt;，则中间直接敲&lt;code&gt;回车(Enter)&lt;/code&gt;即可，等到返回原来&lt;code&gt;shell&lt;/code&gt;环境之后，可以使用&lt;code&gt;exit&lt;/code&gt;命令退出；如上图所示。再次使用&lt;code&gt;SecureCRT&lt;/code&gt;/&lt;code&gt;putty&lt;/code&gt;等终端登录，并输入如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ps –ef | grep “ping”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到上图中结果，原来的程序&lt;code&gt;pid&lt;/code&gt;为&lt;code&gt;13380&lt;/code&gt;还在执行，只是此进程的父进程改为&lt;code&gt;pid=1&lt;/code&gt;的特殊进程。程序运行过程中，所有输出自动输出到当前目录的&lt;code&gt;nohup.out&lt;/code&gt;文件中（具体&lt;a href=&quot;http://www.linuxidc.com/Linux/2010-09/28366.htm&quot;&gt;参考2&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;疑问1&lt;/strong&gt;：后台运行：&lt;code&gt;command &amp;amp; &lt;/code&gt;和 &lt;code&gt;nohup command &amp;amp;&lt;/code&gt;有区别吗？&lt;/p&gt;

&lt;p&gt;答：&lt;code&gt;command &amp;amp;&lt;/code&gt;：后台运行，关掉中断，命令会终止运行；&lt;code&gt;nobup command &amp;amp;&lt;/code&gt;：后台运行，关掉终端，命令会继续运行。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参考来源&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/&quot;&gt;https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.linuxidc.com/Linux/2010-09/28366.htm&quot;&gt;http://www.linuxidc.com/Linux/2010-09/28366.htm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/lwm-1988/archive/2011/08/20/2147299.html&quot;&gt;http://www.cnblogs.com/lwm-1988/archive/2011/08/20/2147299.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux-cmd-run-in-background/scene-background.jpg&quot; alt=&quot;scene&quot; /&gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>使用数据库查找材料</title>
     <link href="http://ningg.github.com/how-to-use-lib"/>
     <updated>2012-11-30T00:00:00+08:00</updated>
     <id>http://ningg.github.com/how-to-use-lib</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;图书馆数据库的使用&lt;/h2&gt;

&lt;p&gt;3年前在本科的时候，上过一门课“文献检索”，当时主要学了一点cnki使用的知识，没多久就忘掉了，现在想想造成这个结果有两个原因：1.当时学习就不求甚解，学习的时候，只是想到在考核上要达标，没有记录一些实用的检索手段；2.后来使用cnki的次数也少。要查找东西得时候，自己都是google，这是个好的习惯，但是，这只是初级水平；要达到中等水平，需要熟练专业数据库的检索。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/how-to-use-lib/lib-floor.jpg&quot; alt=&quot;lib-floor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在越来越发现，数据库的使用是多么的重要。特别是在资料查询上，如果使用数据库检索得心应手，就会节省很多时间，而且，能够很精确的找到自己想要的材料。&lt;/p&gt;

&lt;p&gt;本次主要介绍一些外文数据库的使用，具体包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://libra.msra.cn&quot;&gt;微软学术&lt;/a&gt;：包含范围比较广&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://scholar.google.com/&quot;&gt;google学术&lt;/a&gt;：最近几年，相比于&lt;a href=&quot;http://libra.msra.cn&quot;&gt;微软学术&lt;/a&gt;，能够实时收录最新的论文&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://acm.lib.tsinghua.edu.cn/acm/Main.nsp&quot;&gt;ACM&lt;/a&gt;：具体查找顶级会议、期刊的电子资源&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ieeexplore.ieee.org/&quot;&gt;IEEE&lt;/a&gt;：具体查找顶级会议、期刊的电子资源&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;微软学术搜索&lt;/h2&gt;

&lt;p&gt;网址：&lt;a href=&quot;http://libra.msra.cn&quot;&gt;http://libra.msra.cn&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在搜索框中，直接进行检索，例如“decision tree for mining data stream”；&lt;/li&gt;
  &lt;li&gt;（可选）添加高级搜索条件“advanced search”；&lt;/li&gt;
  &lt;li&gt;在左边栏中，选择搜索的领域，例如选择“Computer Science”；&lt;/li&gt;
  &lt;li&gt;在左边栏中，选择搜索的“Author\Conferences\Journals\Organizations”；（注意只选这几个关键字，而不要选择关键字下面具体的内容）&lt;/li&gt;
  &lt;li&gt;在打开的界面中，依次选择“related publication(s)”即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;google&quot;&gt;google学术搜索&lt;/h2&gt;

&lt;p&gt;网址：&lt;a href=&quot;http://scholar.google.com/&quot;&gt;http://scholar.google.com/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;acm&quot;&gt;ACM&lt;/h2&gt;

&lt;p&gt;网址：&lt;a href=&quot;http://acm.lib.tsinghua.edu.cn/acm/Main.nsp&quot;&gt;http://acm.lib.tsinghua.edu.cn/acm/Main.nsp&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首页可选择浏览“Special Interest Groups（SIGs）”或者“Transactions”等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ieee&quot;&gt;IEEE&lt;/h2&gt;

&lt;p&gt;网址：&lt;a href=&quot;http://ieeexplore.ieee.org/&quot;&gt;http://ieeexplore.ieee.org/&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首页选择范围“conference Publications”或者“Journal &amp;amp; Magazines”；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/how-to-use-lib/lib-book.jpg&quot; alt=&quot;lib-book&quot; /&gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>非通信专业，如何对通信有一个整体的认识</title>
     <link href="http://ningg.github.com/frame-of-communication-knowledge"/>
     <updated>2012-11-30T00:00:00+08:00</updated>
     <id>http://ningg.github.com/frame-of-communication-knowledge</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;今天有人问我，不是通信专业怎么才能对通信以及通信网络有个整体的认识，大概想了一下，列了一下自己的想法，如果有错误的地方还请大家帮忙改正。 &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bbs.byr.cn/&quot;&gt;北邮人论坛&lt;/a&gt;的注册用户&lt;code&gt;bacbyr (比爱成)&lt;/code&gt;和&lt;code&gt;wuxuguang ( 水炎) &lt;/code&gt;都推荐《&lt;a href=&quot;http://book.douban.com/subject/4199502/&quot;&gt;大话无线通信&lt;/a&gt;》，评语：理解清清楚楚，就靠它入门了；比较生动形象，一下子就能翻几十页，很痛快。&lt;/p&gt;

&lt;p&gt;看来《&lt;a href=&quot;http://book.douban.com/subject/4199502/&quot;&gt;大话无线通信&lt;/a&gt;》这本书值得一读。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;个人观点&lt;/h2&gt;

&lt;p&gt;要对通信有整体认识，需要解决下面几个问题： &lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.什么是通信？&lt;/h3&gt;

&lt;p&gt;我的理解，双方进行信息交换过程就是通信。 &lt;/p&gt;

&lt;p&gt;举例：你和隔壁的吴老二，俩人的聊天过程就是一个典型的通信过程。见下图： &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/frame-of-communication-knowledge/talk-with-neighbour.jpg&quot; alt=&quot;talk-with-neighbour&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;2.什么是通信网？&lt;/h3&gt;

&lt;p&gt;通信网是由基本通信系统组成的，一个基本的通信系统包括：信源、信道、信宿；信源实际就是发信者，信宿就是收信者；信源产生的信息，通过信道进行传输，最终到达信宿。 &lt;/p&gt;

&lt;p&gt;举例：具体，在聊天过程中，当你在说、隔壁吴老二在听的时候，你是信源（发信者），空气是信道（无线信道有木有），吴老二是信宿（收信者）；反之，自己想。基本通信系统，见下图： &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/frame-of-communication-knowledge/base-unit.jpg&quot; alt=&quot;base-unit&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;3.通信知识框架-基础&lt;/h3&gt;

&lt;p&gt;（理解了上面两个问题，再看这一个）上面提到的“通信系统”虽然很简单，只是由“信源、信道、信宿”构成，但是却引出整个通信的知识。简要说明如下： &lt;/p&gt;

&lt;h4 id=&quot;a&quot;&gt;a)信源发出的信息，一般都是模拟信号，需要经过数字化处理，之后还需要信息编码；（对不同信息：声音、图像、视频等，都有各色各样的编码技术）什么编码方式能保证不失真，需要信息论的知识；&lt;/h4&gt;

&lt;h4 id=&quot;b&quot;&gt;b)经过处理的信息，要想在信道上传输，需要信道编码；（对于不同信道，主要是有线信道、无线信道，根据信道特性不同，使用不同的传输技术；特别需要说明的是，在不同情况下，信道的衰减特性不同，使用不同的信息增强技术）&lt;/h4&gt;

&lt;h4 id=&quot;c&quot;&gt;c)信宿收到信息之后，需要进行与信源相反的操作：解码。&lt;/h4&gt;

&lt;p&gt;举例：具体，就好比，你跟隔壁吴老二距离很近的时候，直接说话聊天，你俩人都能听清楚；但是当你俩距离很远时，直接说话对方不一定能听清楚，这就需要经过一些处理，才能保证你俩能继续聊天，例如，用大喇叭来放大声音等。见下图： &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/frame-of-communication-knowledge/talk-with-neighbour-advance.jpg&quot; alt=&quot;talk-with-neighbour-advance&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;4.通信知识框架-深入&lt;/h3&gt;

&lt;p&gt;（理解了上面三个问题，再看这一个）进一步，想构成一个能容纳多用户的通信网，就涉及到一些列的技术： &lt;/p&gt;

&lt;h4 id=&quot;a-1&quot;&gt;a)双工技术：双工技术是什么？能解决什么问题？（单工、半双工、双工）&lt;/h4&gt;

&lt;h4 id=&quot;b-1&quot;&gt;b)复用技术：为什么要使用复用技术？能解决什么问题？（时分复用、码分复用、频分复用）&lt;/h4&gt;

&lt;h4 id=&quot;c-1&quot;&gt;c)信令：为什么有信令？没有信令行不行？现网中常用的信令都有哪些？&lt;/h4&gt;

&lt;h4 id=&quot;d&quot;&gt;d)网络规划：网络扩容的依据是什么？常用的网络规划技术有哪些？（通信网拓扑结构）&lt;/h4&gt;

&lt;h4 id=&quot;e&quot;&gt;e)网络中需要什么配套设备：网络中的交换机、控制中心有什么作用？没有行不行？&lt;/h4&gt;

&lt;h4 id=&quot;f&quot;&gt;f)通信网络的性能指标：怎么评价一个网络的容量？怎么评价一个次通话的通信质量？怎样评价一个网络的性能？这些指标有哪些？&lt;/h4&gt;

&lt;h4 id=&quot;g&quot;&gt;g)无线信道：使用无线信道，跟有线信道有什么区别？需要什么特别的技术吗？（这是整个无线通信的基础）&lt;/h4&gt;

&lt;p&gt;举例：这就好比，之前在一个地方，只有你和隔壁吴老二聊天，你俩都能相互听清楚对方；但是，现在这个地方里来了很多人，都想两两之间进行聊天；如果不采取一些措施，大家都说话，那就乱哄哄的，最糟糕的情况是：所有人都听不清楚对方，这个地方的聊天这个功能瘫痪掉了；这时候，管理人员就诞生了，制定一些规则，例如，大家轮流说话，这样，就能保证至少大家都能聊天（虽然有的时候，可能要等很久，才能轮到自己聊天）。 &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/frame-of-communication-knowledge/talk-with-neighbour-highest.jpg&quot; alt=&quot;talk-with-neighbour-highest&quot; /&gt; &lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;5.通信知识框架-应用&lt;/h3&gt;

&lt;p&gt;（理解了上面四个问题，再看这一个）再进一步，通信网有各种类型：公共电话交换网（传统的固定电话网）、互联网（计算机网）、移动通信网（3g网）； &lt;/p&gt;

&lt;h4 id=&quot;a-2&quot;&gt;a)这些网络各自有什么特点？&lt;/h4&gt;

&lt;h4 id=&quot;b-2&quot;&gt;b)这些网络中各自有什么独特的问题？不同网络的瓶颈不同，例如无线网络的一个瓶颈就是：自由空间的无线资源是有限的，而且无线信道中干扰很大。&lt;/h4&gt;

&lt;p&gt;上面就是对于整个通信知识的基本介绍了，建议：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最好能弄明白上面的每一个问题，不需要知道答案； &lt;/li&gt;
  &lt;li&gt;今后工作中用到这些知识了，再去深入学习； &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;几本书&lt;/h2&gt;

&lt;p&gt;最后列几本我们学过的书： &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://product.dangdang.com/product.aspx?product_id=9223550&quot;&gt;《通信原理（第6版）》&lt;/a&gt; 讲解的理论比较深，很多公式；&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://product.dangdang.com/product.aspx?product_id=20042290&quot;&gt;《数字通信原理（第2版）》&lt;/a&gt;主要解决&lt;code&gt;3.a&lt;/code&gt;、&lt;code&gt;4.b&lt;/code&gt;的问题；&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://product.dangdang.com/product.aspx?product_id=9046475&quot;&gt;《移动通信原理与系统》&lt;/a&gt;主要解决&lt;code&gt;3.b&lt;/code&gt;、&lt;code&gt;4.g&lt;/code&gt;、&lt;code&gt;5.b&lt;/code&gt;的问题；&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/4864934/&quot;&gt;《通信概论》&lt;/a&gt;我没看过这本书，在网上找了一下，感觉可能还行；&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://product.dangdang.com/product.aspx?product_id=9229349&quot;&gt;《宽带通信网原理》&lt;/a&gt;主要解决&lt;code&gt;4.d&lt;/code&gt;、&lt;code&gt;4.e&lt;/code&gt;、&lt;code&gt;4.f&lt;/code&gt;的问题；&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>模型是什么？</title>
     <link href="http://ningg.github.com/what-model-is"/>
     <updated>2012-11-13T00:00:00+08:00</updated>
     <id>http://ningg.github.com/what-model-is</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;模型是什么&lt;/h2&gt;

&lt;p&gt;模型，如果是在一年前我应该会很反感这个词汇，因为我对“模型”的最初记忆是本科一二年级的“数学建模大赛”，而当初对数学建模的第一印象是：东拼西凑、瞎胡闹，浪费时间。现在看来当初自己是错了，“模型”很重要、很关键，一定程度上“模型”体现了一个现象的本质，并可以基于“模型”来分析甚至预测事情的发展。现在各行各业很少不使用“模型”，金融决策、国家政策、工程解决方案等都要依据“模型”。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;为什么会想到要说“模型”&lt;/h2&gt;

&lt;p&gt;为什么会突然想到“模型”呢？因为读了梁斌的一篇博客&lt;a href=&quot;http://blog.sina.com.cn/s/blog_593af2a701018qc0.html&quot;&gt;《百度狼》&lt;/a&gt;，其中使用一个比喻（模型）来分析了一下百度最近的狼文化；暂且不说狼性文化好不好、是否适用baidu，只是来分析&lt;a href=&quot;http://blog.sina.com.cn/s/blog_593af2a701018qc0.html&quot;&gt;《百度狼》&lt;/a&gt;这篇文章的论述结构和手法，其开始就提出了一个众所周知的模型“西游记师徒5人”，然后以此来分析，最终得出一个结论。整个文章的分析过程，自己第一感觉，有理有据，令人信服，但转念一想：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;模型“西游记师徒5人”适用这种情况吗？&lt;/li&gt;
  &lt;li&gt;模型是由“虚幻小说”提出的，那么这个模型是合理的吗？&lt;/li&gt;
  &lt;li&gt;即使模型是真实存在的，那这个模型是能达到最高效率的模型吗？&lt;/li&gt;
  &lt;li&gt;后来这篇文章又提出军事家“曹操”的用人之道（暂不分析其是否最大效率发挥人才的作用），那么当时曹操的境遇与现在“百度”的处境是否相同呢？（模型的使用条件是否相同）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/what-model-is/xiyouji-sanzang.jpg&quot; alt=&quot;xiyouji&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;树立令自己信服的观点&lt;/h2&gt;

&lt;p&gt;到现在仍然感觉&lt;a href=&quot;http://blog.sina.com.cn/s/blog_593af2a701018qc0.html&quot;&gt;《百度狼》&lt;/a&gt;是有些参考价值的，但已然没有了第一次阅读时的“坚信不疑”了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;疑问：一个数学模型，最初是怎么提出的？其提出的依据是什么？模型的合理性怎么证明？另外，在企业管理研究领域，如何提高企业效率，如何最大程度提高员工的主观能动性，没有研究吗？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面都是比较客观地去看“模型”这个问题。
对于现实生活中的某些问题，一定程度上可以考虑使用&lt;a href=&quot;http://blog.sina.com.cn/s/blog_593af2a701018qc0.html&quot;&gt;《百度狼》&lt;/a&gt;类似的论述。（生活中的事情，是对是错，最终的评论只有后来人能说清楚）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/what-model-is/wolf.jpg&quot; alt=&quot;wolf&quot; /&gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>MOA中RandomTreeGenerator[Advanced]</title>
     <link href="http://ningg.github.com/moa-random-tree-generator-advance"/>
     <updated>2012-10-27T00:00:00+08:00</updated>
     <id>http://ningg.github.com/moa-random-tree-generator-advance</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RandomTreeGenerator&lt;/code&gt;是一个&lt;code&gt;stream&lt;/code&gt;产生器，源源不断的输出&lt;code&gt;Instance&lt;/code&gt;；这一部分，将详细探讨其实现；请先阅读”&lt;a href=&quot;/moa-random-tree-generator/&quot;&gt;MOA中RandomTreeGenerator-Basic&lt;/a&gt;“。查看源码的工具是Eclipse，关于Eclipse下查看源代码的快捷键，可参考”&lt;a href=&quot;/moa-sourcecode-with-eclipse/&quot;&gt;Eclipse下查看MOA源代码&lt;/a&gt;“。&lt;/p&gt;

&lt;p&gt;具体将分为2个方面来讨论&lt;code&gt;RandomTreeGenerator&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对外继承关系；&lt;/li&gt;
  &lt;li&gt;内部成员；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些分析是准备解决问题的，不能解决问题的分析，就是徒劳；在本篇文章的后半部分，将基于上述讨论，来分析：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如何使用RandomTreeGenerator？&lt;/li&gt;
  &lt;li&gt;怎样定义一个stream的Generator？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果只是讨论上面的这些东西，那么相当于一台没有主角的戏，枯燥浅显；因为处理对象是&lt;code&gt;data stream&lt;/code&gt;，如果在程序中无法存储&lt;code&gt;data stream&lt;/code&gt;，那就好比没有大米，却要去煮大米粥；最后一部分，重点讨论&lt;code&gt;MOA&lt;/code&gt;中数据存储相关知识：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;data stream的数学表示是什么？程序中存储在什么地方？&lt;/li&gt;
  &lt;li&gt;Attribute、Instance、Instances、InstancesHeader之间有什么联系？&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;对外继承关系&lt;/h2&gt;

&lt;p&gt;几个基本的快捷键：
&amp;lt;table style=&quot;width: 100%;&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&amp;gt;&lt;/p&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;strong&gt;操作&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + 鼠标左击&lt;/td&gt;
&lt;td&gt;查看class、method、attribute的源代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt &amp;nbsp;+&amp;nbsp;←&lt;/td&gt;
&lt;td&gt;返回上一次鼠标位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt &amp;nbsp;+&amp;nbsp;→&lt;/td&gt;
&lt;td&gt;与“Alt + &lt;span style=&quot;white-space: normal;&quot;&gt;←&lt;/span&gt;”相反&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F4&lt;/td&gt;
&lt;td&gt;查看Class的继承关系&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;p&gt;&amp;lt;/table&amp;gt;&lt;/p&gt;

</content>
   </entry>
   
 
</feed>
