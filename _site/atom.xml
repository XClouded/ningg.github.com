<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>NingG.github.com</title>
   <link href="http://ningg.github.com/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://ningg.github.com" rel="alternate" type="text/html" />
   <updated>2014-05-08T19:17:19+08:00</updated>
   <id>http://ningg.github.com</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>正则表达式（字符串匹配模式）</title>
     <link href="http://ningg.github.com/regular-expression"/>
     <updated>2014-05-04T00:00:00+08:00</updated>
     <id>http://ningg.github.com/regular-expression</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近师兄安排我用Pig解析一下日志文件，在数据装载过程中，需要抽取特定位置的字符串&lt;em&gt;（即使是数字、符号，在程序看来也是字符）。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;回想起之前的团队中，CZW对正则表达式进行过技术分享，深入浅出，反正当时我是听懂了，应该也达到了能用的水平，无奈10月左右的时间，只剩下点滴印象了，&lt;em&gt;（唉，时光已去，曾经掌握的东西，当要用时，又需要重新去学，这正是自己写技术博客的原因之一）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;不多说了，接下来，将整体上对正则表达式来一个梳理。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正则表达式，是什么？&lt;/h2&gt;

&lt;p&gt;正则表达式，英文原名: &lt;code&gt;Regular Expression&lt;/code&gt;（简称：&lt;code&gt;regex&lt;/code&gt;或&lt;code&gt;regexp&lt;/code&gt;），直接翻译：&lt;code&gt;有规律的式子&lt;/code&gt;，或者，可以翻译为&lt;code&gt;描述规律的式子&lt;/code&gt;。&lt;em&gt;(他奶奶的，不知道谁第一个翻译的，取名&lt;code&gt;正则表达式&lt;/code&gt;？忒高大上了，听上去完全不知到干什么的，还是&lt;code&gt;描述规律的式子&lt;/code&gt;容易理解)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/regular-expression/regular-expressions-comics.png&quot; alt=&quot;comics&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决什么问题？&lt;/h3&gt;

&lt;p&gt;通俗的说：查找满足一定规则的字符串。&lt;/p&gt;

&lt;p&gt;可用于文本的查找、替换。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;应用场景举例&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;场景1：仅查找出文本中单词&lt;code&gt;car&lt;/code&gt;，不想找出其他单词&lt;code&gt;scar&lt;/code&gt;、&lt;code&gt;carry&lt;/code&gt;等。&lt;/li&gt;
  &lt;li&gt;场景2：用户在注册页面填写Email时，检查Email地址格式是否正确。&lt;/li&gt;
  &lt;li&gt;场景3：查找指定目录下，文件名中包含&lt;code&gt;application&lt;/code&gt;字样的文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;正式定义&lt;/h3&gt;

&lt;p&gt;正则表达式，给个正式定义：按一定规则查找字符串，并可以进行替换操作。&lt;/p&gt;

&lt;p&gt;正则表达式，几点要注意的内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;有自己的语法规则，即，正则表达式语言；&lt;/li&gt;
  &lt;li&gt;不是正规的（完备的）程序设计语言，没有专门针对正则表达式的软件，来安装和运行；&lt;/li&gt;
  &lt;li&gt;常内置于其他软件/语言中；（即，其他语言实现了正则表达式规则的解析器）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当前，java/Python/PHP/JavaScript等，都支持正则表达式。&lt;/p&gt;

&lt;p&gt;支持正则表达式的语言\工具：&lt;a href=&quot;http://www.regular-expressions.info/tools.html&quot;&gt;Applications and Languages Related with RegEx&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;产生的启发点&lt;/h3&gt;

&lt;p&gt;1950年左右时，数学领域的一些研究工作&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://cns-classes.bu.edu/cn550/Readings/mcculloch-pitts-43.pdf&quot;&gt;A logical calculus of the ideas immanent in nervous activity&lt;/a&gt;, 1943;
Author: McCulloch, Warren S., and Walter Pitts;
简述：神经系统中神经元看作小巧而简单的自动控制单元。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.dlsi.ua.es/~mlf/nnafmc/papers/kleene56representation.pdf&quot;&gt;Representation of Events in Nerve Nets and Finite Automata&lt;/a&gt;, 1956;
Author: Kleene, Stephen C;
简述：“正则集合”的数学符号来描述此模型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;几年后，计算机领域借助上述研究成果，实现perl、grep等工具/语言，正则表达式进入实用阶段。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/regular-expression/regular-expression-introduction.png&quot; alt=&quot;illustration&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;怎么用？&lt;/h2&gt;

&lt;p&gt;正则表达式，俗称&lt;code&gt;描述规律的式子&lt;/code&gt;，用来查找字符串，基本逻辑是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如何匹配出1个字符；&lt;/li&gt;
  &lt;li&gt;如何匹配出n个字符；&lt;/li&gt;
  &lt;li&gt;如何匹配出特定位置的字符；（特定位置：字符串的开头、结尾）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-7&quot;&gt;匹配1个字符&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;a&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;一个字符&lt;code&gt;a&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[abc]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[..]表示集合内的任意一个字符，在此例中，[abc]表示a、b、c字符中的任意一个&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[^abc]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;除去a、b、c之外的任意一个字符，注意，&lt;code&gt;^&lt;/code&gt;只限于在&lt;code&gt;[^&lt;/code&gt;位置，才表示此含义&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[0123456789]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任意一个数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[a-z]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任意一个消息字母（在[]内&lt;code&gt;-&lt;/code&gt;为特殊字符，代表区间）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[0-9]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任意一个数字，等同于[0123456789]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;.&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任意一个字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\f&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;换页符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\t&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;制表键，tab&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\r&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;回车符，return&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\n&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;换行符，nextLine&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\v&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;垂直制表符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\w&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等价于[a-zA-Z0-9]，任何一个字母（区分大小写）、数字、下划线&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\W&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等价于[^a-zA-Z0-9]，任何一个非字母（区分大小写）、数字、下划线&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\d&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任何一个数字字符,等价于[0-9]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\D&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等价于[^0-9]，任何一个非数字字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\s&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等价于[ \f\n\r\t\v]，任何一个空白字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\S&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等价于[^ \f\n\r\t\v]，任何一个非空白字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\x0A&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;（16进制）对应ASCII字符10，即\n&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\011&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;（8进制）对应ASCII字符9，即\t&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;校正&lt;/strong&gt;：关于&lt;code&gt;\s&lt;/code&gt;,《&lt;a href=&quot;http://book.douban.com/subject/2269648/&quot; title=&quot;《正则表达式必知必会》2007年12月，第1版&quot;&gt;正则表达式必知必会&lt;/a&gt;》 版本信息（2007年12月，第1版），在Page 31中，&lt;code&gt;\s&lt;/code&gt;表示任何一个空白字符，应该包含空格&lt;code&gt; &lt;/code&gt;在内（具体参考：&lt;a href=&quot;http://www.regular-expressions.info/shorthand.html&quot;&gt;Shorthand Character Classes Of Regex&lt;/a&gt;）&lt;/p&gt;

&lt;h3 id=&quot;n&quot;&gt;匹配n个字符&lt;/h3&gt;

&lt;p&gt;匹配&lt;code&gt;n&lt;/code&gt;个字符，就是“匹配一个字符”重复&lt;code&gt;n&lt;/code&gt;次，嗯，很简单，则有：&lt;code&gt;aa&lt;/code&gt;，表示匹配连续两个字符&lt;code&gt;a&lt;/code&gt;；&lt;code&gt;\d\d&lt;/code&gt;,表示匹配2个数字；&lt;code&gt;\n\n\n&lt;/code&gt;,表示匹配3个换行符。&lt;em&gt;(很简单有木有)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;问题来了，假设有如下文本：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I $am$ the $god$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;目标：查找出&lt;code&gt;$..$&lt;/code&gt;间的内容，正则表达式怎么写？(&lt;code&gt;$..$&lt;/code&gt;间字符的个数，不能确定，只知道1个以上)&lt;/p&gt;

&lt;p&gt;我x，不是说要“匹配一个字符”重复&lt;code&gt;n&lt;/code&gt;次就可以么？关键现在&lt;code&gt;n&lt;/code&gt;是几啊？这怎么还是一个范围（&lt;code&gt;n&amp;gt;=1&lt;/code&gt;）？这如何是好？&lt;/p&gt;

&lt;p&gt;莫急莫急，请往下看。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;?&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0次或1次&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;+&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1次以上（a+：表示一个或多个a的连续出现；[0-9]+：表示一个或多个连续出现的数字）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;*&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0次及0次以上&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{3}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3次&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{ ,3}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0次–3次（包含0次和3次）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{1, }&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1次以上&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{1,3}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1次–3次（包含1次和3次）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;到这儿，就可以看出，使用 &lt;code&gt;$.+$&lt;/code&gt;就能匹配上面的内容了。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;匹配特定位置字符&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;在字符串开头&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;$&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;在字符串结尾&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\b&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;单词的边界&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\B&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;非单词的边界&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;匹配出如下文本中的cat单词：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;cat catt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;\bcat\b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;匹配如下文本中的&lt;code&gt;-&lt;/code&gt;，要求：只找出两个字母之间的&lt;code&gt;-&lt;/code&gt;，文本内容：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A-b - ss s- f-  - a-&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;\B-\B&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;过度匹配（贪婪）&lt;/h3&gt;

&lt;p&gt;要匹配文本&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ben@cib.com.cn&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;\w+@\w[\w\.]+\.\w+&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;理论上，可以匹配出：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;ben@baidu.com&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ben@baidu.com.cn&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是，上述匹配结果是2，即&lt;code&gt;ben@cib.com.cn&lt;/code&gt;。原因：&lt;code&gt;+&lt;/code&gt;、&lt;code&gt;*&lt;/code&gt;默认都是贪婪匹配，即找出最长的匹配模式；如果希望匹配出结果1，即&lt;code&gt;ben@cib.com&lt;/code&gt;，惰性匹配，找出最短的匹配模式，需要修改正则表达式：&lt;code&gt;\w+?@\w[\w\.]+?\.\w+?&lt;/code&gt;，即&lt;code&gt;+&lt;/code&gt;替换为&lt;code&gt;+?&lt;/code&gt;，&lt;code&gt;*&lt;/code&gt;替换为&lt;code&gt;*?&lt;/code&gt;。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;贪婪匹配&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;懒惰字符&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;*&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;*?&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;+&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;+?&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{n, }&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{n, }?&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-10&quot;&gt;补充说明&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;转义字符，例如，&lt;code&gt;\.&lt;/code&gt; 表示&lt;code&gt;.&lt;/code&gt;字符本身，单独&lt;code&gt;.&lt;/code&gt;表示匹配任意一个字符；&lt;code&gt;\?&lt;/code&gt;表示&lt;code&gt;?&lt;/code&gt;字符自身&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;表示其前后两种模式的任意一个，例如&lt;code&gt;(19|20)\d{2}&lt;/code&gt;，匹配19xx和20xx，xx表示任意两位数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;子表达式，整体上看作一个独立元素&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;假设有一个文本&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hello, my name is Ben&lt;code&gt;&amp;amp;nbsp;&lt;/code&gt; … Node.js, Linux&lt;code&gt;&amp;amp;nbsp;&amp;amp;nbsp;&lt;/code&gt;, and other tech.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在要匹配出连续的两个&lt;code&gt;&amp;amp;nbsp;&lt;/code&gt;，可以使用&lt;code&gt;&amp;amp;nbsp;&amp;amp;nbsp;&lt;/code&gt;，也可以使用&lt;code&gt;(&amp;amp;nbsp;){2}&lt;/code&gt;，而不能使用&lt;code&gt;&amp;amp;nbsp;{2}&lt;/code&gt;，因为&lt;code&gt;{2}&lt;/code&gt;，表示匹配其前面字符，实际&lt;code&gt;&amp;amp;nbsp;{2}&lt;/code&gt;等价与&lt;code&gt;&amp;amp;nbsp;;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;匹配IP：10.108.210.111&lt;/p&gt;

&lt;p&gt;正则表达式：&lt;code&gt;\d{1,3}\. \d{1,3}\. \d{1,3}\. \d{1,3}\ &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以替换为： &lt;code&gt;(\d{1,3}\.){3}\d{1,3}\ &lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;高级用法&lt;/h2&gt;

&lt;h3 id=&quot;section-12&quot;&gt;子表达式&lt;/h3&gt;

&lt;p&gt;前文提到过，在这儿单独拿出来说，是因为下文要用到。&lt;em&gt;（尼玛，下文难道不会用到前文其他内容么？凭什么单说&lt;code&gt;子表达式&lt;/code&gt;啊；因为，实在是怕你忘了，其他内容你即使忘了，也容易自己查找）&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;引用回溯&lt;/h3&gt;

&lt;p&gt;本质：前后匹配一致；&lt;/p&gt;

&lt;p&gt;技术上实质：后半部分引用前半部分匹配到的子表达式。&lt;/p&gt;

&lt;p&gt;举例：&lt;/p&gt;

&lt;p&gt;匹配如下文档中重复输入的单次：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This is a block of of text, several words here are are repeated, and and they should not be.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;[ ]+(\w+)[ ]+\1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\1&lt;/code&gt;表示&lt;code&gt;(\w+)&lt;/code&gt;中匹配到的内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：回溯引用中&lt;code&gt;\1&lt;/code&gt;,&lt;code&gt;\2&lt;/code&gt;只能一用子表达式（即用&lt;code&gt;()&lt;/code&gt;括起来的部分），&lt;code&gt;\0&lt;/code&gt;代表整个正则表达式匹配的结果。&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;前后查找&lt;/h3&gt;

&lt;p&gt;本质：匹配全部，返回局部；&lt;/p&gt;

&lt;p&gt;技术上实质：将子表达式向前（后）匹配到字符串返回。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;向前查找： 正 向前查找&lt;code&gt;exp2(?=exp1)&lt;/code&gt;， 负 向前查找&lt;code&gt;(exp2(?!exp1))&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;向后查找： 正 向后查找&lt;code&gt;(?&amp;lt;=exp1)exp2&lt;/code&gt;， 负 向后查找&lt;code&gt;(?&amp;lt;!exp1)exp2&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注：上式都是匹配&lt;code&gt;exp1&lt;/code&gt;，返回&lt;code&gt;exp2&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;举例1：&lt;/p&gt;

&lt;p&gt;匹配如下文本中的传输协议&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://www.baidu.com&lt;/p&gt;

  &lt;p&gt;ftp://ftp.baidu.com&lt;/p&gt;

  &lt;p&gt;https://mails.baidu.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;.+(?=:)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;举例2：&lt;/p&gt;

&lt;p&gt;匹配如下文本中的金额&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;abc: $23.01&lt;/p&gt;

  &lt;p&gt;hdc: $899.00&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;(?&amp;lt;=\$)\d[\d.]*\d&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;嵌入条件&lt;/h3&gt;

&lt;p&gt;可以添加逻辑条件，类似if。&lt;/p&gt;

&lt;p&gt;说几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;功能很强大；&lt;/li&gt;
  &lt;li&gt;使用的不是很多；&lt;/li&gt;
  &lt;li&gt;真要了解一下，参考《&lt;a href=&quot;http://book.douban.com/subject/2269648/&quot; title=&quot;《正则表达式必知必会》2007年12月，第1版&quot;&gt;正则表达式必知必会&lt;/a&gt;》&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-16&quot;&gt;元字符？&lt;/h3&gt;

&lt;p&gt;啥？元字符？什么东东？小伙儿，不要激动。正则表达式为了描述匹配哪些位置的字符串，使用了&lt;code&gt;.&lt;/code&gt;,&lt;code&gt;\d&lt;/code&gt;,&lt;code&gt;\s&lt;/code&gt;,&lt;code&gt;\w&lt;/code&gt;,&lt;code&gt;\W&lt;/code&gt;,&lt;code&gt;^&lt;/code&gt;,&lt;code&gt;[]&lt;/code&gt;,&lt;code&gt;()&lt;/code&gt;,&lt;code&gt;|&lt;/code&gt;,&lt;code&gt;$&lt;/code&gt;，来描述正则表达式语言的语法，即，这些字符是表述&lt;code&gt;正则表达式语言&lt;/code&gt;语法规则的字符，成为这个语言的元字符。&lt;/p&gt;

&lt;h2 id=&quot;section-17&quot;&gt;参考来源：&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/2269648/&quot; title=&quot;《正则表达式必知必会》2007年12月，第1版&quot;&gt;正则表达式必知必会&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.regular-expressions.info/tutorial.html&quot;&gt;Regex Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/regular-expression/regex-example.png&quot; alt=&quot;regex-example&quot; /&gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>GitHub上搭建个人网站</title>
     <link href="http://ningg.github.com/build-blog-with-github"/>
     <updated>2014-05-02T00:00:00+08:00</updated>
     <id>http://ningg.github.com/build-blog-with-github</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;0.背景&lt;/h2&gt;

&lt;p&gt;准备重新捡起博客，记录自己的生活，特别是技术生活&lt;em&gt;（过于私密的东西，也不敢往博客上放不是）。&lt;/em&gt;个人博客有两个途径：a.使用已有的博客网站; b.搭建自己的私人网站。调研了一下国内博客网站，（&lt;a href=&quot;http://www.csdn.net/&quot; title=&quot;CSDN&quot;&gt;CSDN&lt;/a&gt;、&lt;a href=&quot;http://www.iteye.com/&quot; title=&quot;javaEye(现在更名为ITeye)&quot;&gt;javaEye&lt;/a&gt;、&lt;a href=&quot;http://www.oschina.net/&quot; title=&quot;OSCHINA&quot;&gt;OSCHINA&lt;/a&gt;等）普遍文字格式、代码编排样式不是很喜欢&lt;em&gt;（太挑剔了？对，我就是一个挑剔的人），&lt;/em&gt;这让自己转向私人博客。可以预想到，自己搭建要稍微复杂一点，话又说回来了，作为&lt;code&gt;software engineer&lt;/code&gt;折腾网站也算看家本领了&lt;em&gt;（我会告诉你我的目标是&lt;code&gt;scientist&lt;/code&gt;么）。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;既然要搭自己的私人博客，那选定什么框架/方案呢？之前使用&lt;a href=&quot;https://wordpress.org/&quot; title=&quot;WordPress&quot;&gt;WordPress&lt;/a&gt;搭过，但需要购买域名和空间；现在流行在&lt;a href=&quot;https://github.com/about&quot; title=&quot;GitHub&quot;&gt;GitHub&lt;/a&gt;上搭，并且不需要考虑域名和空间的问题，那就他了，上&lt;a href=&quot;https://github.com/about&quot; title=&quot;GitHub&quot;&gt;GitHub&lt;/a&gt;，走起&lt;em&gt;（其实，国内也有一个类似的地方&lt;a href=&quot;https://gitcafe.com/&quot; title=&quot;GitCafe&quot;&gt;GitCafe&lt;/a&gt;，不过，出于装B需要，最终选定了&lt;a href=&quot;https://github.com/about&quot; title=&quot;GitHub&quot;&gt;GitHub&lt;/a&gt;）。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;1.做什么？&lt;/h2&gt;

&lt;p&gt;目标：私人博客、自己搭建。&lt;/p&gt;

&lt;p&gt;方式：&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;2.怎么做？&lt;/h2&gt;

&lt;p&gt;初步分析，在&lt;a href=&quot;https://github.com/about&quot; title=&quot;GitHub&quot;&gt;GitHub&lt;/a&gt;上搭建博客，实质是：将自己的博客内容上传到GitHub上&lt;em&gt;（因为GitHub提供了空间）；&lt;/em&gt;如果需要修改博客内容，则需要从GitHub上将download/pull下来；接下来就是让外面可以访问GitHub上的博客。总结一下，对应3个必要步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;GitHub上创建工程、并且能够将GitHub上的文件/代码，下载到本地；&lt;/li&gt;
  &lt;li&gt;将本地的文件/代码，上传到GitHub上；&lt;/li&gt;
  &lt;li&gt;配置GitHub，使其对外提供私人博客的访问页面；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;好了，上面是凭空想出来的&lt;em&gt;（任何地方搭建博客，都是上面的逻辑步骤，而不仅限于GitHub）；&lt;/em&gt;那实际如何操作呢？具体分为4个阶段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;熟悉&lt;a href=&quot;https://github.com/about&quot; title=&quot;GitHub&quot;&gt;GitHub&lt;/a&gt;的基本操作（创建工程、上传代码、下载代码）；&lt;/li&gt;
  &lt;li&gt;利用&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;功能，搭建简易网站；&lt;/li&gt;
  &lt;li&gt;利用&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;jekyll&lt;/a&gt;，增强网站功能（除了jekyll，还有其他的方式）；&lt;/li&gt;
  &lt;li&gt;在&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;jekyll&lt;/a&gt;框架下，依照个人偏好，进行定制；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;3.实际操作&lt;/h2&gt;

&lt;h3 id=&quot;github&quot;&gt;3.1GitHub的基本操作&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/set-up-git&quot;&gt;安装使用Git（GitHub上传、下载文件的工具）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/create-a-repo&quot;&gt;GitHub上创建项目（其中包含了，GitHub上传文件的Git命令）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/fork-a-repo&quot;&gt;GitHub上Fork项目（其中包含了，GitHub下载文件的Git命令）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;补充：&lt;a href=&quot;https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line&quot;&gt;上传文件至GitHub&lt;/a&gt;；另外，向GitHub提交代码时，按照上面的操作方式，需要每次都输入GitHub的用户名和密码，可以采用&lt;code&gt;SSH Keys&lt;/code&gt;的方式来解决此问题。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;3.2如何搭建博客？&lt;/h3&gt;

&lt;p&gt;GitHub上对于个人博客的支持，实质是利用GitHub Pages功能来实现的，具体操作：&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;,认真读一遍，5mins，一步一步操作下来，简易博客就搭建成功了（一个简单的欢迎页面&lt;code&gt;index.html&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;补充：扩展阅读&lt;a href=&quot;https://help.github.com/categories/20/articles&quot;&gt;GitHub Pages FAQ&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;jekyll&quot;&gt;3.3Jekyll增强博客网站功能&lt;/h3&gt;

&lt;p&gt;详细阅读”&lt;strong&gt;3.2如何搭建博客&lt;/strong&gt;“中提到的&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;的童鞋，在&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;页面最下端一定注意到了&lt;a href=&quot;http://jekyllrb.com/docs/quickstart/&quot;&gt;Blogging with Jekyll&lt;/a&gt;，对，就是他，读一遍，操作一下，搞定。&lt;/p&gt;

&lt;p&gt;补充：jekyll用起来倒是用起来了，怎么发表一遍博文呢？这个…额…等到学会 “&lt;strong&gt;3.4 基于jekyll框架，定制博客&lt;/strong&gt;” 再去写博客吧，现在建议把上面的操作反复看两遍，捋一捋逻辑流程。&lt;/p&gt;

&lt;h3 id=&quot;jekyll-1&quot;&gt;3.4基于jekyll框架，定制博客&lt;/h3&gt;

&lt;p&gt;先看一下两个使用jekyll框架的博客：&lt;a href=&quot;http://beiyuu.com/&quot;&gt;BeiYuu&lt;/a&gt; &amp;amp; &lt;a href=&quot;http://havee.me/&quot;&gt;Havee&lt;/a&gt;，他们对应的模版在GitHub上都可以找到：&lt;a href=&quot;https://github.com/beiyuu/beiyuu.github.com&quot;&gt;BeiYuu.com Template of GitHub&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://github.com/Ihavee/ihavee.github.io&quot;&gt;Havee.me Template of GitHub&lt;/a&gt;。 &lt;/p&gt;

&lt;p&gt;先膜拜一下上面两个博客模板，&lt;em&gt;光彩夺目，亮瞎一双狗眼，&lt;/em&gt;好了，我能不能也搭建一个类似的博客？途径有一个：深入学习一下&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll的官方文档&lt;/a&gt;，补充：&lt;a href=&quot;http://jekyllcn.com/&quot;&gt;中文版本&lt;/a&gt;。&lt;em&gt;（基于jekyll，如何定制博客，我将写一篇详细的介绍，敬请期待）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;faq&quot;&gt;4.FAQ&lt;/h2&gt;

&lt;h3 id=&quot;google-analytics&quot;&gt;4.1使用google analytics来统计网站访问情况&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;注册&lt;a href=&quot;http://www.google.com/analytics/&quot;&gt;Google Analytics&lt;/a&gt;账户；&lt;/li&gt;
  &lt;li&gt;在账户下，添加要监控的网站信息，&lt;a href=&quot;http://www.google.com/analytics/&quot;&gt;Google Analytics&lt;/a&gt;会生成跟踪信息的JS片段；&lt;/li&gt;
  &lt;li&gt;将上述JS片段插入到自己想要统计的页面上；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体设置细节：请查看&lt;a href=&quot;http://www.google.com/intl/zh-CN_ALL/analytics/learn/index.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;discus&quot;&gt;4.2如何DISCUS作为评论插件？&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;注册&lt;a href=&quot;http://disqus.com/&quot;&gt;DISQUS&lt;/a&gt;账户；&lt;/li&gt;
  &lt;li&gt;登录后，点击&lt;code&gt;Add Disqus to your site&lt;/code&gt;按钮，操作下去，最终将获得相应的JS片段；&lt;/li&gt;
  &lt;li&gt;将上述JS片段插入到自己想要包含评论的页面即可；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;latex&quot;&gt;4.3配置网站，支持LaTeX语法&lt;/h3&gt;

&lt;p&gt;配置博客，支持&lt;a href=&quot;http://www.latex-project.org/&quot;&gt;LaTeX&lt;/a&gt;公式，此次设置&lt;a href=&quot;http://kramdown.gettalong.org&quot;&gt;kramdown&lt;/a&gt;来解析&lt;a href=&quot;http://daringfireball.net/projects/markdown/syntax&quot;&gt;Markdown&lt;/a&gt;文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
If you have sufficient control over the publishing process
(e.g. you are running Jekyll yourself), an easy solution is
to switch the markdown parser to one that supports TeX.
*/

//For example, using kramdown:
gem install kramdown

//Change the markdown line in _config.yml to
markdown: kramdown

//and add something like
&amp;lt;script type=&quot;text/javascript&quot; 
src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&amp;gt;
&amp;lt;/script&amp;gt;
//to _layouts/default.html. 

//Now you can simply mark any mathematics in your posts with $$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;http://stackoverflow.com/questions/10987992/using-mathjax-with-jekyll&quot;&gt;Using MathJax with Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;4.3遇到的问题&amp;amp;解决办法？&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/dengjianqiang2011/article/details/9260435&quot;&gt;执行Git命令时，出错提示：（fatal: remote origin already exists.）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/migrating-your-pages-site-from-maruku&quot;&gt;GitHub上markdown的解析引擎不同，会造成最终页面效果的差异&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;jekyll serve启动出错提示：（Liquid Exception: invalid byte sequence in GBK）&lt;strong&gt;见下文&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;修改&lt;code&gt;\Ruby200\lib\ruby\gems\2.0.0\gems\jekyll-1.0.3\lib\jekyll&lt;/code&gt;目录下的&lt;code&gt;convertible.rb&lt;/code&gt;文件，将其中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.content = File.read(File.join(base, name))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.content = File.read(File.join(base, name),:encoding=&amp;gt;&quot;utf-8&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果上述修改之后，仍然提示出错，则：&lt;code&gt;...\lib\jekyll\tags&lt;/code&gt;目录下&lt;code&gt;include.rb&lt;/code&gt;文件，类似对于&lt;code&gt;convertible.rb&lt;/code&gt;文件的操作；&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>使用数据库查找材料</title>
     <link href="http://ningg.github.com/how-to-use-lib"/>
     <updated>2012-11-30T00:00:00+08:00</updated>
     <id>http://ningg.github.com/how-to-use-lib</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;图书馆数据库的使用&lt;/h2&gt;

&lt;p&gt;3年前在本科的时候，上过一门课“文献检索”，当时主要学了一点cnki使用的知识，没多久就忘掉了，现在想想造成这个结果有两个原因：1.当时学习就不求甚解，学习的时候，只是想到在考核上要达标，没有记录一些实用的检索手段；2.后来使用cnki的次数也少。要查找东西得时候，自己都是google，这是个好的习惯，但是，这只是初级水平；要达到中等水平，需要熟练专业数据库的检索。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/how-to-use-lib/lib-floor.jpg&quot; alt=&quot;lib-floor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在越来越发现，数据库的使用是多么的重要。特别是在资料查询上，如果使用数据库检索得心应手，就会节省很多时间，而且，能够很精确的找到自己想要的材料。&lt;/p&gt;

&lt;p&gt;本次主要介绍一些外文数据库的使用，具体包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://libra.msra.cn&quot;&gt;微软学术&lt;/a&gt;：包含范围比较广&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://scholar.google.com/&quot;&gt;google学术&lt;/a&gt;：最近几年，相比于&lt;a href=&quot;http://libra.msra.cn&quot;&gt;微软学术&lt;/a&gt;，能够实时收录最新的论文&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://acm.lib.tsinghua.edu.cn/acm/Main.nsp&quot;&gt;ACM&lt;/a&gt;：具体查找顶级会议、期刊的电子资源&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ieeexplore.ieee.org/&quot;&gt;IEEE&lt;/a&gt;：具体查找顶级会议、期刊的电子资源&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;微软学术搜索&lt;/h2&gt;

&lt;p&gt;网址：&lt;a href=&quot;http://libra.msra.cn&quot;&gt;http://libra.msra.cn&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在搜索框中，直接进行检索，例如“decision tree for mining data stream”；&lt;/li&gt;
  &lt;li&gt;（可选）添加高级搜索条件“advanced search”；&lt;/li&gt;
  &lt;li&gt;在左边栏中，选择搜索的领域，例如选择“Computer Science”；&lt;/li&gt;
  &lt;li&gt;在左边栏中，选择搜索的“Author\Conferences\Journals\Organizations”；（注意只选这几个关键字，而不要选择关键字下面具体的内容）&lt;/li&gt;
  &lt;li&gt;在打开的界面中，依次选择“related publication(s)”即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;google&quot;&gt;google学术搜索&lt;/h2&gt;

&lt;p&gt;网址：&lt;a href=&quot;http://scholar.google.com/&quot;&gt;http://scholar.google.com/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;acm&quot;&gt;ACM&lt;/h2&gt;

&lt;p&gt;网址：&lt;a href=&quot;http://acm.lib.tsinghua.edu.cn/acm/Main.nsp&quot;&gt;http://acm.lib.tsinghua.edu.cn/acm/Main.nsp&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首页可选择浏览“Special Interest Groups（SIGs）”或者“Transactions”等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ieee&quot;&gt;IEEE&lt;/h2&gt;

&lt;p&gt;网址：&lt;a href=&quot;http://ieeexplore.ieee.org/&quot;&gt;http://ieeexplore.ieee.org/&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首页选择范围“conference Publications”或者“Journal &amp;amp; Magazines”；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/how-to-use-lib/lib-book.jpg&quot; alt=&quot;lib-book&quot; /&gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>模型是什么？</title>
     <link href="http://ningg.github.com/what-model-is"/>
     <updated>2012-11-13T00:00:00+08:00</updated>
     <id>http://ningg.github.com/what-model-is</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;模型是什么&lt;/h2&gt;

&lt;p&gt;模型，如果是在一年前我应该会很反感这个词汇，因为我对“模型”的最初记忆是本科一二年级的“数学建模大赛”，而当初对数学建模的第一印象是：东拼西凑、瞎胡闹，浪费时间。现在看来当初自己是错了，“模型”很重要、很关键，一定程度上“模型”体现了一个现象的本质，并可以基于“模型”来分析甚至预测事情的发展。现在各行各业很少不使用“模型”，金融决策、国家政策、工程解决方案等都要依据“模型”。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;为什么会想到要说“模型”&lt;/h2&gt;

&lt;p&gt;为什么会突然想到“模型”呢？因为读了梁斌的一篇博客&lt;a href=&quot;http://blog.sina.com.cn/s/blog_593af2a701018qc0.html&quot;&gt;《百度狼》&lt;/a&gt;，其中使用一个比喻（模型）来分析了一下百度最近的狼文化；暂且不说狼性文化好不好、是否适用baidu，只是来分析&lt;a href=&quot;http://blog.sina.com.cn/s/blog_593af2a701018qc0.html&quot;&gt;《百度狼》&lt;/a&gt;这篇文章的论述结构和手法，其开始就提出了一个众所周知的模型“西游记师徒5人”，然后以此来分析，最终得出一个结论。整个文章的分析过程，自己第一感觉，有理有据，令人信服，但转念一想：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;模型“西游记师徒5人”适用这种情况吗？&lt;/li&gt;
  &lt;li&gt;模型是由“虚幻小说”提出的，那么这个模型是合理的吗？&lt;/li&gt;
  &lt;li&gt;即使模型是真实存在的，那这个模型是能达到最高效率的模型吗？&lt;/li&gt;
  &lt;li&gt;后来这篇文章又提出军事家“曹操”的用人之道（暂不分析其是否最大效率发挥人才的作用），那么当时曹操的境遇与现在“百度”的处境是否相同呢？（模型的使用条件是否相同）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/what-model-is/xiyouji-sanzang.jpg&quot; alt=&quot;xiyouji&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;树立令自己信服的观点&lt;/h2&gt;

&lt;p&gt;到现在仍然感觉&lt;a href=&quot;http://blog.sina.com.cn/s/blog_593af2a701018qc0.html&quot;&gt;《百度狼》&lt;/a&gt;是有些参考价值的，但已然没有了第一次阅读时的“坚信不疑”了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;疑问：一个数学模型，最初是怎么提出的？其提出的依据是什么？模型的合理性怎么证明？另外，在企业管理研究领域，如何提高企业效率，如何最大程度提高员工的主观能动性，没有研究吗？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面都是比较客观地去看“模型”这个问题。
对于现实生活中的某些问题，一定程度上可以考虑使用&lt;a href=&quot;http://blog.sina.com.cn/s/blog_593af2a701018qc0.html&quot;&gt;《百度狼》&lt;/a&gt;类似的论述。（生活中的事情，是对是错，最终的评论只有后来人能说清楚）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/what-model-is/wolf.jpg&quot; alt=&quot;wolf&quot; /&gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>MOA中RandomTreeGenerator[Advanced]</title>
     <link href="http://ningg.github.com/moa-random-tree-generator-advance"/>
     <updated>2012-10-27T00:00:00+08:00</updated>
     <id>http://ningg.github.com/moa-random-tree-generator-advance</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RandomTreeGenerator&lt;/code&gt;是一个&lt;code&gt;stream&lt;/code&gt;产生器，源源不断的输出&lt;code&gt;Instance&lt;/code&gt;；这一部分，将详细探讨其实现；请先阅读”&lt;a href=&quot;/moa-random-tree-generator/&quot;&gt;MOA中RandomTreeGenerator-Basic&lt;/a&gt;“。查看源码的工具是Eclipse，关于Eclipse下查看源代码的快捷键，可参考”&lt;a href=&quot;/moa-sourcecode-with-eclipse/&quot;&gt;Eclipse下查看MOA源代码&lt;/a&gt;“。&lt;/p&gt;

&lt;p&gt;具体将分为2个方面来讨论&lt;code&gt;RandomTreeGenerator&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对外继承关系；&lt;/li&gt;
  &lt;li&gt;内部成员；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些分析是准备解决问题的，不能解决问题的分析，就是徒劳；在本篇文章的后半部分，将基于上述讨论，来分析：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如何使用RandomTreeGenerator？&lt;/li&gt;
  &lt;li&gt;怎样定义一个stream的Generator？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果只是讨论上面的这些东西，那么相当于一台没有主角的戏，枯燥浅显；因为处理对象是&lt;code&gt;data stream&lt;/code&gt;，如果在程序中无法存储&lt;code&gt;data stream&lt;/code&gt;，那就好比没有大米，却要去煮大米粥；最后一部分，重点讨论&lt;code&gt;MOA&lt;/code&gt;中数据存储相关知识：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;data stream的数学表示是什么？程序中存储在什么地方？&lt;/li&gt;
  &lt;li&gt;Attribute、Instance、Instances、InstancesHeader之间有什么联系？&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;对外继承关系&lt;/h2&gt;

&lt;p&gt;几个基本的快捷键：
&amp;lt;table style=&quot;width: 100%;&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&amp;gt;&lt;/p&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;strong&gt;操作&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + 鼠标左击&lt;/td&gt;
&lt;td&gt;查看class、method、attribute的源代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt &amp;nbsp;+&amp;nbsp;←&lt;/td&gt;
&lt;td&gt;返回上一次鼠标位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt &amp;nbsp;+&amp;nbsp;→&lt;/td&gt;
&lt;td&gt;与“Alt + &lt;span style=&quot;white-space: normal;&quot;&gt;←&lt;/span&gt;”相反&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F4&lt;/td&gt;
&lt;td&gt;查看Class的继承关系&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;p&gt;&amp;lt;/table&amp;gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>MOA中RandomTreeGenerator[Basic]</title>
     <link href="http://ningg.github.com/moa-random-tree-generator"/>
     <updated>2012-10-26T00:00:00+08:00</updated>
     <id>http://ningg.github.com/moa-random-tree-generator</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RandomTreeGenerator&lt;/code&gt;是一个数据流（stream）产生器，它首次提出于：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.ir.iit.edu/~dagr/DataMiningCourse/Research_Papers/p71-domingos.pdf&quot;&gt;P.Domingos and G. Hulten. Mining high-speed data streams. In KDD, 2000&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;它的基本原理：基于一棵随机产生的树，来生成&lt;code&gt;Instance&lt;/code&gt;数据。关键点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;怎样产生一个随机树？&lt;/li&gt;
  &lt;li&gt;在这棵随机数上，怎样生成&lt;code&gt;Instance&lt;/code&gt;？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面我们来一一说明。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;产生随机数&lt;/h2&gt;

&lt;p&gt;随机选取属性，作为判断条件，来进行分裂；在最终的&lt;code&gt;leaf&lt;/code&gt;上，随机标记一个&lt;code&gt;Class&lt;/code&gt;；即可获得一棵随机树，因为在生成过程中，树的中间节点进行属性判断和分裂，因此准确的说，生成的是一棵决策树（&lt;code&gt;decision tree&lt;/code&gt;）。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/moa-random-tree-generator/randomTree.jpg&quot; alt=&quot;randomTree&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：上图表示一棵决策树（&lt;code&gt;decision tree&lt;/code&gt;），&lt;code&gt;Instance&lt;/code&gt;的&lt;code&gt;Class&lt;/code&gt;共计有&lt;code&gt;A&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; &lt;code&gt;C&lt;/code&gt; 3类，均已经标记在&lt;code&gt;leaf&lt;/code&gt;上。这棵树上，未标记&lt;code&gt;Class&lt;/code&gt;的节点，是中间节点，在其上进行条件判断和分裂。&lt;/p&gt;

&lt;h2 id=&quot;instance&quot;&gt;生成Instance&lt;/h2&gt;

&lt;p&gt;在讨论如何生成&lt;code&gt;Instance&lt;/code&gt;之前，先说明一下，&lt;code&gt;Instance&lt;/code&gt;的数学表示形式：&amp;lt; &lt;strong&gt;x&lt;/strong&gt;，y&amp;gt;。其中， &lt;strong&gt;x&lt;/strong&gt; 是一个属性值的向量，y是class的值。例如：Instance: &amp;lt;(1,2,3),A&amp;gt;，表示：&lt;code&gt;属性1=1&lt;/code&gt;,&lt;code&gt;属性2=2&lt;/code&gt;,&lt;code&gt;属性3=3&lt;/code&gt;,并且&lt;code&gt;Class=A&lt;/code&gt;的一个Instance。&lt;/p&gt;

&lt;p&gt;好了，有了这些说明，那如何利用 “产生随机数” 中获得的随机决策树，来生成&lt;code&gt;Instance&lt;/code&gt;呢？&lt;/p&gt;

&lt;p&gt;具体分为2步：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;随机生成一个属性值的向量 &lt;strong&gt;x&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;利用向量 &lt;strong&gt;x&lt;/strong&gt; 中的属性值，去决策树中判断对应的 y 值（class值）；
至此，获得了一个Instance &amp;lt; &lt;strong&gt;x&lt;/strong&gt; ,y&amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;补充&lt;/h2&gt;

&lt;p&gt;科学实验中，注重实验结果的__可再现__、__可重现__性；为了保证 &lt;code&gt;Instance&lt;/code&gt; 的可再现，需要保证__随机决策树__的可再现。在&lt;code&gt;MOA&lt;/code&gt;中，这些都已经实现，使用的是JAVA中&lt;code&gt;Random&lt;/code&gt;类。&lt;/p&gt;

&lt;p&gt;在实际的程序中，随机决策树的产生，可以进行设定一些参数，来进行约束：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-r	 保证 随机决策树 的再现性，只要此值相同，产生的随机树，即相同
-i	 保证 Instance 的再现性，如果 -r 值相同，并且 -i 值相同，则产生的instance相同
-c	 产生的class个数
-o	 属性中，离散型属性的个数
-u	 属性中，数值型（连续型）属性的个数
-d	 树的深度
-l	 首次存在 leaf  节点的level
-f	 每层中leaf 节点所占的比重
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;MOA:&lt;a href=&quot;http://heanet.dl.sourceforge.net/project/moa-datastream/documentation/StreamMining.pdf&quot;&gt;StreamMining.pdf&lt;/a&gt; PART: 2.5.1 Random Tree Generator&lt;/li&gt;
  &lt;li&gt;MOA:&lt;a href=&quot;http://heanet.dl.sourceforge.net/project/moa-datastream/documentation/Manual.pdf&quot;&gt;Manul.pdf&lt;/a&gt; PART: 6.2.7 generators.RandomTreeGenerator&lt;/li&gt;
&lt;/ul&gt;
</content>
   </entry>
   
   <entry>
     <title>lixiaolai's blog</title>
     <link href="http://ningg.github.com/lixiaolai-blog"/>
     <updated>2012-10-25T00:00:00+08:00</updated>
     <id>http://ningg.github.com/lixiaolai-blog</id>
     <content type="html">&lt;h2 id=&quot;lixiaolai&quot;&gt;[推荐]lixiaolai的博客&lt;/h2&gt;

&lt;p&gt;发个文，标记一下lixiaolai的一篇博客：&lt;a href=&quot;http://wordpress.lixiaolai.com/archives/12427.html&quot;&gt;《学习学习在学习》&lt;/a&gt;，也算为自己今后提个醒。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/lixiaolai-blog/google.jpg&quot; alt=&quot;google&quot; /&gt;&lt;/p&gt;

&lt;p&gt;只喜欢技术的哥们儿，&lt;a href=&quot;http://wordpress.lixiaolai.com/archives/12427.html&quot;&gt;《学习学习在学习》&lt;/a&gt;里面也介绍了一部分google搜索的应用，值得一看。我一直没有系统学过google的高级搜索，今天也算入门了。摘要几点过来：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;多使用网址：&lt;code&gt;www.google.com/ncr&lt;/code&gt;  (&lt;code&gt;No Country Redirection&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;几种符号：引号&lt;code&gt;“”&lt;/code&gt;、星号&lt;code&gt;*&lt;/code&gt;、波浪号&lt;code&gt;~&lt;/code&gt;、加号&lt;code&gt;+&lt;/code&gt;（默认的）、减号&lt;code&gt;-&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;站内搜索：例如，&lt;code&gt;“umts”+”opnet” site:ibcn.intec.ugent.be&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;定制搜索：&lt;a href=&quot;http://www.google.com/cse/&quot;&gt;Google cse（Custom Search Engine）&lt;/a&gt;，定制一个特定功能的搜索引擎；（试了一下，好使）(自己常用的人肉搜索利器之一，十分顺手~)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/images/lixiaolai-blog/learn-discuss.jpg&quot; alt=&quot;learn&quot; /&gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>Eclipse下查看MOA源代码</title>
     <link href="http://ningg.github.com/moa-sourcecode-with-eclipse"/>
     <updated>2012-10-16T00:00:00+08:00</updated>
     <id>http://ningg.github.com/moa-sourcecode-with-eclipse</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;概要&lt;/h2&gt;
&lt;p&gt;本篇短文中，此目标包含两层意思：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 使用Eclipse快速查看java代码，特别是class之间的继承(extends)、实现(implements)等关系；
2. 针对MOA源码，有没有什么特别需要注意的地方？例如，快捷方式、项目文件的组织结构等。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依照上面对于目标的定位，本篇将着重讨论如下几个要点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. java基本理论知识，针对类、继承、抽象类、接口、注解、反射的基本含义及作用进行说明；
2. Eclipse下的快捷键，特别是源代码查询，类间继承关系、接口的实现关系的快捷查看；
3. MOA基础知识：主要是MOA的目录结构、基本class、interface
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此次考虑的&lt;code&gt;class&lt;/code&gt;，主要是跟算法相分离的基本&lt;code&gt;class&lt;/code&gt;，分为以下2类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 负责数据存储功能的class，与此同时提供了对数据的基本操作方法：Instance、Stream等；
2. 规定算法实现接口的class，这些class一般是Interface或者 Abstract class。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;示例准备&lt;/h2&gt;

&lt;p&gt;此次采用的例子是&lt;a href=&quot;http://moa.cms.waikato.ac.nz/&quot; title=&quot;Massive Online Analysis&quot;&gt;MOA&lt;/a&gt;的&lt;a href=&quot;http://sourceforge.net/projects/moa-datastream/files/documentation/Tutorial2.pdf&quot; title=&quot;Introduction to the API of MOA&quot;&gt;Tutorial2&lt;/a&gt;中提供的两个示例代码：
###代码一：&lt;code&gt;ApiOfTest1.java&lt;/code&gt;
&lt;code&gt;
源代码名称: ApiOfTest1.java
文档中对应位置：Listing 1
基本功能描述：生成一个stream，并使用learner对其进行学习。
&lt;/code&gt;
&lt;strong&gt;补充说明：&lt;/strong&gt; 本次例子&lt;code&gt;ApiOfTest1.java&lt;/code&gt;中使用的&lt;code&gt;stream&lt;/code&gt;和&lt;code&gt;learner&lt;/code&gt;做出改动，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RandomTreeGenerator stream = new RandomTreeGenerator();
Classifier learner = new DecisionStumpTutorial();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;decisionstumptutorialjava&quot;&gt;代码二：&lt;code&gt;DecisionStumpTutorial.java&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
源代码名称: DecisionStumpTutorial.java
文档中对应位置：Listing 8
基本功能描述：实现了一个单层的决策树分类算法（decision stump classifier）
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;java基本知识&lt;/h2&gt;

&lt;h3 id=&quot;class&quot;&gt;类（class）&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;说明&lt;/em&gt; ：由属性（&lt;code&gt;attribute&lt;/code&gt;）和方法（&lt;code&gt;method&lt;/code&gt;）构成。&lt;/p&gt;

&lt;h3 id=&quot;extends&quot;&gt;继承（extends）&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;说明&lt;/em&gt; ：&lt;code&gt;java&lt;/code&gt;中类（&lt;code&gt;class&lt;/code&gt;）是__单继承__的，即，最多只能继承一个类。&lt;/p&gt;

&lt;h3 id=&quot;abstract-class&quot;&gt;抽象类（abstract class）&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;说明&lt;/em&gt; : 无法具体的对象被定义为抽象类（&lt;code&gt;abstract class&lt;/code&gt;）；&lt;/p&gt;

&lt;p&gt;有时候，我们可能想要构造一个很抽象的父类对象，它可能仅仅代表一种分类或抽象概念，它的实例没有任何意义，因此不希望它能被实例化。例如：有一个父类&lt;code&gt;水果（Fruit）&lt;/code&gt;，它有几个子类&lt;code&gt;苹果（Apple）&lt;/code&gt;、&lt;code&gt;橘子（Orange）&lt;/code&gt;、&lt;code&gt;香蕉（Banana）&lt;/code&gt;等。&lt;code&gt;水果&lt;/code&gt;在这里仅仅只是作为一种分类，显然&lt;code&gt;水果&lt;/code&gt;的实例没有什么意义（就好像一个人如果告诉你他买了一些&lt;code&gt;水果&lt;/code&gt;但是却不告诉你是&lt;code&gt;苹果&lt;/code&gt;还是&lt;code&gt;橘子&lt;/code&gt;，你很难想象他到底买的是什么）。而&lt;code&gt;水果类&lt;/code&gt;又要能被子类化，这就要求我们使用抽象类（&lt;code&gt;abstract class&lt;/code&gt;）来解决这个问题。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;说明&lt;/em&gt; ：抽象类，可以有抽象方法，但不能实例化。例如：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java
//定义抽象类水果（Fruit）
public abstract class Fruit {
……
}
//如果我们试图用以下语句来获得一个实例，将无法编译成功。
Fruit fruit = new Fruit();
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;说明&lt;/em&gt; ：抽象类中可以有实例属性。&lt;/p&gt;

&lt;h3 id=&quot;interface&quot;&gt;接口（interface）&lt;/h3&gt;

&lt;p&gt;接口也是抽象对象，它甚至比抽象类更抽象。&lt;strong&gt;接口中的方法都是抽象方法&lt;/strong&gt;。
一个接口可以&lt;code&gt;继承&lt;/code&gt;其他接口；一个类通过关键字implements声明要&lt;code&gt;实现&lt;/code&gt;一个接口，并具体实现接口的方法。例如：&lt;/p&gt;

&lt;p&gt;```java
//有一个接口InterfaceA，
public  interface  InterfaceA {
    void  methodA();
}&lt;/p&gt;

&lt;p&gt;//类ClassA实现接口InterfaceA。
public  class  ClassA implements InterfaceA {
    public  void  methodA() {
    System.out.println( ”methodA of ClassA implements InterfaceA” );
    }
}
```
&lt;em&gt;说明&lt;/em&gt; ：正常的&lt;code&gt;class&lt;/code&gt;实现（&lt;code&gt;implements&lt;/code&gt;）接口（&lt;code&gt;interface&lt;/code&gt;），必须实现接口定义的所有方法；但抽象类（&lt;code&gt;abstract class&lt;/code&gt;）实现接口，可以不用实现接口定义的方法。
&lt;em&gt;说明&lt;/em&gt; ：接口中不能有实例属性，如果有属性，必须为静态的常量（&lt;code&gt;static final&lt;/code&gt;）
&lt;em&gt;说明&lt;/em&gt; ：&lt;code&gt;java&lt;/code&gt;中一个类，可以同时实现（&lt;code&gt;implements&lt;/code&gt;）多个接口（&lt;code&gt;interface&lt;/code&gt;）&lt;/p&gt;

&lt;h3 id=&quot;annotation&quot;&gt;注解（annotation）&lt;/h3&gt;

&lt;p&gt;Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 &lt;code&gt;java.lang.annotation&lt;/code&gt; 包中。
&lt;em&gt;说明&lt;/em&gt; ：此次只对注解&lt;code&gt;@Override&lt;/code&gt;进行说明：
&lt;code&gt;@Override&lt;/code&gt;注解用于类方法(&lt;code&gt;Method&lt;/code&gt;)，
表示一个方法声明打算重写超类中的另一个方法声明。如果方法利用此注释类型进行注解但没有重写超类方法，则编译器会生成一条错误消息。&lt;/p&gt;

&lt;h3 id=&quot;reflection&quot;&gt;反射（Reflection）&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;说明&lt;/em&gt; ：程序运行时，通过反射获得某个类中的各种变量，函数，数组，构造函数以及类本身，并使用它们。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;其他概念：内部类&lt;/h3&gt;
&lt;p&gt;(doing…)&lt;/p&gt;

&lt;h2 id=&quot;eclipse&quot;&gt;Eclipse的快捷操作&lt;/h2&gt;

&lt;p&gt;源代码上查看方法位置、类间继承关系的快捷键（操作）。
自己用得最上手的几个快捷键（操作）列举如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码查看&lt;/strong&gt; 方面的快捷操作：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
//查找method、class出处（不如下面的方法常用）
F3 
//最直接的查找method、class出处的方法（比上面的方法更常用和有效）
Ctrl + 鼠标点击（左击）
//返回上一次鼠标位置	
Alt + ←	   
//与“Alt + ←”相反 
Alt + →	    
//根据名称匹配，查找当前工作区源代码文件
Ctrl + Shift + r/R	
//查找，哪个类继承了此类（不如下面方法常用）
选中“class”，右键“reference”—“Hierarchy”	
//查看类的继承关系（被谁继承），并且在Type Hierarch窗口中显示（比上面方法跟有效）
F4	
//显示当前类的继承关系
选中“class”， 然后 ctrl + T	
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码编辑&lt;/strong&gt; 上的操作&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
//注释本行
ctrl + /	
//注释选中的多行
ctrl + shift + /	
//取消对于多行的注释
ctrl + shift + \	
//上下行代码之间互换位置
alt + up/down	
//复制本行代码，并粘贴在上行、或者下行
ctrl + alt + up/down	
//自动添加、去除import包
ctrl + shift + O	
//自动代码提示（很方便，极其常用）
Alt + /	   
//执行当前代码（只用一个main时，自动执行；当有多个main存在时，提示选择main） 
ctrl + F11	 
//显示快捷键窗口  
ctrl + shift + L
//关闭当前源代码窗口	
ctrl + w	 
//关闭所有打开的源代码窗口   
ctrl + shift + w	
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Eclipse中几个窗口的功能：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
outline: 简要显示当前class中的attribute、method
search: 选中“class”，右键“reference”—“Hierarchy”查找，哪个类继承了此类时，结果显示在此窗口中。
console: 输出结果、出错、警告等信息
problem: 编译前，警告、出错等信息的提示
Type Hierarch: 显示当前类的继承关系（包括父类、子类）；注意此窗口中有几个按钮很重要。
packet Explorer: 查看当前源代码的组织结构
&lt;/code&gt; &lt;/p&gt;

&lt;h2 id=&quot;moa&quot;&gt;MOA基本知识&lt;/h2&gt;

&lt;p&gt;参看MOA自带文档，并且对于instanse的基本类借用于weka工程。&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>MOA的安装</title>
     <link href="http://ningg.github.com/Install-MOA"/>
     <updated>2012-10-15T00:00:00+08:00</updated>
     <id>http://ningg.github.com/Install-MOA</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;目标&lt;/h3&gt;

&lt;p&gt;同时查看MOA源代码和Weka的源代码，记录配置过程。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;具体步骤&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;搭建&lt;a href=&quot;http://www.cs.waikato.ac.nz/ml/weka/&quot; title=&quot;Waikato Environment for Knowledge Analysis&quot;&gt;weka&lt;/a&gt;环境，使其独立运行，无错误;&lt;/li&gt;
  &lt;li&gt;重新搭建&lt;a href=&quot;http://moa.cs.waikato.ac.nz&quot; title=&quot;Massive Online Analysis&quot;&gt;MOA&lt;/a&gt;环境，使其独立运行，无错误;&lt;/li&gt;
  &lt;li&gt;如何在&lt;a href=&quot;http://moa.cs.waikato.ac.nz&quot; title=&quot;Massive Online Analysis&quot;&gt;MOA&lt;/a&gt;独立环境中查看&lt;a href=&quot;http://www.cs.waikato.ac.nz/ml/weka/&quot; title=&quot;Waikato Environment for Knowledge Analysis&quot;&gt;weka&lt;/a&gt;源代码;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-3&quot;&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://moa.cs.waikato.ac.nz&quot; title=&quot;Massive Online Analysis&quot;&gt;MOA&lt;/a&gt;官网&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cs.waikato.ac.nz/ml/weka/&quot; title=&quot;Waikato Environment for Knowledge Analysis&quot;&gt;weka&lt;/a&gt;官网 &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.google.com/ncr&quot; title=&quot;google search engine&quot;&gt;google&lt;/a&gt;、&lt;a href=&quot;http://www.baidu.com&quot; title=&quot;baidu search engine&quot;&gt;baidu&lt;/a&gt;搜索&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;weka&quot;&gt;搭建Weka环境&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;主要参考来源&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cs.waikato.ac.nz/ml/weka/&quot; title=&quot;Waikato Environment for Knowledge Analysis&quot;&gt;weka&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://weka.wikispaces.com/Frequently+Asked+Questions&quot; title=&quot;weka Frequently Asked Questions&quot;&gt;weka-FAQ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;详细步骤&lt;/h3&gt;

&lt;h4 id=&quot;weka-1&quot;&gt;可执行文件方式，搭建weka环境&lt;/h4&gt;
&lt;p&gt;从&lt;a href=&quot;http://www.cs.waikato.ac.nz/ml/weka/&quot; title=&quot;Waikato Environment for Knowledge Analysis&quot;&gt;weka官网&lt;/a&gt;中下载Weka安装文件。由于目前支持&lt;code&gt;MOA&lt;/code&gt;的&lt;code&gt;Weka&lt;/code&gt;必须是&lt;code&gt;3.7.X&lt;/code&gt;以上版本，本次选择下载&lt;code&gt;weka-3.7-7&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;操作系统环境：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;win XP Professional 5.1.2600 Service Pack 3 内部版本号2600 基于X86
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可选择的Weka安装文件类型：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;weka-3-7-7.exe&lt;/code&gt;(&lt;code&gt;windows X86&lt;/code&gt;)需要安装，系统自动配置环境。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;weka-3-7-7.zip&lt;/code&gt;无需安装，手动进入目录，使用命令行启动图形界面。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本次选择&lt;code&gt;weka-3-7-7.zip&lt;/code&gt;，解压之后，运行方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java –Xmx1000M –jar weka.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了便于今后运行&lt;code&gt;weka&lt;/code&gt;方便，我写了个&lt;code&gt;weka-start.bat&lt;/code&gt;文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bat&quot;&gt;d:
cd &quot;\reference\data mining\数据挖掘\weka\weka 安装文件\weka-3-7-7&quot;
java -Xmx1000M -jar weka.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt; ：对应于上面bat文件，本地&lt;code&gt;weka-3-7-7.zip&lt;/code&gt;解压目录为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D：\reference\data mining\数据挖掘\weka\weka 安装文件\weka-3-7-7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; ：运行&lt;code&gt;weka&lt;/code&gt;之前，需要安装&lt;code&gt;JDK&lt;/code&gt;，具体版本，查看：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cs.waikato.ac.nz/ml/weka/&quot; title=&quot;Waikato Environment for Knowledge Analysis&quot;&gt;weka官网&lt;/a&gt; &lt;code&gt;Requirements&lt;/code&gt;目录&lt;/p&gt;

&lt;h4 id=&quot;weka-2&quot;&gt;源码方式，搭建weka环境&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;weka&lt;/code&gt;源码，在&lt;code&gt;eclipse&lt;/code&gt;下，搭建&lt;code&gt;weka&lt;/code&gt;工程。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;weka&lt;/code&gt;源码位置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//weka-3-7-7.exe(windows X86)
安装目录下“weka-src.jar”
//weka-3-7-7.zip
解压目录下“weka-src.jar”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者，通过&lt;code&gt;subversion&lt;/code&gt;来获得源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://weka.wikispaces.com/Subversion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解压&lt;code&gt;weka-src.jar&lt;/code&gt;得到如下文件列表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Ant build file for weka.
build.xml
//ANT file for generating JFlex/CUP parsers.
parsers.xml
/*POM是项目对象模型(Project Object Model)的简称，
 *它是Maven项目中的文件，使用XML表示，名称叫做pom.xml。
 *在Maven中，当谈到Project的时候，不仅仅是一堆包含代码的文件。
 *一个Project往往包含一个配置文件，包括了与开发者有关的，缺陷跟踪系统，
 *组织与许可，项目的URL，项目依赖，以及其他。它包含了所有与这个项目相关
 *的东西。事实上，在Maven世界中，project可以什么都没有，
 *甚至没有代码，但是必须包含pom.xml文件。
 */
pom.xml
.classpath.default
.project.default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;【说明】：更详细的内容，请自行查找&lt;code&gt;maven&lt;/code&gt;、&lt;code&gt;ant&lt;/code&gt;的知识。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在eclipse中File  –&amp;gt;  import –&amp;gt;  existing Maven Projects ，选择weka-src的解压目录。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，至此，导入源代码成功（如果没有成功，请反复再看看前面的操作细节）。&lt;/p&gt;

&lt;p&gt;从源代码运行&lt;code&gt;weka&lt;/code&gt;
找出&lt;code&gt;java&lt;/code&gt;文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/weka-dev/src/main/java/weka/gui/GUIChooser.java
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行其中的&lt;code&gt;main&lt;/code&gt;函数即可。&lt;/p&gt;

&lt;h4 id=&quot;maven&quot;&gt;附录：Maven知识&lt;/h4&gt;

&lt;p&gt;[目标]：&lt;code&gt;maven&lt;/code&gt;可以完成什么工作？怎么完成？单独写一个文档。
(doing…)&lt;/p&gt;

&lt;h2 id=&quot;moa&quot;&gt;搭建MOA环境&lt;/h2&gt;

&lt;h3 id=&quot;section-6&quot;&gt;主要参考来源&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;MOA自带文档&lt;a href=&quot;http://heanet.dl.sourceforge.net/project/moa-datastream/documentation/Manual.pdf&quot; title=&quot;MOA Manual Documentation&quot;&gt;Manual.pdf&lt;/a&gt;中&lt;code&gt;Installation&lt;/code&gt;部分。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-7&quot;&gt;详细步骤&lt;/h3&gt;

&lt;h4 id=&quot;moa-1&quot;&gt;源码方式，搭建MOA环境&lt;/h4&gt;

&lt;p&gt;下载文件：&lt;a href=&quot;http://moa.cms.waikato.ac.nz/downloads/&quot; title=&quot;MOA download site&quot;&gt;MOA download&lt;/a&gt;中下载&lt;code&gt;MOA Release 2012.08&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解压并分析文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//启动moa图形界面的文件：moa.bat、moa.sh
bin

//api文档（html版本），moa手册：Manual.pdf、StreamMining.pdf、 Tutorial1.pdf、Tutorial2.pdf
doc

//moa自带的Tutorial2.pdf中例子2的源代码。
examples
 
//moa对应生成的可执行jar包
lib
 
//开源软件声明信息
license

//源码文件
src

//编译后，可执行的moa包
moa.jar

//用于测试java对象所占内存大小，所需要的包。
sizeofag.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在eclipse下新建&lt;code&gt;java&lt;/code&gt;工程，并将&lt;code&gt;src&lt;/code&gt;文件夹下的源代码文件夹复制到工程的&lt;code&gt;src&lt;/code&gt;目录下；注意所需&lt;code&gt;jar&lt;/code&gt;包也需要添加进去。&lt;/p&gt;

&lt;p&gt;工程运行，需要&lt;code&gt;weka.jar&lt;/code&gt;包的支持，因此，下载&lt;code&gt;weka3.7.0&lt;/code&gt;以上的版本，并添加到&lt;code&gt;java project&lt;/code&gt;的路径中。&lt;/p&gt;

&lt;p&gt;仔细观察，发现上面操作之后，&lt;code&gt;java&lt;/code&gt;工程仍然提示有错，无法运行。打开出错的&lt;code&gt;java&lt;/code&gt;源文件，发现&lt;code&gt;import moa.core.Globals&lt;/code&gt;出，提示&lt;code&gt;cannot be resolved&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt; ：刚才&lt;code&gt;src&lt;/code&gt;下添加的源文件，有2个&lt;code&gt;moa&lt;/code&gt;文件夹，将占存储小的&lt;code&gt;moa&lt;/code&gt;文件夹下源文件，复制到另一个&lt;code&gt;moa&lt;/code&gt;文件夹下，保持文件夹内的相对路径不变。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; ：&lt;code&gt;moa&lt;/code&gt;的&lt;code&gt;2012.08&lt;/code&gt;版本中，使用&lt;code&gt;junit4&lt;/code&gt;进行的单元测试。原因：&lt;code&gt;test/moa/integration/SimpleClusterTest.java&lt;/code&gt; 中&lt;code&gt;import org.junit.Test;&lt;/code&gt;存在于&lt;code&gt;junit4&lt;/code&gt;中（&lt;code&gt;junit3&lt;/code&gt;中不存在此用法）。&lt;/p&gt;

&lt;p&gt;从源代码运行&lt;code&gt;weka&lt;/code&gt;
找出&lt;code&gt;java&lt;/code&gt;文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/moa/src/moa/gui/GUI.java
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行其中的&lt;code&gt;main&lt;/code&gt;函数即可。&lt;/p&gt;

&lt;h4 id=&quot;junit4&quot;&gt;附录：Junit4知识&lt;/h4&gt;

&lt;p&gt;目标：&lt;code&gt;Junit4&lt;/code&gt;的有什么用？怎么用？单独写一个文档。&lt;/p&gt;

&lt;h2 id=&quot;moaweka&quot;&gt;MOA环境下，查看weka源代码&lt;/h2&gt;

&lt;p&gt;在搭建好&lt;code&gt;MOA&lt;/code&gt;环境之后，有些程序继承自&lt;code&gt;weka&lt;/code&gt;，&lt;code&gt;Ctrl+”点击code”&lt;/code&gt;方式查看源代码时，会弹出如下界面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/install-moa/attach-sourcecode.jpg&quot; alt=&quot;attach-src&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt; ：点击上面的“Attach Source”按钮，并添加&lt;code&gt;weka-src.jar&lt;/code&gt;包即可。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

\begin{align*}
  &amp; \phi(x,y) = \phi \left(\sum_{i=1}^n x_ie_i, \sum_{j=1}^n y_je_j \right)
  = \sum_{i=1}^n \sum_{j=1}^n x_i y_j \phi(e_i, e_j) = \\
  &amp; (x_1, \ldots, x_n) \left( \begin{array}{ccc}
      \phi(e_1, e_1) &amp; \cdots &amp; \phi(e_1, e_n) \\
      \vdots &amp; \ddots &amp; \vdots \\
      \phi(e_n, e_1) &amp; \cdots &amp; \phi(e_n, e_n)
    \end{array} \right)
  \left( \begin{array}{c}
      y_1 \\
      \vdots \\
      y_n
    \end{array} \right)
\end{align*}
 %]]&gt;&lt;/script&gt;

</content>
   </entry>
   
 
</feed>
