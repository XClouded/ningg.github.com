<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>NingG.github.com</title>
   <link href="http://ningg.github.com/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://ningg.github.com" rel="alternate" type="text/html" />
   <updated>2014-09-26T00:05:33+08:00</updated>
   <id>http://ningg.github.com</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>Android入门几个基本知识</title>
     <link href="http://ningg.github.com/android-lesson-one"/>
     <updated>2014-09-23T00:00:00+08:00</updated>
     <id>http://ningg.github.com/android-lesson-one</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近参加某活动，也算掌握了点滴的内容，整理一下，算是阶段的笔记。&lt;/p&gt;

&lt;h2 id=&quot;android4&quot;&gt;Android的4个模块&lt;/h2&gt;

&lt;p&gt;Android开发中涉及4个模块/对象：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Activity；&lt;/li&gt;
  &lt;li&gt;Service；&lt;/li&gt;
  &lt;li&gt;Broadcast Receiver；&lt;/li&gt;
  &lt;li&gt;Content Provider；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;activity&quot;&gt;Activity&lt;/h3&gt;

&lt;p&gt;通常是用户界面，粒度也可能更细些，例如：菜单列表、图片、图片标题，都可能是一个单独的Activity；&lt;/p&gt;

&lt;h3 id=&quot;service&quot;&gt;Service&lt;/h3&gt;

&lt;p&gt;没有用户界面，但会一直在后台运行，例如：进行其他操作时，播放背景音乐、后台下载数据；&lt;/p&gt;

&lt;h3 id=&quot;broadcast-receiver&quot;&gt;Broadcast Receiver&lt;/h3&gt;

&lt;p&gt;应用程序利用Broadcast Receiver机制，来接收、发送广播消息，举例：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;接收/拨打电话；&lt;/li&gt;
  &lt;li&gt;接收/发送短信；&lt;/li&gt;
  &lt;li&gt;手机所处时区改变时，应用程序会接收到通知；&lt;/li&gt;
  &lt;li&gt;电池电量不足；&lt;/li&gt;
  &lt;li&gt;用户选择一张图片；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;content-provider&quot;&gt;Content Provider&lt;/h3&gt;

&lt;p&gt;应用程序利用Content Provider机制，来进行数据共享，例如：读取系统电话簿中联系人；&lt;/p&gt;

&lt;h2 id=&quot;activity-1&quot;&gt;Activity的生命周期&lt;/h2&gt;

&lt;p&gt;生命周期？对，这个术语在计算机相关的开发中，总能听到，到底什么意思？干什么的？生命周期，&lt;code&gt;lifecycle&lt;/code&gt;，其基本目标是：描述清楚一个对象从产生到消亡的过程，为开发者干预这一过程提供方法。&lt;em&gt;（用个通俗的术语来重新表述一下Object lifecycle：物体的状态变化路径）&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;back-stack&quot;&gt;返回站（Back Stack）&lt;/h3&gt;

&lt;p&gt;说Activity的生命周期之前，补充一个概念：返回栈；为了方便管理Activity，将多个相互关联的Activity合并称作一个Task，一个Task对应一个Back Stack。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-lesson-one/diagram_backstack.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于返回栈，简要说明几点（官方文档）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A &lt;code&gt;task&lt;/code&gt; is a collection of activities that users interact with when performing a certain job.&lt;/li&gt;
  &lt;li&gt;the back stack operates as a &lt;code&gt;last in, first out&lt;/code&gt; object structure.&lt;/li&gt;
  &lt;li&gt;pushed onto the stack when started by the current activity and popped off when the user leaves it using the Back button.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;activity-2&quot;&gt;Activity状态&lt;/h3&gt;

&lt;p&gt;Activity从产生到消亡，会有几个典型的状态，简要说一下（来自官方文档）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;运行状态：栈顶，显示Activity；&lt;/li&gt;
  &lt;li&gt;暂停状态：不处于栈顶，但部分可见；&lt;/li&gt;
  &lt;li&gt;停止状态：不处于栈顶，也全部不可见；&lt;/li&gt;
  &lt;li&gt;销毁状态：返回栈中，已经移除；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;acitivity-lifecycle&quot;&gt;Acitivity lifecycle&lt;/h3&gt;

&lt;p&gt;Activity生命周期如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-lesson-one/activity_lifecycle.png&quot; alt=&quot;activity_lifecycle.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;备注：可利用上面7个回调方法，来调整Activity。&lt;/p&gt;

&lt;h2 id=&quot;intent&quot;&gt;Intent简介&lt;/h2&gt;

&lt;p&gt;Intent是不同组件之间进行交互的重要方式，基本点两个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;指明当前组件要执行的动作；&lt;/li&gt;
  &lt;li&gt;不同组件之间传递的数据；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Intent能够携带数据，具体用途有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;启动Activity；&lt;/li&gt;
  &lt;li&gt;启动Service；&lt;/li&gt;
  &lt;li&gt;发送广播；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Intent分为2类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;显式Intent：举例，Intent直接指定下一步启动的Activity；&lt;/li&gt;
  &lt;li&gt;隐式Intent；举例，通过Activity的&lt;code&gt;&amp;lt;activity&amp;gt;&amp;lt;intent-filter&amp;gt;&lt;/code&gt;来隐式指定，某个Activity来捕获哪一类的Intent；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;android&quot;&gt;Android测试相关&lt;/h2&gt;

&lt;p&gt;之前，我对测试不感兴趣的，但最近感觉，开发中前期，对系统弄一个测试框架，能够提升开发、调试的效率，同时，也能在产品最终上线前进行较为全面的验证。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;测试点&lt;/h3&gt;

&lt;p&gt;测试，到底要测哪些方面？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;功能测试
    &lt;ul&gt;
      &lt;li&gt;安装/卸载&lt;/li&gt;
      &lt;li&gt;具体功能点&lt;/li&gt;
      &lt;li&gt;联网（默认的联网方式：wifi or sim卡？网络切换是否有相应提示？飞行模式）&lt;/li&gt;
      &lt;li&gt;程序进入输入功能时，是否正常弹出键盘？键盘是否遮挡应用需要输入内容的对话框？&lt;/li&gt;
      &lt;li&gt;home键与应用之间，多次切换&lt;/li&gt;
      &lt;li&gt;返回上一级操作，退出程序后的提示&lt;/li&gt;
      &lt;li&gt;当离开应用一段事件后，再次回到应用程序时，不能丢失用户数据；&lt;/li&gt;
      &lt;li&gt;横屏、竖屏切换时，不能丢失用户数据；&lt;/li&gt;
      &lt;li&gt;长按某一按钮，是否会触发其他事件；&lt;/li&gt;
      &lt;li&gt;PC端与APP端的数据同步（例如，bloger在PC端设置禁止他人评论，则，APP上也应禁止评论）&lt;/li&gt;
      &lt;li&gt;APP中内嵌的链接，程序如何处理？如果调用设备的浏览器，能否正常切回到APP？&lt;/li&gt;
      &lt;li&gt;各个页面间，多次切换&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;性能测试
    &lt;ul&gt;
      &lt;li&gt;APP的整体响应速度；&lt;/li&gt;
      &lt;li&gt;连续点击相同按钮（游戏类APP）&lt;/li&gt;
      &lt;li&gt;快速划屏（游戏类APP）&lt;/li&gt;
      &lt;li&gt;长时间使用应用&lt;/li&gt;
      &lt;li&gt;当应用不处于活动状态时，不能大量消耗系统资源&lt;/li&gt;
      &lt;li&gt;耗电情况&lt;/li&gt;
      &lt;li&gt;运行过程中，需要产看内存和CPU的使用情况：&lt;code&gt;adb shell top&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;异常测试
    &lt;ul&gt;
      &lt;li&gt;低电量情况下使用应用&lt;/li&gt;
      &lt;li&gt;（处理以下情况时，应用不能崩溃，并且返回应用后，数据不能丢失）&lt;/li&gt;
      &lt;li&gt;使用应用时，对来电的处理&lt;/li&gt;
      &lt;li&gt;使用应用时，对短信的处理&lt;/li&gt;
      &lt;li&gt;使用应用时，闹铃响起&lt;/li&gt;
      &lt;li&gt;使用应用时，锁屏、解锁&lt;/li&gt;
      &lt;li&gt;网络异常：使用应用时，断网；断网情况下，启动应用 &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;UI测试&lt;/li&gt;
  &lt;li&gt;不同系统语言的支持&lt;/li&gt;
  &lt;li&gt;适配测试
    &lt;ul&gt;
      &lt;li&gt;目标：测试不同厂家、型号的手机上，APP的运行效果；&lt;/li&gt;
      &lt;li&gt;背景：由于手机型号、总类繁多，通常只关注当前用户数较多的手机&lt;/li&gt;
      &lt;li&gt;问题1：如何找出用户较多的具体手机型号？&lt;/li&gt;
      &lt;li&gt;RE问题1：选几个纬度，屏幕尺寸、分辨率、Android系统版本，正交定位一下&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;android-testing-framework&quot;&gt;Android Testing Framework&lt;/h3&gt;

&lt;p&gt;下面会列出一张图（官网拿的），简要说几点：&lt;em&gt;（可能理解有错，会陆续更正）&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Mock Objects&lt;/code&gt;：模拟系统的一切行为；另，支持依赖注入；&lt;/li&gt;
  &lt;li&gt;JUnit：写单元测试；（白盒测试）&lt;/li&gt;
  &lt;li&gt;Instrumentation：可以模拟系统行为，捕获Activity的任何一个回调方法；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-lesson-one/test_framework.png&quot; alt=&quot;test_framework.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基于这一测试框架，能够进行如下几个测试：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单元测试；&lt;/li&gt;
  &lt;li&gt;框架测试；（什么意思？）&lt;/li&gt;
  &lt;li&gt;UI测试；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;备注：在官网文档中，&lt;code&gt;Develop&lt;/code&gt;–&lt;code&gt;Tools&lt;/code&gt;部分，针对&lt;code&gt;Tests&lt;/code&gt;有详细介绍。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;测试工具&lt;/h3&gt;

&lt;p&gt;列几个常用测试工具，以及简要的说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;monkey：产生伪随机事件流，用途：压力测试、随机点击；&lt;/li&gt;
  &lt;li&gt;monkey runner：利用python脚本，进行自动化测试，可以测试安装/卸载、截图、业务使用流程；&lt;/li&gt;
  &lt;li&gt;Hierarchy Viewer：可视化方式，显示UI树，用途：调试、优化，用户界面；另，可以放大界面；&lt;/li&gt;
  &lt;li&gt;DDMS（Dalvik Debug Monitor Service）：Eclipse下的一个视图，用途：模拟设备的地理位置变动；&lt;/li&gt;
  &lt;li&gt;traceview：跟踪程序性能，并且具体到method；&lt;em&gt;（&lt;code&gt;Debug.startMethodtrace(FILE)&lt;/code&gt;启动跟踪）&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;附录&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;几个名词&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;回归测试：修改代码之后，重新测试。&lt;/li&gt;
  &lt;li&gt;AVD：Android Virtual Devices，模拟器&lt;/li&gt;
  &lt;li&gt;SDK：Software Development Kit，软件开发平台&lt;/li&gt;
  &lt;li&gt;ADT；Android Development Tools，Eclipse下Android开发时用到的插件&lt;/li&gt;
  &lt;li&gt;ADB：Android Debug Bridge，调试桥&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;产品设计几点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;允许用户登录情况下，使用app的大部分通用功能；&lt;/li&gt;
  &lt;li&gt;当且仅当用户要使用一些核心功能时，强制用户注册、登录；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://developer.android.com/index.html&quot;&gt;Android官方开发者网站&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://developer.android.com/develop/index.html&quot;&gt;Android官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>搭建Android开发环境</title>
     <link href="http://ningg.github.com/install-android-dev-env"/>
     <updated>2014-09-22T00:00:00+08:00</updated>
     <id>http://ningg.github.com/install-android-dev-env</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;哈哈，这个背景说不说呢？说，坦坦荡荡的：想做一个对Android手机的截屏图片，直接打马赛克的小APP，当前满足这一需求的APP有不少，例如：美图秀秀等，但是不好意思，我想要一个轻量级的，而且最简单的打码操作。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;搭建开发环境&lt;/h2&gt;

&lt;p&gt;打码APP，目标确定了，就开发搞起。&lt;em&gt;（具体功能是什么？技术方案定了吗？别急，这些我现在都不会、都不确定，个人估计折腾折腾就清晰的，我对这个还是有信心的）&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;特别提醒&lt;/strong&gt;：下面是我看官网的操作记录，请那些还有丁点技术追求的coder，也去看官网，我写blog不是为了布道，而且blog的精准、严谨程度，与官网差得太远。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;下载软件&lt;/h3&gt;

&lt;p&gt;图省事，我从官网直接下载了”Eclipse ADT bundle”，详细版本信息：”adt-bundle-windows-x86_64-20140702.zip”，其下载地址如下：&lt;a href=&quot;https://dl.google.com/android/adt/adt-bundle-windows-x86_64-20140702.zip&quot;&gt;https://dl.google.com/android/adt/adt-bundle-windows-x86_64-20140702.zip&lt;/a&gt; 。由于GFW的存在，很多地方无法直接下载上面链接文件，怎么办？用迅雷，复制上面的链接，新建一个迅雷下载任务，妥了，下载完毕。&lt;/p&gt;

&lt;p&gt;Eclipse ADT Bundle包含3个部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Android SDK&lt;/li&gt;
  &lt;li&gt;Eclipse IDE&lt;/li&gt;
  &lt;li&gt;ADT(Android Developer Tools)：Eclipse下进行Android开发的插件；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;客官，留意一下：上面Eclipse ADT Bundle对应的解压包中，自带了Android开发的文档，具体路径：&lt;code&gt;%ECLIPSE_ADT_BUNDLE%/sdk/docs/&lt;/code&gt;，这个极其有用，我有问题，都会偷偷看这个。&lt;/p&gt;

&lt;h3 id=&quot;package&quot;&gt;安装package&lt;/h3&gt;

&lt;p&gt;上面Eclipse ADT Bundle对应的解压包中eclipse直接可以使用了，不过很多时候，需要安装写package，来支持Android的开发。通常，通过Android SDK Manager来安装package，截个图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/install-android-dev-env/sdk-manager.jpg&quot; alt=&quot;Android SDK Manager&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装package，本来挺简单个事，由于GFW的存在，唉，上面的package基本无法下载，或者极其慢，解决办法：修改hosts文件，在其中添加片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Google主页
203.208.46.146 www.google.com
#这行是为了方便打开Android开发官网 现在好像不VPN也可以打开
#74.125.113.121 developer.android.com
#更新的内容从以下地址下载
203.208.46.146 dl.google.com
203.208.46.146 dl-ssl.google.com
****************************************
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考来源：&lt;a href=&quot;http://www.cnblogs.com/tc310/archive/2012/12/21/2828450.html&quot;&gt;http://www.cnblogs.com/tc310/archive/2012/12/21/2828450.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;推荐书籍&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/25942191/&quot;&gt;第一行代码——Android&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;这个入门不错，对于有开发经验的人员也可以借鉴一下&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>编译flume：使用eclipse查看flume源码</title>
     <link href="http://ningg.github.com/build-flume"/>
     <updated>2014-09-19T00:00:00+08:00</updated>
     <id>http://ningg.github.com/build-flume</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近要弄日志收集系统，初始方案是将日志压缩之后，通过类似FTP方式上传，其中有一个问题：日志不能实时收集，因此，无法实时监控系统状态。Flume支持实时的日志采集，妥了，尝试用一下。&lt;/p&gt;

&lt;p&gt;说点题外话，通过类似FTP方式上传文件时，还有几个问题，自己仍在思考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;日志上传时，如何确定日志上传完成？&lt;/li&gt;
  &lt;li&gt;如果上传过程中出现意外，接收端是否会丢弃已经接收到的文件片段？&lt;/li&gt;
  &lt;li&gt;传输的文件是否压缩？&lt;/li&gt;
  &lt;li&gt;传输文件直接上传到HDFS上，还是先上传到local FS上？&lt;/li&gt;
  &lt;li&gt;日志传输到服务器上之后，如何才能立即就进行分析？&lt;/li&gt;
  &lt;li&gt;分析日志之前，怎么判断日志是否满足规范？（命名、编码等）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;编译环境&lt;/h2&gt;

&lt;p&gt;查看自己机器的环境：我用笔记本来编译的，是win 7（x64）操作系统；更详细的编译环境信息通过如下方式查看：&lt;code&gt;CMD&lt;/code&gt;–&amp;gt;&lt;code&gt;systeminfo&lt;/code&gt;，这个命令收集系统信息，需要花费40s，稍等一会儿，得到如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\Users\Administrator&amp;gt;systeminfo

OS 名称:          Microsoft Windows 7 旗舰版
OS 版本:          6.1.7601 Service Pack 1 Build 7601

系统类型:         x64-based PC
处理器:           安装了 1 个处理器。
	 [01]: Intel64 Family 6 Model 23 Stepping 6 GenuineIntel ~785 Mhz

物理内存总量:     2,968 MB
可用的物理内存:   819 MB
虚拟内存: 最大值: 5,934 MB
虚拟内存: 可用:   2,196 MB
虚拟内存: 使用中: 3,738 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;开始编译&lt;/h2&gt;

&lt;p&gt;OK，在这台Win7上，编译flume源码，走起。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;特别说明：这些内容，都是我从官网看来的，建议有点追求的coder，多看看&lt;a href=&quot;http://flume.apache.org/&quot;&gt;flume官网&lt;/a&gt;，这样才能有提高，我的博客仅仅是自己留作备份看的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;下载源码&lt;/h3&gt;

&lt;p&gt;Apache flume的下载页面：&lt;a href=&quot;http://flume.apache.org/download.html&quot;&gt;Apache Flume Download&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我下载的是当前稳定版本flume对应的源码：&lt;a href=&quot;http://www.apache.org/dyn/closer.cgi/flume/1.5.0.1/apache-flume-1.5.0.1-src.tar.gz&quot;&gt;apache-flume-1.5.0.1-src&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;开始编译&lt;/h3&gt;

&lt;p&gt;根据官方资料：&lt;a href=&quot;https://cwiki.apache.org/confluence/display/FLUME/Development+Environment&quot;&gt;flume开发&amp;amp;调试环境&lt;/a&gt;，开始编译。此次编译，我的目标很简单：在eclipse下查看flume的源代码。具体编译时，使用的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mvn install -DskipTests
mvn eclipse:eclipse -DdownloadSources
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;出现的问题&lt;/h3&gt;

&lt;p&gt;执行命令&lt;code&gt;mvn install -DskipTests&lt;/code&gt;后，程序有一段时间静止在编译flume ng core的模块上，强行终止（操作：&lt;code&gt;ctrl + c&lt;/code&gt;）后，使用  “mvn install -rf :flume-ng-core -X “ 启动debug进行问题定位找到线索:&lt;/p&gt;

&lt;p&gt;分析之后，修改flume-ng-core\scripts\目录下&lt;code&gt;saveVersion.ps1&lt;/code&gt;，将其中powershell的两个参数&lt;code&gt;args[0]&lt;/code&gt;和&lt;code&gt;args[1]&lt;/code&gt;替换为实际值即可。在此之前，需要确认windows系统已经安装了powershell，验证是否安装powershell的方法：&lt;code&gt;运行&lt;/code&gt;–&amp;gt;&lt;code&gt;powershell&lt;/code&gt;，看看是否能够进入与&lt;code&gt;cmd&lt;/code&gt;类似的命令页面（我的win7系统默认带了powershell）。
如果没有安装powershell，请参考：&lt;a href=&quot;http://support.microsoft.com/kb/968929&quot;&gt;windows管理框架&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在编译&lt;code&gt;flume-ng-morphline-solr-sink&lt;/code&gt;过程中，由于GFW等等原因，可能无法访问&lt;code&gt; repository.cloudera.com&lt;/code&gt;，导致编译失败，失败信息详情如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ERROR] Failed to execute goal on project flume-ng-morphline-solr
-sink: Could not resolve dependencies for project org.apache.flum
e.flume-ng-sinks:flume-ng-morphline-solr-sink:jar:1.5.0.1: Failed
 to collect dependencies at org.kitesdk:kite-morphlines-all:pom:0
.12.0: Failed to read artifact descriptor for org.kitesdk:kite-mo
rphlines-all:pom:0.12.0: Could not transfer artifact org.kitesdk:
kite-morphlines-all:pom:0.12.0 from/to cdh.repo (https://reposito
ry.cloudera.com/artifactory/cloudera-repos): repository.cloudera.
com: Unknown host repository.cloudera.com -&amp;gt; [Help 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览一下，失败信息的大意是：编译&lt;code&gt;flume-ng-morphline-solr-sink&lt;/code&gt;过程中，寻找依赖(dependency)失败，这是由于远端cloudera仓库对应的域名&lt;code&gt;repository.cloudera.com&lt;/code&gt;无法解析引发的。OK，既然找不到这个cloudera仓库，那直接取消对这一仓库的引用好了，具体：修改flume-ng-sinks\flume-ng-morphline-solr-sink\目录下&lt;code&gt;pom.xml&lt;/code&gt;文件，将&lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt;元素注释掉，最终效果如表：&lt;/p&gt;

&lt;repositories&gt;

	&lt;!--
	&lt;repository&gt;
	  &lt;id&gt;cdh.repo&lt;/id&gt;
	  &lt;url&gt;https://repository.cloudera.com/artifactory/cloudera-repos&lt;/url&gt;
	  &lt;name&gt;Cloudera Repositories&lt;/name&gt;
	  &lt;snapshots&gt;
		&lt;enabled&gt;false&lt;/enabled&gt;
	  &lt;/snapshots&gt;
	&lt;/repository&gt;

	&lt;repository&gt;
	  &lt;id&gt;cdh.snapshots.repo&lt;/id&gt;
	  &lt;url&gt;https://repository.cloudera.com/artifactory/libs-snapshot-local&lt;/url&gt;
	  &lt;name&gt;Cloudera Snapshots Repository&lt;/name&gt;
	  &lt;snapshots&gt;
		&lt;enabled&gt;true&lt;/enabled&gt;
	  &lt;/snapshots&gt;
	  &lt;releases&gt;
		&lt;enabled&gt;false&lt;/enabled&gt;
	  &lt;/releases&gt;
	&lt;/repository&gt;
	--&gt;

  &lt;/repositories&gt;

&lt;p&gt;ok，重新执行命令&lt;code&gt;mvn install -DskipTests&lt;/code&gt;，欧NO，又出错了，得到如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ERROR] Failed to execute goal on project flume-ng-morphline-solr
-sink: Could not resolve dependencies for project org.apache.flum
e.flume-ng-sinks:flume-ng-morphline-solr-sink:jar:1.5.0.1: The fo
-llowing artifacts could not be resolved: org.kitesdk:kite-morphli
nes-all:pom:0.12.0, org.kitesdk:kite-morphlines-solr-core:jar:tes
-ts:0.12.0: Failure to find org.kitesdk:kite-morphlines-all:pom:0.
12.0 in http://repo1.maven.org/maven2 was cached in the local repo
-sitory, resolution will not be reattempted until the update inte
rval of repo1.maven.org has elapsed or updates are forced -&amp;gt; [Help 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;平复一下心情，看看上面的提示，大意是说找不到&lt;code&gt;kite-morphlines-all&lt;/code&gt;，看来之前粗鲁的将&lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt;元素注释掉，并不能解决问题，OK，再找两个替代的repository就好了，具体再次修改flume-ng-sinks\flume-ng-morphline-solr-sink\目录下&lt;code&gt;pom.xml&lt;/code&gt;文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;repositories&amp;gt;
	&amp;lt;repository&amp;gt;
		&amp;lt;id&amp;gt;maven-restlet&amp;lt;/id&amp;gt;
		&amp;lt;name&amp;gt;Public online Restlet repository&amp;lt;/name&amp;gt;
		&amp;lt;url&amp;gt;http://maven.restlet.org&amp;lt;/url&amp;gt;
	&amp;lt;/repository&amp;gt;
  &amp;lt;/repositories&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且修改flume源代码根目录下的&lt;code&gt;pom.xml&lt;/code&gt;文件，将其中&lt;code&gt;&amp;lt;kite.version&amp;gt;0.12.0&amp;lt;/kite.version&amp;gt;&lt;/code&gt;，修改为&lt;code&gt;&amp;lt;kite.version&amp;gt;0.15.0&amp;lt;/kite.version&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;又有依赖(dependency)找不到了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ERROR] Failed to execute goal on project flume-ng-morphline-solr
-sink: Could not resolve dependencies for project org.apache.flum
e.flume-ng-sinks:flume-ng-morphline-solr-sink:jar:1.5.0.1: Failed
 to collect dependencies at org.kitesdk:kite-morphlines-all:pom:0
.12.0 -&amp;gt; org.kitesdk:kite-morphlines-useragent:jar:0.12.0 -&amp;gt; ua_p
arser:ua-parser:jar:1.3.0: Failed to read artifact descriptor for
 ua_parser:ua-parser:jar:1.3.0: Could not transfer artifact ua_pa
rser:ua-parser:pom:1.3.0 from/to maven-twttr (http://maven.twttr.
com): Connection to http://maven.twttr.com refused: Connection ti
med out: connect -&amp;gt; [Help 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次修改flume-ng-sinks\flume-ng-morphline-solr-sink\目录下&lt;code&gt;pom.xml&lt;/code&gt;文件，在&lt;code&gt;&amp;lt;repositories&amp;gt;&lt;/code&gt;下添加一个元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;repositories&amp;gt;
	
	... 
	
	&amp;lt;repository&amp;gt;
	  &amp;lt;id&amp;gt;p2.jfrog.org&amp;lt;/id&amp;gt;
	  &amp;lt;url&amp;gt;http://p2.jfrog.org/libs-releases&amp;lt;/url&amp;gt;
	&amp;lt;/repository&amp;gt;
&amp;lt;/repositories&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新编译，还不行，说是找不到&lt;code&gt;p2.jfrog.org&lt;/code&gt;，怒了，翻墙，再编译，搞定。（有的网络环境，不需要翻墙，也能编译通过）&lt;/p&gt;

&lt;h3 id=&quot;eclipse&quot;&gt;eclipse下查看源码&lt;/h3&gt;

&lt;p&gt;上面编译之后，在eclipse下，&lt;code&gt;Import&lt;/code&gt;–&amp;gt;&lt;code&gt;Existing Projects into Workspace&lt;/code&gt;，然后选择flume编译源码的路径即可，结果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/build-flume/eclipse-flume-src.jpg&quot; alt=&quot;eclipse-src&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;疑问&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用maven管理的代码，为什么不作为maven项目Import到eclipse下？而是先运行命令&lt;code&gt;mvn eclipse:eclipse&lt;/code&gt;，然后将项目作为普通的java project导入到eclipse？&lt;/li&gt;
  &lt;li&gt;使用eclipse来查看、调试flume源码，那如何对外发布源码？&lt;/li&gt;
  &lt;li&gt;总结一下，就是一个问题&lt;code&gt;mvn eclipse:eclipse&lt;/code&gt;过程中到底执行了什么？为什么要这么做？&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;后记&lt;/strong&gt;：每次编译代码，网络都让人蛋疼，GFW让人蛋疼，有一个VPN太重要了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-6&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://flume.apache.org/&quot;&gt;flume官网&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/FLUME/Development+Environment&quot;&gt;flume开发&amp;amp;调试环境&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>wordpress的开发调试环境</title>
     <link href="http://ningg.github.com/wordpress-debug-env"/>
     <updated>2014-09-05T00:00:00+08:00</updated>
     <id>http://ningg.github.com/wordpress-debug-env</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;用wordpress建站，两个功能：一个是展示团队工作，另一个是方便其他人进来讨论。&lt;/p&gt;

&lt;p&gt;初步立意：使用wordpress搭建两个网站，团队工作展示一个，讨论区一个；&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;组件与安装&lt;/h2&gt;

&lt;p&gt;环境：Win 7，已经安装了JDK 6 和 JDK 7&lt;/p&gt;

&lt;p&gt;下载软件清单如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;下载XAMPP：&lt;a href=&quot;https://www.apachefriends.org/zh_cn/index.html&quot;&gt;https://www.apachefriends.org/zh_cn/index.html&lt;/a&gt; 版本：1.8.3；对应PHP: 5.5.1&lt;/li&gt;
  &lt;li&gt;下载eclipse for php：&lt;a href=&quot;http://www.eclipse.org/downloads/&quot;&gt;http://www.eclipse.org/downloads/&lt;/a&gt;  版本：eclipse-php-luna-R-win32-x86_64&lt;/li&gt;
  &lt;li&gt;下载wordpress：&lt;a href=&quot;http://cn.wordpress.org/&quot;&gt;http://cn.wordpress.org/&lt;/a&gt; 版本：3.9&lt;/li&gt;
  &lt;li&gt;下载主题：
    &lt;ol&gt;
      &lt;li&gt;hum：&lt;a href=&quot;http://wordpress.org/extend/themes/hum/&quot;&gt;http://wordpress.org/extend/themes/hum/&lt;/a&gt; 版本：0.2.1&lt;/li&gt;
      &lt;li&gt;twenty eleven：&lt;a href=&quot;http://wordpress.org/themes/twentyeleven&quot;&gt;http://wordpress.org/themes/twentyeleven&lt;/a&gt; 版本：1.9&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;下载JDK：&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/index.html&quot;&gt;Oracle JDK(Sun)&lt;/a&gt; 版本：JDK 7u67&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;依次安装：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;XAMPP：wordpress的运行环境&lt;/li&gt;
  &lt;li&gt;wordpress，并为其配置主题：
    &lt;ul&gt;
      &lt;li&gt;twenty eleven&lt;/li&gt;
      &lt;li&gt;hum&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;eclipse：将整个wordpress文件夹，新建为PHP Project；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;配置&lt;/h2&gt;

&lt;p&gt;设计搭建其调试环境所需要的基本配置。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;基本配置&lt;/h3&gt;

&lt;p&gt;主要是Apache、MySQL、PHP相关：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设置MySQL的root密码，两种方式都可以：
    &lt;ol&gt;
      &lt;li&gt;CMD的命令行；&lt;/li&gt;
      &lt;li&gt;myphpAdmin图形界面；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;主题配置&lt;/h3&gt;

&lt;p&gt;主要是为成功安装主题，所需要进行的配置。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;wordpress
    &lt;ol&gt;
      &lt;li&gt;取消twenty eleven主题中google front（因为google被墙了）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;调试&lt;/h2&gt;

&lt;p&gt;调试是学习一个框架/语言较快的方式，这一部分将着重介绍如何进行调试。关注几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如何进行调试；&lt;/li&gt;
  &lt;li&gt;PHP web基本处理逻辑；&lt;/li&gt;
  &lt;li&gt;wordpress中使用了哪些巧妙的设计，使其流行数年；&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>PHP入门知识</title>
     <link href="http://ningg.github.com/php-intro"/>
     <updated>2014-08-31T00:00:00+08:00</updated>
     <id>http://ningg.github.com/php-intro</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近要快速搭建一个网站，用途：实现团队内容的对外展现，第一反应就是用wordpress框架实现，号称5分钟建站，够快了。问题来了：网站要实现一些特定的效果，这个就需要定制一下了，wordpress后端是PHP写的处理逻辑，OK，熟悉一下PHP。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;学习路线&lt;/h2&gt;

&lt;p&gt;自己之前接触过1个多月的PHP，当时的内容就是搭建web站点；针对一门不熟悉的语言，只需要掌握其基本知识即可开始工作，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义变量；&lt;/li&gt;
  &lt;li&gt;不同数据结构对应的变量；（链表、集合）&lt;/li&gt;
  &lt;li&gt;多个文件之间的组织结构；&lt;/li&gt;
  &lt;li&gt;调试程序；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;变量&lt;/h2&gt;

&lt;p&gt;变量，就是存储数据的容器，对变量进行操作就是处理数据；&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;定义变量&lt;/h3&gt;

&lt;p&gt;变量名，几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量名必须以&lt;code&gt;$&lt;/code&gt;开头；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;$&lt;/code&gt;之后，第一个字符必须为字母、下划线&lt;code&gt;_&lt;/code&gt;，不能为数字；&lt;/li&gt;
  &lt;li&gt;变量名剩余部分，可以包含任意字母、数字、下划线；&lt;/li&gt;
  &lt;li&gt;变量名，区分大小写；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于变量名，建议：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量名，全部小写字母；&lt;/li&gt;
  &lt;li&gt;变量名，表示其含义，举例：&lt;code&gt;$first_name&lt;/code&gt;好于&lt;code&gt;$fn&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;注释变量用途，例：$first_name = ‘Guo’; //the first name&lt;/li&gt;
  &lt;li&gt;保持一致命名模式，如果要大写，就全部大写；举例：预定义变量&lt;code&gt;$_SERVER&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;变量定义，几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PHP是脚本语言，不要求必须先定义变量或者初始化变量；但为了规范开发、减少出错，建议先定义变量后使用；&lt;/li&gt;
  &lt;li&gt;在定义时，对变量用途进行注释；&lt;/li&gt;
  &lt;li&gt;变量命名风格，有两种：驼峰式（&lt;code&gt;$FirstName&lt;/code&gt;）和下划线式（&lt;code&gt;$first_name&lt;/code&gt;），建议下划线式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;变量类型&lt;/h3&gt;

&lt;p&gt;这一部分，将介绍3种变量类型：数值型、字符串型和数组；&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数值
    &lt;ol&gt;
      &lt;li&gt;整数：1、-1；&lt;/li&gt;
      &lt;li&gt;浮点数：1.0、2.2；&lt;/li&gt;
      &lt;li&gt;注：&lt;code&gt;1/3&lt;/code&gt;包含&lt;code&gt;/&lt;/code&gt;是错误表示；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;字符串
    &lt;ol&gt;
      &lt;li&gt;单引号&lt;code&gt;&#39;&lt;/code&gt;、双引号&lt;code&gt;“&lt;/code&gt;包含起来的任意符号；&lt;/li&gt;
      &lt;li&gt;可以包含变量，例：&lt;code&gt;&#39;$field_name&#39;&lt;/code&gt;；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;数组
    &lt;ol&gt;
      &lt;li&gt;基本单元：key-value；&lt;/li&gt;
      &lt;li&gt;key不同，数组分为两类：索引数组（key为数值）、关联数组（key为字符串）；&lt;/li&gt;
      &lt;li&gt;数组的key，又称索引；&lt;/li&gt;
      &lt;li&gt;如果数组的value也是数组，则，为多维数组；&lt;/li&gt;
      &lt;li&gt;PHP中关联数组，在Perl和Ruby中称为散列；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;索引数组如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;key&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;value&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Don&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Jane&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Roger&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;关联数组如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;key&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;value&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;D&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Don&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;J&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Jane&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Roger&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-5&quot;&gt;变量赋值&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;普通变量（数值、字符串）
    &lt;ol&gt;
      &lt;li&gt;等号赋值，例： $number = 1;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;数组
    &lt;ol&gt;
      &lt;li&gt;使用array()函数，例：$list = array();&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;使用变量&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;直接输出变量
    &lt;ul&gt;
      &lt;li&gt;echo $number;&lt;/li&gt;
      &lt;li&gt;print $number;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;上下文中输出变量
    &lt;ul&gt;
      &lt;li&gt;echo “number is $number”;&lt;/li&gt;
      &lt;li&gt;注：上述不能使用单引号&lt;code&gt;‘&lt;/code&gt;，下文会提到；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数组
    &lt;ul&gt;
      &lt;li&gt;print_r “$_SERVER”;&lt;/li&gt;
      &lt;li&gt;注：print “$_SERVER”; 结果是：&lt;code&gt;Array&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;数组是非标量类型，还有其他输出方式；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;特别说明&lt;/strong&gt;：打印出变量内容，是调试脚本的重要方法。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;引号说明&lt;/h3&gt;

&lt;p&gt;这个比较重要，单拎出来说一下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;单引号&lt;code&gt;‘&lt;/code&gt;内容，原样输出；双引号&lt;code&gt;”&lt;/code&gt;内容，进行变量带入；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;针对引号，几点注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;坚持使用双引号&lt;code&gt;&quot;&lt;/code&gt;即可解决大部分问题；&lt;/li&gt;
  &lt;li&gt;当输出&lt;code&gt;\n&lt;/code&gt;、&lt;code&gt;\t&lt;/code&gt;时，需要使用双引号&lt;code&gt;&quot;&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;建议输出所有变量时，都使用双引号&lt;code&gt;&quot;&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;预定义变量&lt;/h3&gt;

&lt;p&gt;PHP中已经预先定义了一些变量，这些变量功能强大，需要熟记。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$_POST，数组，捕获POST方式表单数据；
    &lt;ol&gt;
      &lt;li&gt;使用键访问数组元素：&lt;code&gt;print $_POST[&#39;name_value&#39;]&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;严格区分大小写，并且以&lt;code&gt;$_&lt;/code&gt;开头，全部大写；&lt;/li&gt;
      &lt;li&gt;双引号内部，不能使用数组的单引号来引用key；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对上面 3. 中提到的情况，说明如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 下面输出会出错
print &quot;Thank U : $_POST[&#39;name&#39;]&quot;;

// 可选解决办法（先取出，后使用）
$input_name_value = $_POST[&#39;name&#39;];
print &quot;Thank U : $input_name_value&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;疑问：能使用双引号，即 &lt;code&gt;$_POST[&quot;name&quot;]&lt;/code&gt; 样式，来获取数组中内容吗？当然可以，单引号能做，双引号也能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$_GET，捕获GET方式表单数据，与$_POST类似；&lt;/li&gt;
  &lt;li&gt;$_REQUEST，捕获任意方式提交的数据；(不推荐)&lt;/li&gt;
  &lt;li&gt;$_COOKIE，设置和查询当前cookie中信息；&lt;/li&gt;
  &lt;li&gt;$_SERVER，服务器和执行环境信息；
    &lt;ol&gt;
      &lt;li&gt;‘PHP_SELF’：当前执行脚本的文件名，与document root有关，例如：&lt;code&gt;/test.php/foo.bar&lt;/code&gt;，具体看PHP手册；&lt;/li&gt;
      &lt;li&gt;‘REQUEST_METHOD’：访问页面的请求方法，例如：GET、POST、PUT；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-9&quot;&gt;数组&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;操作数组&lt;/strong&gt;：array()函数创建数组：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$list = array (&#39;appales&#39;, &#39;bananas&#39;, &#39;oranges&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认，数组的索引从0开始；当然有办法从1开始，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$list = array(
	1 =&amp;gt; &#39;apples&#39;,
	2 =&amp;gt; &#39;bananas&#39;,
	3 =&amp;gt; &#39;oranges&#39;
);

//key值也可以为字符串
$list = array(
	&#39;Mon&#39; =&amp;gt; &#39;apples&#39;,
	&#39;Tue&#39; =&amp;gt; &#39;bananas&#39;,
	&#39;Wed&#39; =&amp;gt; &#39;oranges&#39;
);

//range () 函数创建数组
$evens = range (0, 100, 2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于数组的常用操作，小结如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建数组
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;$list = array ()&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;evens = array ()&lt;/code&gt;;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;输出数组
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;print_r()&lt;/code&gt;函数&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;var_dump()&lt;/code&gt;函数&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;foreach()&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;引用元素
    &lt;ol&gt;
      &lt;li&gt;只能通过key的引用来获取；&lt;/li&gt;
      &lt;li&gt;key区分大小写；&lt;/li&gt;
      &lt;li&gt;key是字符串的，通过$list[1]无法访问任何元素；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;追加元素
    &lt;ol&gt;
      &lt;li&gt;数值索引时：	&lt;code&gt;$list[] = &#39;pears&#39;&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;字符串索引：必须指定key；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;修改元素
    &lt;ol&gt;
      &lt;li&gt;数值索引：&lt;code&gt;$list[2] = &#39;pears&#39;&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;字符串索引：&lt;code&gt;$list[&#39;Wed&#39;] = &#39;pears&#39;&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;字符串索引时，不能使用数值；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;元素个数
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;$how_many = count($array)&lt;/code&gt;;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;删除元素
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;unset($list[1])&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;unset($list[&#39;Wed&#39;])&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;unset($list)&lt;/code&gt;;//删除整个数组&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;$list = array()&lt;/code&gt;;//等价于删除数组&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;合并数组
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;array_merge($list1， $list2)&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;$list = $list1 + $list2&lt;/code&gt;;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;数组排序：会单独列张表
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;sort($array)&lt;/code&gt;、&lt;code&gt;rsort()&lt;/code&gt;；&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;asort()&lt;/code&gt;、&lt;code&gt;arsort()&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;ksort()&lt;/code&gt;、&lt;code&gt;krsort()&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;shuffle()&lt;/code&gt;：数组元素顺序随机重组；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;字符串与数组间相互转换
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;implode()&lt;/code&gt;：数组转换为字符串；&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;explode()&lt;/code&gt;：字符串转换为数组；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;判断是否为数组
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;is_array($array)&lt;/code&gt;;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;额外几个函数
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;array_key_exists()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;array_search()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;in_array()&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数组使用过程总结如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 $list 不存在，&lt;code&gt;$list[] = &#39;value&#39;&lt;/code&gt;，会去创建数组；&lt;/li&gt;
  &lt;li&gt;数组中使用单引号 &lt;code&gt;&#39;&lt;/code&gt; 来引用 key 和 value，也可以使用双引号&lt;code&gt;&quot;&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;sizeof()&lt;/code&gt; 函数是 &lt;code&gt;count()&lt;/code&gt; 的别名，返回数组的元素个数；&lt;/li&gt;
  &lt;li&gt;当key为数值、变量、常数时，不用引号引用，即可调用；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特别要说的是foreach遍历数组，举例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//同时，使用key 和value
foreach($array as $key =&amp;gt; $value) {
	print &quot;&amp;lt;p&amp;gt;Key is $key. Value is $value. &amp;lt;/p&amp;gt;&quot;;
}

//只使用value
foreach($array as $value){
	print &quot;&amp;lt;p&amp;gt;Value is $value.&amp;lt;/p&amp;gt;&quot;;
}

//对于数值索引数组
for($n = 0; $n &amp;lt; count($array); $n++){
	print &quot;&amp;lt;p&amp;gt;Value is $array[$n].&amp;lt;/p&amp;gt;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;备注：上述&lt;code&gt;$key =&amp;gt; $value&lt;/code&gt;，可以替换为&lt;code&gt;$k =&amp;gt; $v&lt;/code&gt;等类似形式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多维数组&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$fruits = array (
	1 =&amp;gt; &#39;apples&#39;,
	2 =&amp;gt; &#39;bananas&#39;,
	3 =&amp;gt; &#39;oranges&#39;
);

$meats =array (
	&#39;fruits&#39; =&amp;gt; $fruits,
	&#39;other&#39; =&amp;gt; &#39;peanuts&#39;,
	&#39;cash&#39; =&amp;gt; 30.00
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数组排序，常用函数如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数&lt;/th&gt;
      &lt;th&gt;排序依据&lt;/th&gt;
      &lt;th&gt;是否保持key-value对应关系&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;sort()&lt;/td&gt;
      &lt;td&gt;Values&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rsort()&lt;/td&gt;
      &lt;td&gt;Values&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;asort()&lt;/td&gt;
      &lt;td&gt;Values&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;arsort()&lt;/td&gt;
      &lt;td&gt;Values&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ksort()&lt;/td&gt;
      &lt;td&gt;Keys&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;krsort()&lt;/td&gt;
      &lt;td&gt;Keys&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;natsort()&lt;/td&gt;
      &lt;td&gt;Keys，自然顺序&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;natcasesort()&lt;/td&gt;
      &lt;td&gt;Keys&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;字符串与数组之间转换，通常如下原因：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数组-&amp;gt;字符串，为了在URL中传输数组；&lt;/li&gt;
  &lt;li&gt;数组-&amp;gt;字符串，方便将数组存储到数据库；&lt;/li&gt;
  &lt;li&gt;字符串-&amp;gt;数组，逗号分割的文本，转化为相互独立形式；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数组与字符串间转换实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 将array以&#39;,&#39;为分割，转换为字符串
$string = implode(&#39;,&#39;, $array);

//将string以&#39;,&#39;为分割，转换为数组
$array = explode(&#39;,&#39;, $string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将数组中元素分别指定给不同变量，使用 list() 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$date = array(&#39;Thursday&#39;, 23, &#39;October&#39;);
//为3个变量赋值
list($weekday, $day, $month) = $date;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实践：查看PHP手册中的几个函数，&lt;code&gt;array_key_exists()&lt;/code&gt;、&lt;code&gt;array_search()&lt;/code&gt;、&lt;code&gt;in_array()&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;常量&lt;/h2&gt;

&lt;p&gt;与变量不同，常量在脚本的执行过程中，一直保持初始值；常量一旦设定就不能更改。&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;定义常量&lt;/h3&gt;

&lt;p&gt;使用define()函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(&#39;CONSTANT_NAME&#39;, value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;常量名，以字母、下划线开头，全部大写；&lt;/li&gt;
  &lt;li&gt;常量名，不需要以&lt;code&gt;$&lt;/code&gt;开头；&lt;/li&gt;
  &lt;li&gt;定义常量，define()中常量名，使用引号；&lt;/li&gt;
  &lt;li&gt;输出常量，直接使用常量名即可；&lt;/li&gt;
  &lt;li&gt;引号内部（单引号、双引号）无法输出常量；&lt;/li&gt;
  &lt;li&gt;判断是否定义常量：&lt;code&gt;defined(&#39;CONSTANT_NAME&#39;)&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;常量是全局作用域的；&lt;/li&gt;
  &lt;li&gt;常量的值不能修改，常量本身也不能修改；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-12&quot;&gt;预定义常量&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;PHP_VERSION：正在运行的PHP版本&lt;/li&gt;
  &lt;li&gt;PHP_OS：服务器操作系统&lt;/li&gt;
  &lt;li&gt;SID：session ID&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-13&quot;&gt;运算符&lt;/h2&gt;

&lt;p&gt;PHP中运算符，参考下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;运算符&lt;/th&gt;
      &lt;th&gt;用法&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;加&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;减&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;乘&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;/&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;除&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;取模&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;++&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;自增&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;自减&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;赋值&lt;/td&gt;
      &lt;td&gt;赋值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;==&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;相等&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;不等&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;小于&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;大于&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;小于等于&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;大于等于&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;!&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;非&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;AND&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;与&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;与&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;OR&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;或&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;||&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;或&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;XOR&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;异或&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;.&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;连接&lt;/td&gt;
      &lt;td&gt;字符串&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-14&quot;&gt;函数&lt;/h2&gt;

&lt;p&gt;特别说明：PHP中函数名与&lt;code&gt;()&lt;/code&gt;之间可以有空格，即，如下两种方式都正确：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;round(100.2);
round (100.2);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-15&quot;&gt;数值格式化&lt;/h3&gt;

&lt;p&gt;round()，进行数值四舍五入，具体参阅[PHP Manual]，举例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
	round(3.4);			//3
	round(4.12, 1);		//4.1
	round(1221, -2);	//1200
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似函数还有：&lt;code&gt;number_format()&lt;/code&gt;、&lt;code&gt;printf()&lt;/code&gt;、&lt;code&gt;sprintf()&lt;/code&gt;；&lt;/p&gt;

&lt;h3 id=&quot;section-16&quot;&gt;随机数&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;rand()&lt;/code&gt;、&lt;code&gt;mt_rand()&lt;/code&gt;，具体不多说，查看操作手册即可；&lt;/p&gt;

&lt;h3 id=&quot;section-17&quot;&gt;字符串连接&lt;/h3&gt;

&lt;p&gt;字符串连接：句点&lt;code&gt;.&lt;/code&gt;，举例：&lt;code&gt;$result = $first_name . $last_name&lt;/code&gt;;&lt;/p&gt;

&lt;h3 id=&quot;html&quot;&gt;转换HTML格式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;nl2br($string);		//将$string内的\n转换为&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;htmlsprcialchars();	//将特定的HTML标签转换为实体版本&lt;/li&gt;
  &lt;li&gt;htmlentities();		//将所有的HTML标签转换为实体版本&lt;/li&gt;
  &lt;li&gt;strip_tags();		//移除所有HTML和PHP标签&lt;/li&gt;
  &lt;li&gt;html_entity_decode();	//将HTML实体转换为相应HTML代码&lt;/li&gt;
  &lt;li&gt;wordwrap();			//按照指定长度，换行处理字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几个问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTML实体是什么？例如：&lt;code&gt;&amp;lt;&lt;/code&gt; 对应HTML实体为 &lt;code&gt;&amp;amp;lt;&lt;/code&gt; ；使用HTML实体主要原因：防止输入文本中包含HTML标签，打乱整个页面的布局，更近一步，防止用户提交JS进行跨站点攻击（XSS，Cross-Site Scripting）。补充：XSS 能够做的事情：破环网站风格、功能；盗取浏览用户的session信息。&lt;/li&gt;
  &lt;li&gt;通常先移除所有HTML、PHP标签，再将&lt;code&gt;\n&lt;/code&gt;等转义符，转换为HTML换行符，即：&lt;code&gt;strip_tags()&lt;/code&gt; 之后 &lt;code&gt;nl2br()&lt;/code&gt; ;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-18&quot;&gt;字符串编/解码&lt;/h3&gt;

&lt;p&gt;背景：通过URL的query向服务器发送参数时，要求参数不能包含空格、特殊字符等；如果一定要使用URL的query向服务器传送数据，可以先对数据进行编码，即可解决此问题。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;urlencode()&lt;/code&gt;，专门解决这一问题，将字符串转换为适合最为URL的一部分来传输。几点说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;表单发送出去的数据，会自动进行URL编码，在服务器端，会自动解码，因此，本例中，只需要在页面上通过 &lt;code&gt;urlencode()&lt;/code&gt; 编码即可，服务器能够自动解码；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;urldecode()&lt;/code&gt;，能够进行解码，但不常用，因为服务器能够自动解码；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-19&quot;&gt;子字符串&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;strtok($string, $token)&lt;/code&gt;，按照$token来分割$string，并返回最新的子串；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;substring($string, 0, 10)&lt;/code&gt;，从$string中索引为0的字符开始（包含在内），累计截取10个字符；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;substring($string, -3, 3)&lt;/code&gt;，从$string中倒数第3个字符开始（包含在内），累计截取3个字符；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;strlen($string)&lt;/code&gt;，字符串中字符个数；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;str_word_count()&lt;/code&gt;，字符串中单词个数；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;str_ireplace($needle, $replacement, $haystack)&lt;/code&gt;，将$haystack中$needle替换为$replacement；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;str_replace()&lt;/code&gt;，区分大小写，其余与str_ireplace()类似；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;trim()&lt;/code&gt;，删除字符串首尾的空格、换行符、制表符；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;rtrim()&lt;/code&gt;，删除最右端的空白字符；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ltrim()&lt;/code&gt;，删除最左端的空白字符；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;strtoupper()&lt;/code&gt;，字符串转换为大写；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;strtolower()&lt;/code&gt;，字符串转换为小写；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;substr_count($string, $substr)&lt;/code&gt;，子字符串出现的次数；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PHP中所有索引的位置都是从0开始的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$evens = range (0, 100, 2); 创建等差数列；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-20&quot;&gt;日期和时间&lt;/h3&gt;

&lt;p&gt;说几个函数，有点印象就行，具体用法去查PHP手册：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;date()&lt;/code&gt; 返回某一日期格式；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;date()&lt;/code&gt; 中第二参数为时间戳（timestamp），是表示从1970年1月1日算起的秒数；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;time()&lt;/code&gt; 返回当前时间戳；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;mktime()&lt;/code&gt; 返回一个给定日期和时间对应的时间戳；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;date_default_timezone_set()&lt;/code&gt; 设置时间默认的时区；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;date_default_timezone_get()&lt;/code&gt; 获取当前时间对应的时区；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;额外说明几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PHP是服务器端的技术，函数反映的是服务器上的时间，如果要获取客户端的时间，需要使用JavaScript；&lt;/li&gt;
  &lt;li&gt;PHP 5.3中，加入一个创建、操作日期和时间的类：DateTime类；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-21&quot;&gt;创建函数&lt;/h3&gt;

&lt;p&gt;一个典型函数的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//设置参数默认值
function function_name($arg1 = &#39;world&#39;, $arg2){
	statements;
	//函数的返回值（返回多个值：数组）
	return $name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;函数名，不区分大小写；&lt;/li&gt;
  &lt;li&gt;函数function_exists(function_name)，用于判断一个函数是否存在；&lt;/li&gt;
  &lt;li&gt;PHP中不要求：函数在调用之前就定义好，但，推荐在脚本开头就定义好函数；（放在引入文件中）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-22&quot;&gt;变量作用域&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;通常，变量作用域：整个脚本的声明周期中；&lt;/li&gt;
  &lt;li&gt;函数中传参数时，传递变量值，而不传递变量本身；&lt;/li&gt;
  &lt;li&gt;函数内部定义的变量，为局部变量；&lt;/li&gt;
  &lt;li&gt;global可以将函数内局部变量设置为全局变量；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-23&quot;&gt;控制结构&lt;/h2&gt;

&lt;p&gt;几点注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;{&lt;/code&gt;、&lt;code&gt;}&lt;/code&gt;的前后，不能出现&lt;code&gt;;&lt;/code&gt;，否则报错；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几个验证函数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;empty()&lt;/code&gt;，除去变量未定义、值为0、空字符串外，返回FALSE;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;isset()&lt;/code&gt;，仅当变量未定义时，返回False；（能够接受任意个数的变量）&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;is_numeric()&lt;/code&gt;，仅当变量为数值时，返回TRUE;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;checkdate()&lt;/code&gt;，验证日期是否存在；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;is_array()&lt;/code&gt;，判断是否数组；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$var1 = 0;
$var2 = &quot;&quot;;
$var3 = &quot;HELLO!&quot;

empty($var);	//TRUE，没有定义的变量
empty($var1);	//TRUE，空值
empty($var2);	//TRUE，空值
empty($var3);	//FALSE，非空（这个是这样吗？）

isset($var);	//FALSE，变量未定义
isset($var1);	//TRUE
isset($var2);	//TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;if&quot;&gt;if条件语句&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if (condition1) {
	statement(s);
} elseif (condition2) {
	statement(s);
} else {
	statements(s);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;switch&quot;&gt;switch条件语句&lt;/h3&gt;

&lt;p&gt;switch($var)，变量$var，可以为字符串、数值，在case后的value，如果是数值，则不需要加引号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;switch ($var) {
	case value1:
		statements1;
		break;
	case value2:
		statements2;
		break;
	default:
		statements3;
		break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-24&quot;&gt;循环语句&lt;/h3&gt;

&lt;p&gt;主要是for、while，以及foreach，不多说，给个示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(condition) {
	statement(s);
}

do {
	statement(s);
} while (condition);

for (init_exp; condition ; closing_exp){
	statement(s);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-25&quot;&gt;调试程序&lt;/h2&gt;

&lt;p&gt;调试程序有2种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;输出变量和错误信息；&lt;/li&gt;
  &lt;li&gt;用IDE，打断点，debug；&lt;/li&gt;
  &lt;li&gt;查看程序运行日志，特别是出错日志；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-26&quot;&gt;输出变量&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;echo “$var”;&lt;/li&gt;
  &lt;li&gt;print “$var”;&lt;/li&gt;
  &lt;li&gt;print_r “$_SERVER”;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-27&quot;&gt;输出错误信息&lt;/h3&gt;

&lt;p&gt;安装PHP之后，默认安全配置下，是不允许向Web端输出任何出错信息的，即，&lt;code&gt;display_errors&lt;/code&gt; 出于关闭状态；为了方便调试，有两种方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开启 &lt;code&gt;display_errors&lt;/code&gt; 设置；&lt;/li&gt;
  &lt;li&gt;为某些脚本单独开启 &lt;code&gt;display_errors&lt;/code&gt; 设置；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当前首选第一个选项，但是只有root用户才有如此权限；普通用户，可以在php页面中添加代码：&lt;code&gt;ini_set(&#39;display_errors&#39;, 1);&lt;/code&gt; 实现为某些脚本开启 &lt;code&gt;display_errors&lt;/code&gt; 。说明：这种方式进行的设置，只在当前php脚本执行期间有效，脚本结束后恢复原始设置；&lt;code&gt;display_errors&lt;/code&gt; 只能控制是否向浏览器发送错误信息，而不会控制错误的发生。&lt;/p&gt;

&lt;h3 id=&quot;section-28&quot;&gt;输出错误信息级别&lt;/h3&gt;

&lt;p&gt;通过设置display_errors可以实现输出错误信息，但是要输出哪一类的错误信息呢？警告信息要不要输出？&lt;/p&gt;

&lt;p&gt;PHP中错误的类型，见下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;示例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;通知&lt;/td&gt;
      &lt;td&gt;非致命性错误，程序不一定有问题&lt;/td&gt;
      &lt;td&gt;引用一个没有值的变量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;警告&lt;/td&gt;
      &lt;td&gt;非致命错误，程序有问题&lt;/td&gt;
      &lt;td&gt;函数误用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;解析错误&lt;/td&gt;
      &lt;td&gt;致命错误，语法错误&lt;/td&gt;
      &lt;td&gt;缺少分好、引号、圆括号、花括号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;错误&lt;/td&gt;
      &lt;td&gt;致命错误，一般错误&lt;/td&gt;
      &lt;td&gt;内存分配问题&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;错误报告常量（不完整，完整版查看[PHP Manual]），见下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;E_NOTICE&lt;/td&gt;
      &lt;td&gt;通知&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E_WARRING&lt;/td&gt;
      &lt;td&gt;警告&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E_PARSE&lt;/td&gt;
      &lt;td&gt;解析错误&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E_ERROR&lt;/td&gt;
      &lt;td&gt;错误&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E_ALL&lt;/td&gt;
      &lt;td&gt;所有错误（E_STRICT除外）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E_STRICT&lt;/td&gt;
      &lt;td&gt;PHP代码修改建议&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;注：上面的常量，是二进制位掩码，可以使用按位运算符来对其进行组合，例如，php.ini中，&lt;code&gt;|&lt;/code&gt;、&lt;code&gt;~&lt;/code&gt;、&lt;code&gt;&amp;amp;&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;两种方式可以设置错误提示级别：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;全局设置：PHP配置文件php.ini中，调整error_reporting()级别；&lt;/li&gt;
  &lt;li&gt;局部设置：php脚本中，使用error_reporting()函数；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;举例说明如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//不报告任何错误
error_reporting(0);

//报告所有错误
error_reporting(E_ALL);

//报告除通知之外的所有错误
error_reporting(E_ALL &amp;amp; ~E_NOTICE);

//所有错误以及代码修改建议
error_reporting(E_ALL | E_STRICT);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;web&quot;&gt;Web开发基本过程&lt;/h2&gt;

&lt;p&gt;Web开发的基本过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建模版HTML文件；&lt;/li&gt;
  &lt;li&gt;从模版中抽取：页头文件、页脚文件；&lt;/li&gt;
  &lt;li&gt;将页头、页脚文件导入php主文件中；
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;include(&#39;file.php&#39;);&lt;/code&gt; 若include()函数失败，发出警告；&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;require(&#39;file.php&#39;);&lt;/code&gt; 若require()函数失败，终止脚本；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;通常两个php脚本来处理表单：一个显示表单，一个接收和处理表单数据；
    &lt;ol&gt;
      &lt;li&gt;让同一个脚本来完成整个流程更好；&lt;/li&gt;
      &lt;li&gt;检查变量是否设置：&lt;code&gt;isset($_POST[&#39;something&#39;])；&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;检查表单提交的方法：&lt;code&gt;$_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;POST&#39;&lt;/code&gt;;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;表单粘性：若表单提交后出错，则，重新提交表单，希望能够记录初次填写的表单数值；
    &lt;ol&gt;
      &lt;li&gt;&amp;lt;input … value=”&lt;?php print $_POST[&#39;name&#39;]; ?&gt;” /&amp;gt;&lt;/li&gt;
      &lt;li&gt;不要引用不存在的变量；在引用之前，判断是否存在isset()&lt;/li&gt;
      &lt;li&gt;用户提交的内容，直接显示在表单中有样式问题，可以使用htmlspecialchars()；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;发送Email
    &lt;ol&gt;
      &lt;li&gt;服务器上Email应用程序发送Email；&lt;/li&gt;
      &lt;li&gt;具体：调用函数&lt;code&gt;mail(to, subject, body)&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;substr_count($_POST[&#39;eamil&#39;], &#39;@&#39;) == 1&lt;/code&gt;，邮件验证；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;输出缓冲，只能在服务器发出响应之前进行调用：
    &lt;ol&gt;
      &lt;li&gt;header()：&lt;/li&gt;
      &lt;li&gt;setcookie()：&lt;/li&gt;
      &lt;li&gt;session_start()：&lt;/li&gt;
      &lt;li&gt;ob_start()；开启输出缓存，output buffering；&lt;/li&gt;
      &lt;li&gt;ob_end_flush()；输出缓冲数据；&lt;/li&gt;
      &lt;li&gt;ob_end_clean()；删除缓冲数据，不进行传输；&lt;/li&gt;
      &lt;li&gt;php.ini中可设置输出缓冲区的大写；&lt;/li&gt;
      &lt;li&gt;ob_get_length()；当前输出缓冲区的大小；&lt;/li&gt;
      &lt;li&gt;ob_get_contents()；获取缓冲区内容；&lt;/li&gt;
      &lt;li&gt;ob_flush()；输出当前缓冲区内容，以方便继续缓冲新内容；&lt;/li&gt;
      &lt;li&gt;ob_clean()；清空缓冲区内容，但后续仍会继续缓冲；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP头，header()函数
    &lt;ol&gt;
      &lt;li&gt;重定向：header(‘Location: index.php’);&lt;/li&gt;
      &lt;li&gt;重定向，接着使用函数，exit()；&lt;/li&gt;
      &lt;li&gt;开启输出缓存：ob_start()；&lt;/li&gt;
      &lt;li&gt;如果浏览器已经收到HTTP头，则headers_sent()函数返回TRUE；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cookiesession&quot;&gt;cookie和session&lt;/h3&gt;

&lt;p&gt;cookie、session的作用：跟踪用户，记录用户信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么是cookie&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;客户端保存用户信息的一种方式，服务器通过此信息识别用户身份；将从几点来介绍cookie：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;建立cookie；&lt;/li&gt;
  &lt;li&gt;从cookie中检索信息；&lt;/li&gt;
  &lt;li&gt;删除cookie；&lt;/li&gt;
  &lt;li&gt;限制cookie的可选参数；&lt;/li&gt;
  &lt;li&gt;如何调试与cookie相关的问题；&lt;/li&gt;
  &lt;li&gt;如何传输和接收cookie；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;cookie的访问时间和方式：用户输入URL后，浏览器会将cookie信息包含至HTTP请求内发送给服务器。额外几点说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务器端的PHP和浏览器端的JavaScript都能发送、读取、删除cookie，这是两种脚本重叠的功能之一；&lt;/li&gt;
  &lt;li&gt;cookie必须在服务器发送任何信息之前，从服务器发送到客户端；&lt;/li&gt;
  &lt;li&gt;setcookie(name, value)函数，向浏览器发送cookie；&lt;/li&gt;
  &lt;li&gt;发送cookie，应位于整个HTML页面标签之前（&amp;lt;!DOCTYPE html … &amp;gt;）；&lt;/li&gt;
  &lt;li&gt;若使用输出缓存机制（output buffering），则setcookie()可以位于PHP脚本中任意位置；&lt;/li&gt;
  &lt;li&gt;cookie的总数，限制在4KB；&lt;/li&gt;
  &lt;li&gt;headers_sent()函数可用与测试HTTP头部是否发送出去；&lt;/li&gt;
  &lt;li&gt;cookie的值在发送时，将自动编码，接收时会自动解码；对于PHP表单发送的值也是如此；&lt;/li&gt;
  &lt;li&gt;setcookie()函数在不同的浏览器中，有兼容性问题；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;读取cookie&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;预定义的数组$_COOKIE中存储了所有cookie数据，按照key值，从数组$_COOKIE中读取即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;向cookie中添加参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;函数setcookie()，具体用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//expiration：过期时间点，单位秒(s)；默认关闭浏览器之前有效；
//domain：设置一个子域的cookie；
//secure：为1时，表示只能通过https传送；
//httponly：设置防止JS读取cookie，但不是所有浏览器都支持；
setcookie(name, value, expiration, path, domain, secure, httponly);

setcookie(name, value, time() + 3600)；
setcookie(name, value, time() + 3600, &#39;/subfolder/&#39;);
setcookie(name, value, time() + 3600, &#39;&#39;, &#39;forum.example.com&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;几点注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cookie过期时间的选择：
    &lt;ol&gt;
      &lt;li&gt;cookie持续时间如果同用户浏览网站的时间一样长，则，不需要设置过期时间；&lt;/li&gt;
      &lt;li&gt;如果需要cookie在关闭、重启浏览器之后继续存在，可将过期时间设置为数个月；&lt;/li&gt;
      &lt;li&gt;若cookie可能引发安全隐患，则可将过期时间设置为小于1h；&lt;/li&gt;
      &lt;li&gt;出于安全考虑，可以设定cookie过期时间为5min~10min，同时，让用户每访问一个新页面时，重新发送一次cookie；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;删除cookie&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;删除cookie，本质就是设置一个空值，同时可以设置一个过去的过期时间：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//重设值，同时设置过去的过期时间
setcookie(&#39;username&#39;, FALSE, time() - 600);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特别提醒：删除cookie时，一定要使用与设置cookie一致的参数（除去值和过期时间）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setcookie(&#39;user&#39;, &#39;larry&#39;, time() + 3600, &#39;&#39;, &#39;forums.example.com&#39;);
setcookie(&#39;user&#39;, &#39;&#39;, time() - 600, &#39;&#39;, &#39;forums.example.com&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;什么是session&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;session的数据保存在服务器端，cookie数据保存在客户端；由此，session比cookie拥有更多的优势：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;session通常更安全，因为数据不会在客户端、浏览器之间重复传输；&lt;/li&gt;
  &lt;li&gt;session存储比cookie更多的信息；&lt;/li&gt;
  &lt;li&gt;session能够在禁止cookie的浏览器上，继续工作；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几点说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开启一个session时，PHP会自动创建一个随机的session ID；&lt;/li&gt;
  &lt;li&gt;每个用户都拥有一个自己的Session ID，这也是服务器上存储该用户session数据的文件名称；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;cookie相对于session的优势有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cookie相对容易创建和使用；&lt;/li&gt;
  &lt;li&gt;cookie耗费服务端的资源少；&lt;/li&gt;
  &lt;li&gt;如果希望长期保存用户身份信息，则应采用cookie；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结论：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当保存数据较少，同时安全性要求不高时，推荐首选cookie；&lt;/li&gt;
  &lt;li&gt;保存数据较多或者敏感，同时安全性要求较高时，首选session；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;创建session&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;session_start()函数用于创建一个session，并且在session首次启动时发送一个cookie，因此，必须在所有HTML响应发送回浏览器之前，创建session。
第一次开启session时，随机产生一个session ID，并向Web浏览器发送一个名为PHPSESSID（session的名称）的cookie。&lt;/p&gt;

&lt;p&gt;一旦启用session，就可以通过向数组赋值的方式来存储数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$_SESSION[&#39;first_name&#39;] = &#39;Sam&#39;;
$_SESSION[&#39;age&#39;] = 14；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每次向session中添加数据时，PHP将向服务器上一个临时文件中添加一些数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//session数据在服务器文件中的存储方式
email|s:14:&quot;me@example.com&quot;; loggedin|i:1292;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于session几点信息：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;php.ini中可以配置session信息；&lt;/li&gt;
  &lt;li&gt;ini_set()函数可以设置session信息；&lt;/li&gt;
  &lt;li&gt;session_name()函数可以修改session名称（默认名称PHPSESSID），注意：必须在调用session_start()之前使用；&lt;/li&gt;
  &lt;li&gt;session_set_cookie_params()函数，用户修改session cookie的设置（过期时间、路径、域）；&lt;/li&gt;
  &lt;li&gt;常量SID用格式name=ID的方式保存一个字符串；&lt;/li&gt;
  &lt;li&gt;session中可以保存任意类型数据，甚至对象；&lt;/li&gt;
  &lt;li&gt;在session中，数据都会以纯文本的形式保存在一个开放可读的文本文件中；永远不要将真实的敏感信息存在session中，例如信用卡数据；&lt;/li&gt;
  &lt;li&gt;为提高安全性，可以将数据加密后保存到session中，在读取session后再解密（Mcrypt库）；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;删除session&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;服务器端session中包含的数据都保存在$_SESSION数组中，可以对数组重新赋值，以达到删除session的效果，但也需要删除服务器上保存session数据的临时文件，具体操作如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//重置session
$_SESSION = array();
//删除服务器端session临时文件
session_destroy();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数unset($var)，可用于删除一个变量，也能达到删除$_SESSION的效果；同时，如果浏览器禁用cookie，则可以在URL上添加session ID作为附属参数，以继续使用session，注意：需要在php.ini中启用enable_trans_side。&lt;/p&gt;

&lt;h3 id=&quot;section-29&quot;&gt;文件和目录&lt;/h3&gt;

&lt;p&gt;Web应用程序，不可避免两个问题：数据存储、检索数据。当前数据存储的方法主要有两种：文件（和目录）、数据库。这一部分，主要介绍一下文件的写入、读取和锁定。&lt;/p&gt;

&lt;p&gt;疑问：读取、上传的文件，为什么在Web目录之外？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;file_exists(‘somefile.ext’)，判断文件是否存在；&lt;/li&gt;
  &lt;li&gt;is_readable()测试文件是否可读；&lt;/li&gt;
  &lt;li&gt;touch(‘somefile.ext’)，创建空白文件；&lt;/li&gt;
  &lt;li&gt;chgrp()、chown()、chmod()，修改文件、目录权限；&lt;/li&gt;
  &lt;li&gt;file_put_contents($file, $data)，向文件写入数据；
    &lt;ol&gt;
      &lt;li&gt;文件不存在，则，函数主动创建；&lt;/li&gt;
      &lt;li&gt;文件存在，覆盖文件内容；&lt;/li&gt;
      &lt;li&gt;file_put_contents($file, $data, FILE_APPEND)，追加；&lt;/li&gt;
      &lt;li&gt;如果需要追加的内容独占一行，则需要在内容后，添加换行符，PHP专用常量 PHP_EOL 可以解决这一问题，file_put_contents($file, $data . PHP_EOL, FILE_APPEND)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;file_put_contents($file, $data, LOCK_EX);写文件同时锁定文件；
    &lt;ol&gt;
      &lt;li&gt;若同时追加文件、锁定文件，则，&lt;code&gt;LOCK_EX | FILE_APPEND&lt;/code&gt;；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;file_get_contents($file)，一次读取文件所有内容；&lt;/li&gt;
  &lt;li&gt;file($file)，读取文件内容，并且返回一个数组，每个元素为原文件中的一行；&lt;/li&gt;
  &lt;li&gt;更多文件读取方式：fgets()、fgetcsv()；&lt;/li&gt;
  &lt;li&gt;filesize($file)，返回文件大小（单位Byte）；&lt;/li&gt;
  &lt;li&gt;filetime($file)，返回文件修改时间戳，可使用date()格式化；&lt;/li&gt;
  &lt;li&gt;is_writeable()&lt;/li&gt;
  &lt;li&gt;is_readable()&lt;/li&gt;
  &lt;li&gt;is_dir()&lt;/li&gt;
  &lt;li&gt;is_file()&lt;/li&gt;
  &lt;li&gt;glob()，搜索名字与模式匹配的文件（*.jpg）&lt;/li&gt;
  &lt;li&gt;fileperms()，文件权限；&lt;/li&gt;
  &lt;li&gt;fileatime()，文件最后访问时间；&lt;/li&gt;
  &lt;li&gt;fileowner()，拥有该文件的用户名称；&lt;/li&gt;
  &lt;li&gt;basename()、dirname()，返回文件名、路径名；&lt;/li&gt;
  &lt;li&gt;finfo_file()，文件的MIME类型；&lt;/li&gt;
  &lt;li&gt;mkdir(‘dir_name’, permissions)，创建文件；&lt;/li&gt;
  &lt;li&gt;rmdir()，删除现有目录；&lt;/li&gt;
  &lt;li&gt;fgets()，返回指定长度的字符串；&lt;/li&gt;
  &lt;li&gt;feof()，判断是否达到文件末尾；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;补充几点：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;读取文件&lt;/strong&gt;：PHP 4 以及以下版本，不能使用file_put_contents()，需要按照旧方法来写数据：打开文件、写数据、关闭文件；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//文件模式mode，查PHP手册很详细
$file_pointer = fopen($file, mode);
fwrite($file_pointer, $data . PHP_EOL);
fclose($file_pointer);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;上传文件&lt;/strong&gt;：通过表单上传，修改3处：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;form表单添加enctype，即 &amp;lt;form action=… enctype=”multipart/form-data” method=”post” &amp;gt;；必须使用POST方式；&lt;/li&gt;
  &lt;li&gt;添加银行输入框：&lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;30000&quot; /&gt;，用于建议浏览器最大能够上传的文件；&lt;/li&gt;
  &lt;li&gt;使用file元素，创建所需的表单：&lt;input type=&quot;file&quot; name=&quot;pic&quot; /&gt;，file类型允许用户上传一个文件；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PHP脚本中，使用$_FILES变量能够引用上传的文件。$_FILES数组包含5个成员：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;name，用户上传文件的原始名字；&lt;/li&gt;
  &lt;li&gt;type，文件MIME类型，例：image/jpg；&lt;/li&gt;
  &lt;li&gt;size，文件大小（单位Byte）&lt;/li&gt;
  &lt;li&gt;tmp_name，文件存放在服务器上的临时文件名称；&lt;/li&gt;
  &lt;li&gt;error，发生错误时，保存的错误代码；（查看PHP手册）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;文件上传之后，需要将临时文件移动到最终目标位置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//将临时文件移动到最终位置
move_uploaded_file($_FILES[&#39;pic&#39;][&#39;tmp_name&#39;], &#39;/path/filename&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个php脚本可以同时处理多个文件上传，只要name属性不同即可，此时只需要一个隐含输入框设定MAX_FILE_SIZE。另外，针对移动文件的函数小结：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;move_uplodaded_file()，将上传的临时文件移动到最终位置；&lt;/li&gt;
  &lt;li&gt;unlink()，删除文件，不会进行移动或者复制；&lt;/li&gt;
  &lt;li&gt;copy()，复制文件；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上传文件时，有几点注意：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;php.ini中，开启file_uploads配置；&lt;/li&gt;
  &lt;li&gt;php.ini中，设置upload_tmp_dir，如果没有设置，可能会指定一个隐含值；&lt;/li&gt;
  &lt;li&gt;php.ini中，upload_max_filesize和post_max_size用于设定PHP能够处理的文件大小；&lt;/li&gt;
  &lt;li&gt;form中隐含input元素中设定的MAX_FILE_SIZE只是在前端浏览器处，进行的约束；&lt;/li&gt;
  &lt;li&gt;当缺失要上传大文件时，除了上述相关的配置，还应设置两个参数：memory_limit、max_execution_time，来给PHP脚本足够的处理时间和空间；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;目录相关&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;浏览目录：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;scandir($dir)，返回目录下所有内容，一个数组：包含文件和子目录；&lt;/li&gt;
  &lt;li&gt;旧版本的PHP中，需要使用opendir()、readdir()、closedir()；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mysql&quot;&gt;数据库MySQL&lt;/h3&gt;

&lt;p&gt;PHP中操作MySQL数据库，基本过程，连接数据库、操作、释放连接，具体几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$dbc = mysql_connect(hostname, username, passwd)，获取数据库连接&lt;/li&gt;
  &lt;li&gt;mysql_query($query, $dbc)&lt;/li&gt;
  &lt;li&gt;mysql_query(‘create database somedb’, $dbc);&lt;/li&gt;
  &lt;li&gt;mysql_select_db(‘somedb’, $dbc);&lt;/li&gt;
  &lt;li&gt;$result = mysql_query($query, $dbc)， 执行$query&lt;/li&gt;
  &lt;li&gt;mysql_num_rows($result)，返回查询结果的个数，可用于删除、查询之前判断？&lt;/li&gt;
  &lt;li&gt;$row = mysql_fetch_array($result)，每次返回一行数据，形式：数组；&lt;/li&gt;
  &lt;li&gt;mysql_fetch_array($result, MYSQL_ASSOC or MYSQL_NUM)，关联数组、索引数组；&lt;/li&gt;
  &lt;li&gt;while( $row = mysql_fetch_array($result) ){ … }，用于遍历结果；&lt;/li&gt;
  &lt;li&gt;mysql_affected_rows()，返回INSERT、DELETE、UPDATE等影响到的行数；&lt;/li&gt;
  &lt;li&gt;msyql_close($dbc)，释放连接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;PHP中对MySQL的支持&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PHP操作MySQL，根据扩展不同，分为两类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;标准MySQL，支持所有MySQL版本，函数以 &lt;code&gt;mysql_&lt;/code&gt; 作为前缀；&lt;/li&gt;
  &lt;li&gt;扩展MySQL，MySQLi（Improved MySQL Extension），PHP5之后引入的，支持MySQL4.1以上的版本，能够利用MySQL的一些额外特性，函数以 &lt;code&gt;mysqli_&lt;/code&gt; 最为前缀；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;MySQL错误处理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;常见的错误类型有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;连接MySQL失败；&lt;/li&gt;
  &lt;li&gt;选择数据库失败；&lt;/li&gt;
  &lt;li&gt;无法运行查询；&lt;/li&gt;
  &lt;li&gt;查询没有返回结果；&lt;/li&gt;
  &lt;li&gt;数据没有插入到表中；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体说几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mysql_error()，显示发生错误的详细信息；&lt;/li&gt;
  &lt;li&gt;错误控制符&lt;code&gt;@&lt;/code&gt;，在函数名之前使用，阻止显示错误信息，但并不能阻止错误的发生，仅当希望自己处理错误时，才使用&lt;code&gt;@&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;错误控制符&lt;code&gt;@&lt;/code&gt;，可以用于阻止任何函数的错误、通知、警告，而不仅限于MySQL相关函数；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于PHP中使用MySQL，具体说几点：&lt;/p&gt;

&lt;p&gt;为避免SQL注入攻击，可随意用mysql_real_escape_string()函数，来转义危险字符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$var = mysql_real_escape_string($var, $dbc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有文件编码方式需要与HTML中指定的charset一致；&lt;/li&gt;
  &lt;li&gt;如果为UTF-8编码方式，则，必须为UTF-8 without BOM方式；&lt;/li&gt;
  &lt;li&gt;通过include(‘path/file.php’)，路径为相对与最终php脚本的位置；&lt;/li&gt;
  &lt;li&gt;include_once()、require_once()，表示同一个文件只包含一次；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;特别说明&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/download/php-intro/PHP基础教程（第4版）.pdf&quot;&gt;PHP基础教程（第4版）&lt;/a&gt;的附录部分，有很多进一步学习的建议。&lt;/p&gt;

&lt;h2 id=&quot;section-30&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/download/php-intro/PHP基础教程（第4版）.pdf&quot;&gt;PHP基础教程（第4版）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/download/php-intro/php_enhanced_zh.chm&quot;&gt;PHP Manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>Linux下su和sudo进行身份变换</title>
     <link href="http://ningg.github.com/linux-su-sudo"/>
     <updated>2014-08-16T00:00:00+08:00</updated>
     <id>http://ningg.github.com/linux-su-sudo</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近，一些普通用户要在服务器上，安装软件，不时遇到权限问题，因此，只好将root密码献了出去；太多人知道root密码是件很危险的事，特别是，有的人习惯使用root权限登录，这中情况下，很有可能误操作，删除系统文件；有没有其他办法来避免这个问题呢？&lt;/p&gt;

&lt;p&gt;说几个典型场景：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;场景A&lt;/strong&gt;：用户 &lt;code&gt;UserA&lt;/code&gt; 输入命令 &lt;code&gt;find / -name &quot;hello&quot;&lt;/code&gt;，结果提示: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find: /etc/cups/ssl: Permission denied
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;操作服务器时，不同用户之间的权限差异，概括几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;是否有权限，读（r）、写（w）、执行（x），文件 &lt;code&gt;FileA&lt;/code&gt; ；&lt;/li&gt;
  &lt;li&gt;是否有权限，执行命令&lt;code&gt;commandA&lt;/code&gt;；实质上，命令&lt;code&gt;commandA&lt;/code&gt;对应了某个可执行的文件&lt;code&gt;commandA-File&lt;/code&gt;，有权限执行命令&lt;code&gt;commandA&lt;/code&gt;等价于具有文件&lt;code&gt;commandA-File&lt;/code&gt;的执行（x）权限；&lt;/li&gt;
  &lt;li&gt;用户&lt;code&gt;UserA&lt;/code&gt;，找不到命令&lt;code&gt;commandA&lt;/code&gt;，说明，没有将命令&lt;code&gt;commandA&lt;/code&gt;添加到用户&lt;code&gt;UserA&lt;/code&gt;的环境变量&lt;code&gt;PATH&lt;/code&gt;中；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前介绍的Linux ACL（Access Control List，访问控制列表），已经实现了对文件&lt;code&gt;rwx&lt;/code&gt;权限的控制，因此，问题基本解决。&lt;/p&gt;

&lt;p&gt;Linux下，进行身份变换这一功能，有必要吗？公认的原因有几个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用一般帐号：系统日常维护的好习惯。仅当需要设定系统环境时，才变换为root身份，来进行系统管理；&lt;/li&gt;
  &lt;li&gt;使用较低权限启动系统服务。例如，额外建立一个用户起名：apache，并以此来启动apache软件，这样如果apache程序被攻破了，系统还不至于被摧毁；&lt;/li&gt;
  &lt;li&gt;软件本身的限制：有些远程连接程序（例如ssh），可设置为仅允许非root用户登录；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于上述考虑，通常使用一般帐号登录，在必要的时候，切换成root身份。问题来了：如何使一般用户转换为root用户呢？主要方式有两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;su - root&lt;/code&gt;命令，直接切换为root用户：
    &lt;ul&gt;
      &lt;li&gt;需要输入root密码来确认；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;sudo CMD&lt;/code&gt;命令，利用root身份执行命令&lt;code&gt;CMD&lt;/code&gt;：
    &lt;ul&gt;
      &lt;li&gt;需要事先设定普通用户具备sudo的权限；&lt;/li&gt;
      &lt;li&gt;在进行sudo操作时，需要输入普通用户自己的密码；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;su&quot;&gt;su命令&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;man su&lt;/code&gt;来查看命令使用方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NAME
	   su - run a shell with substitute user and group IDs

SYNOPSIS
	   su [OPTION]... [-] [USER [ARG]...]

DESCRIPTION
	   Change  the  effective  user  id  and group id to that of
	   USER.

	   -, -l, --login
			  make the shell a login shell

	   -c, --command=COMMAND
			  pass a single COMMAND to the shell with -c

	   --session-command=COMMAND
			  pass a single COMMAND to the shell with -c and  do
			  not create a new session

	   -f, --fast
			  pass -f to the shell (for csh or tcsh)

	   -m, --preserve-environment
			  do not reset environment variables

	   -p     same as -m

	   -s, --shell=SHELL
			  run SHELL if /etc/shells allows it

	   --help display this help and exit

	   --version
			  output version information and exit

	   A mere - implies -l.   If USER not given, assume root.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要额外说明的一点：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;命令`su root`与`su - root`命令差异很大：
* `su root`：使用login shell方式登录；
* `su - root`：使用non-login shell方式登录；
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;（疑问：login shell 和 non-login shell之间有什么差异？）&lt;/p&gt;

&lt;p&gt;（说明：non-login shell方式登录，很多环境变量无法读取到，需要使用绝度路径的方式来执行）&lt;/p&gt;

&lt;p&gt;命令&lt;code&gt;su - root&lt;/code&gt;需要root密码，因此不方便多用户之间的使用；有没有既能够以root身份来执行命令，同时也不需要root密码的方式？有，sudo命令，就是干这个的。&lt;/p&gt;

&lt;h2 id=&quot;sudo&quot;&gt;sudo命令&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;man sudo&lt;/code&gt;来查看命令详情：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NAME
	   sudo, sudoedit - execute a command as another user

SYNOPSIS
	   sudo -h | -K | -k | -L | -V

	   sudo -v [-AknS] [-g group name|#gid] [-p prompt]
	   [-u user name|#uid] [command]

	   sudo -l[l] [-AknS] [-g group name|#gid] [-p prompt]
	   [-U user name] [-u user name|#uid] [command]

	   sudo [-AbEHnPS] [-C fd] [-g group name|#gid] [-p prompt]
	   [-r role] [-t type] [-u user name|#uid] [VAR=value]
	   [-i | -s] [command]

	   sudoedit [-AnS] [-C fd] [-g group name|#gid] [-p prompt]
	   [-u user name|#uid] file ...

DESCRIPTION
	   sudo allows a permitted user to execute a command as the
	   superuser or another user, as specified in the sudoers
	   file.  The real and effective uid and gid are set to
	   match those of the target user as specified in the passwd
	   file and the group vector is initialized based on the
	   group file (unless the -P option was specified).  If the
	   invoking user is root or if the target user is the same
	   as the invoking user, no password is required.
	   
	   Otherwise, sudo requires that users authenticate
	   themselves with a password by default (NOTE: in the
	   default configuration this is the user’s password, not
	   the root password).  Once a user has been authenticated,
	   a time stamp is updated and the user may then use sudo
	   without a password for a short period of time (5 minutes
	   unless overridden in sudoers).

	   When invoked as sudoedit, the -e option (described
	   below), is implied.

	   sudo determines who is an authorized user by consulting
	   the file /etc/sudoers.  By running sudo with the -v
	   option, a user can update the time stamp without running
	   a command.  If a password is required, sudo will exit if
	   the user’s password is not entered within a configurable
	   time limit.  The default password prompt timeout is 5
	   minutes.

	   If a user who is not listed in the sudoers file tries to
	   run a command via sudo, mail is sent to the proper
	   authorities, as defined at configure time or in the
	   sudoers file (defaults to root).  Note that the mail will
	   not be sent if an unauthorized user tries to run sudo
	   with the -l or -v option.  This allows users to determine
	   for themselves whether or not they are allowed to use
	   sudo.

	   If sudo is run by root and the SUDO_USER environment
	   variable is set, sudo will use this value to determine
	   who the actual user is.  This can be used by a user to
	   log commands through sudo even when a root shell has been
	   invoked.  It also allows the -e option to remain useful
	   even when being run via a sudo-run script or program.
	   Note however, that the sudoers lookup is still done for
	   root, not the user specified by SUDO_USER.

	   sudo can log both successful and unsuccessful attempts
	   (as well as errors) to syslog(3), a log file, or both.
	   By default sudo will log via syslog(3) but this is
	   changeable at configure time or via the sudoers file.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sudo命令，注意事项：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;默认，只有root能使用&lt;code&gt;sudo&lt;/code&gt;命令；&lt;/li&gt;
  &lt;li&gt;基本用法：&lt;code&gt;sudo -u [username] [command]&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;没有指定&lt;code&gt;-u [username]&lt;/code&gt;选项时，默认&lt;code&gt;-u root&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;root执行sudo时，不需要输入密码；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;sudo -u [username] [command]&lt;/code&gt;中当前用户即为&lt;code&gt;username&lt;/code&gt;时，也不需要输入密码；（即，自己切换为自己身份时，不需要输入密码）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;sudo执行流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用户执行sudo时，系统于/etc/sudoers文件中，查找用户是否有执行sudo的权限；&lt;/li&gt;
  &lt;li&gt;若具有执行sudo的权限，则让用户输入自己密码来确认执行；&lt;/li&gt;
  &lt;li&gt;密码正确，则执行命令；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用户是否具有sudo执行权限，依据是/etc/sudoers文件，因此，为某一用户开通sudo权限，本质就是修改/etc/sudoers文件，直接使用vim来编辑，有可能会破坏文件的规范，推荐使用命令&lt;code&gt;visudo&lt;/code&gt;来修改这一文件。&lt;/p&gt;

&lt;h2 id=&quot;visudo&quot;&gt;visudo命令&lt;/h2&gt;

&lt;h3 id=&quot;aroot&quot;&gt;场景A：单个用户拥有root所有命令&lt;/h3&gt;

&lt;p&gt;（分析：拥有root的所有命令？命令难道不是添加到PATH环境变量中就可以了吗？不是的，命令添加到PATH变量中，也是需要用户有这个命令的执行&lt;code&gt;x&lt;/code&gt;权限的。）&lt;/p&gt;

&lt;p&gt;如果希望dev用户使用root的所有命令，那么可以进行如下修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# visudo
...
## Allow root to run any commands anywhere
root    ALL=(ALL)       ALL
# 新增的一行
dev		ALL=(ALL)       ALL
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面对新增行的格式进行简要说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;用户      用户登录来源主机名=(可切换的身份)	可执行的命令
root                     ALL=(ALL)	       	ALL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面四个组件含义进行简要说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用户：这个用户可以使用sudo命令，默认为root用户；&lt;/li&gt;
  &lt;li&gt;用户登录来源主机：设定允许用户通过哪些主机登录过来；&lt;/li&gt;
  &lt;li&gt;可切换的身份：可以切换为什么身份来执行命令，默认root可以切换为任何用户；&lt;/li&gt;
  &lt;li&gt;可执行的命令：务必使用绝对路径；&lt;/li&gt;
  &lt;li&gt;ALL关键词：代表任何身份、主机、命令；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在dev用户就可以执行sudo命令了，按照下面操作试一试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[dev@localhost /]$ head -n 1 /etc/shadow
head: cannot open `/etc/shadow&#39; for reading: Permission denied
[dev@localhost /]$ sudo head -n 1 /etc/shadow
[sudo] password for devp:
root:$6$2t1NiW.e$SM0:16296:0:99999:7:::
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;授予sudo命令的执行权限之前，需调查用户的人品，除非必要，一概不授予普通用户sudo权限。上述设置中，dev用户相当于拥有了整个系统的所有权限，通过&lt;code&gt;sudo visudo&lt;/code&gt;命令，用户&lt;code&gt;dev&lt;/code&gt;也能够像&lt;code&gt;root&lt;/code&gt;用户一样设定所有用户的sudo权限，欧，这也太危险了。&lt;/p&gt;

&lt;h3 id=&quot;bsudo&quot;&gt;场景B：群组的sudo权限及免密码功能&lt;/h3&gt;

&lt;p&gt;如果希望&lt;code&gt;group=dev&lt;/code&gt;内的所有成员都具有sudo命令权限，则进行如下设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# visudo
...
## Allows people in group wheel to run all commands
# %wheel        ALL=(ALL)       ALL
# 新增的一行
%dev   ALL=(ALL)       ALL
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上述设置，&lt;code&gt;group=dev&lt;/code&gt;内成员都具有了sudo权限命令，今后赋予新的成员sudo权限时，只需要将其加入&lt;code&gt;dev&lt;/code&gt;组内即可，而不必每次都修改&lt;code&gt;/etc/sudoers&lt;/code&gt;文件。补充：如何设置用户免密码使用sudo权限？OK，请看如下操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# visudo
...
## Same thing without a password
# %wheel        ALL=(ALL)       NOPASSWD: ALL
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;csudo&quot;&gt;场景C：命令受限的sudo权限&lt;/h3&gt;

&lt;p&gt;前面两个场景中，普通用户获得了与root相当的权限，甚至普通用户反过来能修改root的密码（使用命令：&lt;code&gt;sudo -u root passwd&lt;/code&gt;），这是篡权啊，想想就害怕。然而，害怕并不能解决问题，一些情况下，又必须给普通用户sudo权限，好了，能不能只给用户受限制的sudo权限呢？&lt;/p&gt;

&lt;p&gt;下面以添加用户dev，使其辅助root修改其他用户的密码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# visudo
...
## 为`dev`用户添加权限，使其辅助root修改其他用户密码
dev        ALL=(root)       /usr/bin/passwd [A-Za-Z]*,!/usr/bin/passwd,!/usr/bin/passwd root
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;几点说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过sudo授权用户可执行的命令&lt;code&gt;/usr/bin/passwd&lt;/code&gt;等，要使用绝对路径；&lt;/li&gt;
  &lt;li&gt;多个授权命令之间，使用逗号&lt;code&gt;,&lt;/code&gt;分割；&lt;/li&gt;
  &lt;li&gt;在命令前添加感叹号&lt;code&gt;!&lt;/code&gt;，表示禁止执行此命令；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dvisudo&quot;&gt;场景D：visudo用别名简化配置&lt;/h3&gt;

&lt;p&gt;针对这个情况，举个例子，就清晰了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;User_Alias ADMPW = pro1,pro2
Cmnd_Alias ADMPWCMD = !/usr/bin/passwd, \
		/usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root

ADMPW ALL=(root) ADMPWCOM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际场景中如果忘记了这个例子，没有关系的，只需要&lt;code&gt;visudo&lt;/code&gt;命令，就能看到文件&lt;code&gt;/etc/sudoers&lt;/code&gt;中注释部分的提示了。&lt;/p&gt;

&lt;h3 id=&quot;sudo-1&quot;&gt;sudo命令密码有效时长&lt;/h3&gt;

&lt;p&gt;如果第一次执行sudo命令，则需要输入用户密码，但短时间内T，再次使用sudo命令时，并不需要输入密码。因为系统相信短时间T内，你不会离开服务器，所以再次执行sudo命令，是同一个人。&lt;/p&gt;

&lt;p&gt;（如何设置sudo命令密码的有效时长？）&lt;/p&gt;

&lt;h3 id=&quot;sudosu&quot;&gt;sudo搭配su的使用方式&lt;/h3&gt;

&lt;p&gt;很多时候，我们需要大量的执行很多root的工作，所以，一直使用sudo觉得很烦！那有没有方法使用sudo搭配su，一口气身份转换为root，并且还用用户自己的密码来编程root呢？是有的，而且方法简单的会让你想笑！具体如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@www ~]visudo
...
User_Alias ADMINS =pro1,pro2,pro3
ADMINS ALL=(root) /bin/su -
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，上述pro1、pro2、pro3共计3个用户，只需要输入&lt;code&gt;sudo su -&lt;/code&gt;命令，并且输入自己的密码后，立即转换为root身份了！但root密码不会外流。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特别说明&lt;/strong&gt;：所有sudo用户，都是经过人格调查后，服务器管理员绝对信任的用户，否则，禁掉这一用户的sudo权限。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;《&lt;a href=&quot;&quot;&gt;鸟哥的Linux私房菜 基础版（第三版）–Chapter 14&lt;/a&gt;》&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>ACL入门</title>
     <link href="http://ningg.github.com/linux-acl"/>
     <updated>2014-08-14T00:00:00+08:00</updated>
     <id>http://ningg.github.com/linux-acl</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;文件系统上，文件权限管理的时候，通常有一个词语：ACL。ACL到底是什么？&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;是什么&lt;/h2&gt;

&lt;p&gt;（侧重于ACL能做什么事）&lt;/p&gt;

&lt;p&gt;ACL（&lt;code&gt;Access Control List&lt;/code&gt;，访问控制列表），并不用于设定&lt;code&gt;文件&lt;/code&gt;/&lt;code&gt;目录&lt;/code&gt;的owner、group、others的read、write、execute（&lt;code&gt;r&lt;/code&gt;,&lt;code&gt;w&lt;/code&gt;,&lt;code&gt;x&lt;/code&gt;）权限，而是除此权限设置之外的更细节的权限设置。&lt;/p&gt;

&lt;p&gt;特别说明：实际上，ACL也可以设置文件owner、group、others对应的&lt;code&gt;r&lt;/code&gt;/&lt;code&gt;w&lt;/code&gt;/&lt;code&gt;e&lt;/code&gt;权限，但我们通常使用&lt;code&gt;chmod&lt;/code&gt;命令来实现此功能，而倾向将ACL用于除此之外的权限设置。&lt;/p&gt;

&lt;p&gt;ACL设定的权限主要有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用者（&lt;code&gt;user&lt;/code&gt;）：设置某个使用者（&lt;code&gt;user&lt;/code&gt;）读、写、执行一个文件的权限；解释：此处的&lt;code&gt;user&lt;/code&gt;，不是&lt;code&gt;owner&lt;/code&gt;，而是其他的用户；&lt;/li&gt;
  &lt;li&gt;群组（&lt;code&gt;group&lt;/code&gt;）：设置某个群组（&lt;code&gt;group&lt;/code&gt;）读、写、执行一个文件的权限；解释：此处的&lt;code&gt;group&lt;/code&gt;不是指，文件对应的&lt;code&gt;owning group&lt;/code&gt;的执行权限，而是除&lt;code&gt;owning group&lt;/code&gt;之外的其他&lt;code&gt;group&lt;/code&gt;，操作此文件的权限；&lt;/li&gt;
  &lt;li&gt;默认属性（&lt;code&gt;mask&lt;/code&gt;）：设定某一个&lt;code&gt;目录&lt;/code&gt;之下，新建&lt;code&gt;文件&lt;/code&gt;/&lt;code&gt;目录&lt;/code&gt;时，这些新建的&lt;code&gt;文件&lt;/code&gt;/&lt;code&gt;目录&lt;/code&gt;的默认权限;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（上面内容有待补充）&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;怎么用&lt;/h2&gt;

&lt;p&gt;ACL（&lt;code&gt;访问控制列表&lt;/code&gt;），是Unix-like操作系统权限的额外支持项目，需要文件系统（&lt;code&gt;File System&lt;/code&gt;）的支持。当前大部分文件系统都支持ACL，例如：EXT2/3
、JFS、XFS等。&lt;/p&gt;

&lt;h3 id=&quot;acl&quot;&gt;是否支持ACL&lt;/h3&gt;

&lt;p&gt;使用命令&lt;code&gt;dumpe2fs -h /dev/sda1&lt;/code&gt;查看某一分区上文件系统是否支持ACL，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost devp]# dumpe2fs -h /dev/sda1
dumpe2fs 1.41.12 (17-May-2010)
...
Default mount options:    user_xattr acl
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：&lt;code&gt;dumpe2fs&lt;/code&gt;含义：dump ext2/ext3/ext4 filesystem information.	&lt;/p&gt;

&lt;h3 id=&quot;acl-1&quot;&gt;是否启用ACL&lt;/h3&gt;

&lt;p&gt;文件系统支持ACL，即有能力开启ACL，但是文件系统需要开启ACL，通过如下方式来查询是否开启ACL：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 直接参阅挂载参数
[root@localhost ~]# mount
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
tmpfs on /dev/shm type tmpfs (rw)
/dev/sda1 on /boot type ext4 (rw)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;备注：“是否支持ACL”和“是否启用ACL”这两部分，自己理解不能肯定，需要补充。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;两个命令&lt;/h3&gt;

&lt;p&gt;filesystem启动ACL支持之后，就可以设定和查看ACL了，主要是两条命令：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;getfacl&lt;/code&gt;：查看文件的ACL；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;setfacl&lt;/code&gt;：设置文件的ACL；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两个命令侧重于使用命令：&lt;code&gt;man [COMMAND]&lt;/code&gt;来查看命令细节。两个命令相互配合使用，通常&lt;code&gt;setfacl&lt;/code&gt;之后，跟着一个&lt;code&gt;getfacl&lt;/code&gt;来查看设置是否成功。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;几个场景和实例&lt;/h3&gt;

&lt;h4 id=&quot;section-5&quot;&gt;简介&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;setfacl&lt;/code&gt;：&lt;code&gt;set file access control list&lt;/code&gt;，设置ACL。命令详情如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[superman@localhost /]$ setfacl --help
setfacl 2.2.49 -- `set file access control lists`
Usage: setfacl [-bkndRLP] { -m|-M|-x|-X ... } file ...
  -m, --modify=acl        modify the current ACL(s) of file(s)
  -M, --modify-file=file  read ACL entries to modify from file
  -x, --remove=acl        remove entries from the ACL(s) of file(s)
  -X, --remove-file=file  read ACL entries to remove from file
  -b, --remove-all        remove all extended ACL entries
  -k, --remove-default    remove the default ACL
	  --set=acl           set the ACL of file(s), replacing the current ACL
	  --set-file=file     read ACL entries to set from file
	  --mask              do recalculate the effective rights mask
  -n, --no-mask           don&#39;t recalculate the effective rights mask
  -d, --default           operations apply to the default ACL
  -R, --recursive         recurse into subdirectories
  -L, --logical           logical walk, follow symbolic links
  -P, --physical          physical walk, do not follow symbolic links
	  --restore=file      restore ACLs (inverse of `getfacl -R&#39;)
	  --test              test mode (ACLs are not modified)
  -v, --version           print version and exit
  -h, --help              this help text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getfacl&lt;/code&gt;：&lt;code&gt;get file access control lists&lt;/code&gt;，查看ACL。命令详情如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[god@localhost /]$ getfacl -h
getfacl 2.2.49 -- get file access control lists
Usage: getfacl [-aceEsRLPtpndvh] file ...
  -a,  --access           display the file access control list only
  -d, --default           display the default access control list only
  -c, --omit-header       do not display the comment header
  -e, --all-effective     print all effective rights
  -E, --no-effective      print no effective rights
  -s, --skip-base         skip files that only have the base entries
  -R, --recursive         recurse into subdirectories
  -L, --logical           logical walk, follow symbolic links
  -P, --physical          physical walk, do not follow symbolic links
  -t, --tabular           use tabular output format
  -n, --numeric           print numeric user/group identifiers
  -p, --absolute-names    don&#39;t strip leading &#39;/&#39; in pathnames
  -v, --version           print version and exit
  -h, --help              this help text
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;user&quot;&gt;场景1：设置user权限&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;场景描述：让devp用户获取查看&lt;code&gt;/root&lt;/code&gt;目录的权限。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;设置user权限的命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setfacl -m u:devp:rx /root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 查看目录详情（不是目录下内容列表）
// 查询结果中`dr-xr-x---+`，最后的`+`表示有ACL附加权限；
[god@localhost /]# ll -d root
dr-xr-x---+ 18 root root 4096 Aug  5 09:32 root
// 查看ACL详情
[god@localhost /]# getfacl root
# file: root 
# owner: root
# group: root
user::r-x       //`owner`的权限
user:devp:r-x   //用户`devp`的权限（ACL设置的细节）
group::r-x      //`owning group`的权限
mask::r-x       //什么含义？（ACL设置的细节）
other::---
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;user-1&quot;&gt;场景2：取消user权限&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;场景描述：在场景1中设置了devp用户查看&lt;code&gt;/root&lt;/code&gt;目录的权限，如何取消devp用户的这一权限呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;取消&lt;code&gt;user&lt;/code&gt;权限的命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setfacl -x u:devp /root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 查看ACL详情
[god@localhost /]# getfacl root
# file: root 
# owner: root
# group: root
user::r-x       //`owner`的权限
group::r-x      //`owning group`的权限
mask::r-x       
other::---
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;group&quot;&gt;场景3：设置group权限&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;场景描述：如何设置&lt;code&gt;devp&lt;/code&gt;组拥有&lt;code&gt;/root&lt;/code&gt;目录的查看权限？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;设置命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set -m g:devp:rx /root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询结果：&lt;/p&gt;

&lt;p&gt;（未完待续，各个典型场景）	&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;什么原理&lt;/h2&gt;

&lt;p&gt;（参考：Hadoop技术内幕中HDFS的架构设计与实现原理）&lt;/p&gt;

&lt;h2 id=&quot;hdfsacl&quot;&gt;HDFS中的ACL&lt;/h2&gt;

&lt;p&gt;Hadoop从2.4.0版本开始支持ACL（英文原版的出处），并且已经有人对此进行了测试：http://blog.csdn.net/j2eelamp/article/details/24594159&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>HTTP协议</title>
     <link href="http://ningg.github.com/protocol-http-intro"/>
     <updated>2014-08-13T00:00:00+08:00</updated>
     <id>http://ningg.github.com/protocol-http-intro</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;最近要用java来构造HTTP请求、接收HTTP响应，并从HTTP响应中获取尽可能多的上下文信息，自己每次都查看JAVA的API，不过结果总是浑浑噩噩的感觉，因为自己并不确定HTTP响应中包含了哪些详细的信息，更何谈要提取这些信息了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（备注：不要求大而全，而要求先能够解决问题）&lt;/p&gt;

&lt;h2 id=&quot;http&quot;&gt;HTTP协议的由来&lt;/h2&gt;

&lt;p&gt;OSI模型把网络通信分成七层：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层，对于开发网络应用人员来说，一般把网络分成五层，这样比较容易理解。这五层为：物理层、数据链路层、网络层、传输层和应用层（最顶层），如下图所示：&lt;/p&gt;

&lt;p&gt;网络中的计算机互相通信就是实现了层与层之间的通信，要实现层与层之间的通信，则各层都要遵守规则，这样才能完成更好的通信， 我们就把它们之间遵守的规则就叫个“协议”，然而网络上的五层之间遵守的协议不一样，每层都有各自的协议。下面就对各层进行简要介绍：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;物理层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;物理层是五层模型中的最底层，物理层为计算机之间的数据通信提供了传输媒体和互连设备的标准，为数据传输提供了可靠的环境，媒体包括电缆、光纤、无线信道等，互连设备指是计算机和调制解调器之间的互连设备，如各种插头、插座等。该层的作用是透明的传输比特流（即二进制流），为数据链路层提供一个传输原始比特流的物理连接。&lt;/p&gt;

&lt;p&gt;总结一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;目标：透明地传输bit。&lt;/li&gt;
  &lt;li&gt;传输单元：bit。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;数据链路层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据链路层是模型中的第2层，该层对接受到物理层传输过来的比特流进行分组，一组电信号构成的数据包，就叫做”帧”，数据链链路层就是来传输以”帧”为单位的数据包，把数据传递给上一层（网络层），帧数据由两部分组成：帧头和帧数据，帧头包括接受方物理地址（就是网卡的地址）和其他的网络信息，帧数据就是要传输的数据体。数据帧的最长为1500字节，如果数据很长，就必须分割成多个帧进行发送。&lt;/p&gt;

&lt;p&gt;总结一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;目标：通过&lt;code&gt;MAC地址&lt;/code&gt;来标识设备，并且在两个相邻设备之间，透明、可靠地传输&lt;code&gt;数据帧&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;传输单元：&lt;code&gt;帧&lt;/code&gt;，包含帧头和帧数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该层通过寻址（寻址地址）来建立两个节点之间的连接，大家都知道我们的电脑连接上网络后都一个IP地址，我们可以通过IP地址来确定不同的计算机是否在同一个子网内。如果我们的电脑连接上网络后就有两种地址：物理地址和网络地址（IP地址），网络上的计算机要通信，必须要知道通信的计算机“在哪里”， 首先通过网络地址来判断是否处于同一个子网，然后再对物理地址（MAC）地址进行处理，从而准确确定要通信计算机的位置。&lt;/p&gt;

&lt;p&gt;在网络层中有我们熟悉的IP协议（即规定网络地址的协议），目前广泛采用的是IP协议第四版（IPv4）,这个版本规定，网络地址由32位二进制位组成。&lt;/p&gt;

&lt;p&gt;网络层中以IP数据包的形式来传递数据，IP数据包也包括两部分：头（Head）和数据(Data)，IP数据包放进数据帧中的数据部分进行传输。&lt;/p&gt;

&lt;p&gt;总结一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;目标：通过&lt;code&gt;IP地址&lt;/code&gt;来标识网络节点，并且在网络中任意两个节点之间，透明、可靠地传输&lt;code&gt;IP数据包&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;传输单元：&lt;code&gt;IP数据包&lt;/code&gt;，包含包头和数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过MAC和IP地址，我们可以找到互联网上任意两台主机来建立通信。然而这里有一个问题，找到主机后，主机上有很多程序都需要用到网络，比如说你在一边听歌和好用QQ聊天，当网络上发送来一个数据包时，是怎么知道它是表示聊天的内容还是歌曲的内容的， 这时候就需要一个参数来表示这个数据包是发送给那个程序（进程）来使用的，这个参数我们就叫做&lt;code&gt;端口号&lt;/code&gt;，主机上用端口号来标识不同的程序（进程），端口是0到65535之间的一个整数，0到1023的端口被系统占用，用户只能选择大于1023的端口。&lt;/p&gt;

&lt;p&gt;传输层的功能就是建立端口到端口的通信，网络层就是建立主机与主机的通信，这样如果我们确定了主机和端口，这样就可以实现程序之间的通信了。我们所说的Socket编程就是通过代码来实现传输层之间的通信。因为初始化Socket类对象要指定IP地址和端口号。&lt;/p&gt;

&lt;p&gt;在传输层有两个非常重要的协议：UDP 协议和TCP协议&lt;/p&gt;

&lt;p&gt;采用UDP协议话传输的就是UDP数据包，同样UDP数据包也由头和数据两部分组成，头部分主要标识了发送端口和接受端口，数据部分就是具体的内容信息。同样UDP数据包是放入IP数据包中的”数据”部分，IP数据包再放入数据帧中在网络上传输。&lt;/p&gt;

&lt;p&gt;由于UDP协议的可靠性差（数据发送后无法确定对方是否收到），所以又定义了一个可靠性高的协议——TCP协议，TCP协议采取了握手的方式要确保对方收到了数据。&lt;/p&gt;

&lt;p&gt;总结一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;目标：通过&lt;code&gt;IP地址：端口号&lt;/code&gt;来标识网络节点上的一个进程，并在网络中任意两个节点上的两个进程之间，实现消息的透明传输。&lt;/li&gt;
  &lt;li&gt;传输单元：数据包，TCP数据包或者UDP数据包。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;应用层是模型中的最顶层，是用户与网络的接口，HTTP协议就属于这一层。HTTP协议能做什么？
很多人首先一定会想到：浏览网页。没错，浏览网页是HTTP的主要应用，但是这并不代表HTTP就只能应用于网页的浏览。HTTP是一种协议，只要通信的双方都遵守这个协议，HTTP就能有用武之地。比如咱们常用的QQ，迅雷这些软件，都会使用HTTP协议(还包括其他的协议)。需要说明的是，应用层HTTP协议传输的数据，在传输层，是由TCP协议承载的。&lt;/p&gt;

&lt;p&gt;数据流动的时候，发送端，应用数据从上层向下，层层打包（添加包头），接收端，数据从下层向上，层层解包（去除包头）。&lt;/p&gt;

&lt;p&gt;（应用层到底是什么？应用层与端口之间什么关系？会话层、表示层、应用层之间又有什么差异？）&lt;/p&gt;

&lt;h2 id=&quot;http-1&quot;&gt;HTTP协议如何工作&lt;/h2&gt;

&lt;p&gt;利用HTTP协议传输数据时，其基本过程：Client发送HTTP请求，Server返回HTTP响应；如下图所示：&lt;/p&gt;

&lt;p&gt;（插入一个图片）&lt;/p&gt;

&lt;h3 id=&quot;requestresponse&quot;&gt;Request\Response格式&lt;/h3&gt;

&lt;p&gt;详细信息请参考：&lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;关于HTTP headers的简要汇总和介绍，请参看：&lt;a href=&quot;http://www.cs.tut.fi/~jkorpela/http.html&quot;&gt;Quick reference to HTTP headers&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;request&quot;&gt;Request&lt;/h4&gt;

&lt;p&gt;Request格式：&lt;/p&gt;

&lt;p&gt;（插入一张图片：Request格式）&lt;/p&gt;

&lt;p&gt;备注：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;cr&gt;&lt;lf&gt;为回车换行，其中：CR，Carriage Return，回车，打字机头部位置；LF，Line Feed，换行，打字机向下换一行；
&lt;/lf&gt;&lt;/cr&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Null Line&lt;/code&gt;中必须只有&lt;cr&gt;&lt;lf&gt;而无其他空格；&lt;/lf&gt;&lt;/cr&gt;&lt;/li&gt;
  &lt;li&gt;在HTTP/1.1协议中，所有的&lt;code&gt;Headers&lt;/code&gt;中，除Host外，都是可选的；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Requset实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET http://www.cnblogs.com/gpcuster/ HTTP/1.1
Host: www.cnblogs.com
Proxy-Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36
Referer: http://www.baidu.com/s?wd=http%3A%2F%2Fwww.cnblogs.com%2Fgpcuster%2F&amp;amp;rsv_spt=1&amp;amp;issp=1&amp;amp;rsv_bp=0&amp;amp;ie=utf-8&amp;amp;tn=baiduhome_pg&amp;amp;rsv_n=2&amp;amp;rsv_sug3=1&amp;amp;rsv_sug4=271&amp;amp;inputT=2186
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: __gads=ID=d58f6aafc2b1682a:T=1399182693:S=ALNI_MbGQmpINTGEw1DKhg8-v-WGcqmDGg; CNZZDATA4902471=cnzz_eid%3D780096130-1402377079-http%253A%252F%252Fwww.baidu.com%252F%26ntime%3D1403490466; CNZZDATA3980738=cnzz_eid%3D371156967-1402987944-http%253A%252F%252Fwww.baidu.com%252F%26ntime%3D1404384515; CNZZDATA1923552=cnzz_eid%3D857445479-1402888944-http%253A%252F%252Fwww.cnblogs.com%252F%26ntime%3D1405079579; AJSTAT_ok_times=5; gs_u_GSN-690926-A=567797657:3115:11443:1407743725372; _ga=GA1.2.1054927095.1399182860; __utma=226521935.1054927095.1399182860.1407743656.1407743991.33; __utmb=226521935.2.10.1407743991; __utmc=226521935; __utmz=226521935.1407743991.33.27.utmcsr=baidu|utmccn=(organic)|utmcmd=organic|utmctr=http%3A%2F%2Fwww.cnblogs.com%2Fgpcuster%2F
If-Modified-Since: Mon, 11 Aug 2014 07:59:18 GMT
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;response&quot;&gt;Response&lt;/h4&gt;

&lt;p&gt;Response格式：&lt;/p&gt;

&lt;p&gt;（插入一张图片：Response格式）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Date: Mon, 11 Aug 2014 07:59:41 GMT
Content-Type: text/html; charset=utf-8
Transfer-Encoding: chunked
Proxy-Connection: keep-alive
Vary: Accept-Encoding
Cache-Control: private, max-age=10
Expires: Mon, 11 Aug 2014 07:59:33 GMT
Last-Modified: Mon, 11 Aug 2014 07:59:23 GMT
X-UA-Compatible: IE=10
Content-Encoding: gzip
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;headers&quot;&gt;常用的Headers&lt;/h4&gt;

&lt;p&gt;（doing…）&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;http://blog.csdn.net/adparking/article/details/7265496
http://blog.csdn.net/kfanning/article/details/6062118
http://www.cnblogs.com/loveyakamoz/archive/2011/07/22/2113614.html
http://blog.sina.com.cn/s/blog_5dd2af0901012oko.html
http://canrry.iteye.com/blog/1331292&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;建立连接的方式&lt;/h3&gt;

&lt;p&gt;HTTP支持2种建立连接的方式：非持久连接和持久连接（HTTP 1.0 默认：持久连接的带流水线方式）&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;非持久连接&lt;/h4&gt;

&lt;p&gt;让我们查看一下非持久连接情况下，从Server到Client传送一个Web页面的步骤。假设该页面由：1个基本HTML文件和10个JPEG图像构成，而且所有这些对象都存放在同一台服务器中。再假设该基本HTML文件的URL为：&lt;code&gt;gpcuster.cnblogs.com/index.html&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;下面是具体步骡:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;HTTP Client&lt;/code&gt;初始化一个与&lt;code&gt;HTTP Server&lt;/code&gt;之间的TCP连接。&lt;code&gt;HTTP Server&lt;/code&gt;使用默认端口号80监听来自&lt;code&gt;HTTP Client&lt;/code&gt;的连接建立请求。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;HTTP Client&lt;/code&gt;经由与TCP连接相关联的本地套接字，发出—个HTTP请求消息。这个消息中包含路径名/somepath/index.html。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;HTTP Server&lt;/code&gt; 经由与TCP连接相关联的本地套接字，接收这个请求消息，再从服务器主机的内存或硬盘中取出对象/somepath/index.html，经由同一个套接字发出包含该对象的响应消息。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;HTTP Server&lt;/code&gt;告知TCP关闭这个TCP连接(不过TCP要到客户收到刚才这个响应消息之后才会真正终止这个连接)。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;HTTP Client&lt;/code&gt;经由同一个套接字接收这个响应消息，TCP连接随后终止。&lt;/li&gt;
  &lt;li&gt;HTTP响应中，所封装的对象是一个HTML文件。&lt;code&gt;HTTP Server&lt;/code&gt;从响应中取出这个HTML文件，加以分析后发现其中有10个JPEG对象的引用。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;HTTP Client&lt;/code&gt;针对每一个JPEG对象引用，重复步骡1-5。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述步骤之所以称为&lt;code&gt;非持久连接&lt;/code&gt;，原因是每次&lt;code&gt;HTTP Server&lt;/code&gt;返回一个HTTP响应后，相应的TCP连接就被关闭，即，每个TCP连接只用于传输一个请求消息和一个响应消息。针对上述例子，用户每请求一次那个web页面，就反复建立、释放了11个TCP连接。&lt;/p&gt;

&lt;p&gt;关于非持久连接，总结一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP请求之前，建立TCP连接，HTTP响应之后，释放TCP连接；&lt;/li&gt;
  &lt;li&gt;每个TCP连接只承载一组HTTP请求和响应消息；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;备注：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;名词&lt;code&gt;套接字&lt;/code&gt;socket是什么？&lt;/li&gt;
  &lt;li&gt;TCP连接建立时，有3次握手，详细过程；&lt;/li&gt;
  &lt;li&gt;TCP连接释放时，也有4次握手，详细过程；&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;持久连接&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;非持久连接&lt;/code&gt;有几点效率问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每个等待请求的对象，都需要建立并维护一个独立的TCP连接；对于每个这样的连接，TCP得在客户端和服务器端分配TCP缓冲区，并维持TCP变量。对于有可能同时为来自数百个不同客户的请求提供服务的web服务器来说，这会严重增加其负担。&lt;/li&gt;
  &lt;li&gt;如前所述，每个对象都有2个RTT的响应延长——一个RTT用于建立TCP连接，另—个RTT用于请求和接收对象。&lt;/li&gt;
  &lt;li&gt;每个对象都受TCP慢启动影响，因为每个TCP连接都有一个慢启动阶段。&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;（优点）&lt;/em&gt;也有优势：并行TCP连接的使用，能够部分减轻RTT延迟和慢启动延迟的影响。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为解决非持久连接情况下，反复建立、释放TCP连接时，所产生的资源占用、效率低下的问题，提出了&lt;code&gt;持久连接&lt;/code&gt;，其核心：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;HTTP Server&lt;/code&gt;返回一个HTTP响应之后，TCP连接保持存活一段时间，用于承载后续的其他HTTP请求/响应;&lt;/li&gt;
  &lt;li&gt;TCP连接的存活时间是可以设定的;&lt;/li&gt;
  &lt;li&gt;超过存活时间之后，TCP连接自动释放；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;持久连接分为&lt;code&gt;不带流水线(without pipelining)&lt;/code&gt;和&lt;code&gt;带流水线(with pipelining)&lt;/code&gt;两个版本。&lt;/p&gt;

&lt;p&gt;不带流水线的持久化连接，特点如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Client只在收到前一个请求的响应后才发出新的请求，这种情况下，web页面所引用的每个对象(上例中的10个图像)都经历1个RTT的延迟，用于请求和接收该对象；&lt;/li&gt;
  &lt;li&gt;服务器返回一个响应后，开始等待下一个请求，而这个新请求却不能马上到达，这段时间服务器资源便闲置了；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;带流水线的持久化连接，特点如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HTTP/1.1的默认模式；&lt;/li&gt;
  &lt;li&gt;HTTP Client每碰到一个对象引用，就立即发出一个请求（如果没有可用的TCP连接，则新建一个），&lt;code&gt;HTTP Server&lt;/code&gt;每收到一个请求，就立即返回一个响应；&lt;/li&gt;
  &lt;li&gt;所有引用到的对象一共只经历1个RTT的延迟(而不是像不带流水线的版本那样，每个引用到的对象都各有1个RTT的延迟)；&lt;/li&gt;
  &lt;li&gt;带流水线的持久连接中服务器空等请求的时间比较少；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-4&quot;&gt;缓存机制&lt;/h3&gt;

&lt;p&gt;HTTP/1.1中缓存机制主要目标：提高页面访问速度；实现途径，有两条：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;减少Client发送请求的次数：Client本地缓存页面，发送请求之前先检查一下，当前缓存页面是否&lt;code&gt;过期（expiration）&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;Server只发送局部响应信息：即，Server不返回完整的响应信息，以此减少网络带宽的占用，&lt;code&gt;验证（validation）&lt;/code&gt;机制能够实现此目标；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实际上，HTTP定义了3中缓存机制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Freshness&lt;/strong&gt; allows a response to be used without re-checking it on the origin server, and can be controlled by both the server and the client. For example, the Expires response header gives a date when the document becomes stale, and the Cache-Control: max-age directive tells the cache how many seconds the response is fresh for.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Validation&lt;/strong&gt; can be used to check whether a cached response is still good after it becomes stale. For example, if the response has a Last-Modified header, a cache can make a conditional request using the If-Modified-Since header to see if it has changed.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Invalidation&lt;/strong&gt; is usually a side effect of another request that passes through the cache. For example, if URL associated with a cached response subsequently gets a POST, PUT or DELETE request, the cached response will be invalidated.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于web缓存方面的内容可以参考：Caching Tutorial for Web Authors and Webmasters（&lt;a href=&quot;https://www.mnot.net/cache_docs/#DEFINITION&quot;&gt;英文版&lt;/a&gt;）（&lt;a href=&quot;http://www.chedong.com/tech/cache_docs.html&quot;&gt;中文版&lt;/a&gt;）&lt;/p&gt;

&lt;h2 id=&quot;http-2&quot;&gt;基于HTTP的应用&lt;/h2&gt;

&lt;h3 id=&quot;http-3&quot;&gt;HTTP代理&lt;/h3&gt;

&lt;p&gt;（doing…）&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html&quot;&gt;浅析HTTP协议&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;透明代理&lt;/li&gt;
  &lt;li&gt;非透明代理&lt;/li&gt;
  &lt;li&gt;反向代理&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-5&quot;&gt;多线程下载&lt;/h3&gt;

&lt;p&gt;（doing…）&lt;/p&gt;

&lt;p&gt;基本过程如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;下载工具开启多个线程，来发出HTTP请求；&lt;/li&gt;
  &lt;li&gt;每个HTTP请求只请求资源文件的一部分：Content-Range:bytes 20000-40000/47000&lt;/li&gt;
  &lt;li&gt;合并每个线程下载的文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;https&quot;&gt;HTTPS传输协议原理&lt;/h3&gt;

&lt;p&gt;（doing…）&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html&quot;&gt;浅析HTTP协议&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;webrequest-methods&quot;&gt;WEB开发过程中常用的Request Methods&lt;/h3&gt;

&lt;p&gt;（doing…）&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html&quot;&gt;浅析HTTP协议&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HEAD
  *（Head方法）要求响应与相应的GET请求的响应一样，但是没有的响应体（response body）。这用来获得响应头（response header）中的元数据信息（meta-infomation）有（很）帮助，（因为）它不需要传输所有的内容。&lt;/li&gt;
  &lt;li&gt;TRACE
  *（Trace方法告诉服务器端）返回收到的请求。客户端可以（通过此方法）察看在请求过程中中间服务器添加或者改变哪些内容。&lt;/li&gt;
  &lt;li&gt;OPTIONS
    &lt;ul&gt;
      &lt;li&gt;返回服务器（在指定URL上）支持的HTTP方法。通过请求“*”而不是指定的资源，这个方法可以用来检查网络服务器的功能。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CONNECT
    &lt;ul&gt;
      &lt;li&gt;将请求的连接转换成透明的TCP/IP通道，通常用来简化通过非加密的HTTP代理的SSL-加密通讯（HTTPS）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;用户与服务器交互&lt;/h3&gt;

&lt;p&gt;（doing…）&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html&quot;&gt;浅析HTTP协议&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;身份认证；&lt;/li&gt;
  &lt;li&gt;cookie；&lt;/li&gt;
  &lt;li&gt;待条件的GET；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;javahttp&quot;&gt;java中的HTTP协议&lt;/h2&gt;

&lt;p&gt;（doing…）&lt;/p&gt;

&lt;h3 id=&quot;javahttp-1&quot;&gt;java中HTTP协议&lt;/h3&gt;

&lt;p&gt;（主要两种方式：java api 和 http-common.jar?）&lt;/p&gt;

&lt;h3 id=&quot;servlethttp&quot;&gt;servlet中HTTP协议&lt;/h3&gt;

&lt;h2 id=&quot;section-7&quot;&gt;参考来源&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.w3.org/Protocols/&quot;&gt;W3C: HTTP (HTTP Activity statement)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.chinaw3c.org/about.html&quot;&gt;W3C中文版简介&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/qiqibo/p/3143964.html&quot;&gt;HTTP协议原理解析第一篇&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html&quot;&gt;浅析HTTP协议&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.chedong.com/tech/cache_docs.html&quot;&gt;面向站长和网站管理员的Web缓存加速指南-翻译&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cs.tut.fi/~jkorpela/http.html&quot;&gt;Quick reference to HTTP headers&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;[O’Reilly - HTTP Pocket Reference]&lt;/li&gt;
  &lt;li&gt;[Sams - HTTP Developers Handbook]&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-8&quot;&gt;附录&lt;/h2&gt;

&lt;p&gt;对与几个名词/组织的简介&lt;/p&gt;

&lt;h3 id=&quot;w3c&quot;&gt;W3C&lt;/h3&gt;
&lt;p&gt;万维网联盟（World Wide Web Consortium，简称W3C）创建与1994年，是Web技术领域，影响力较强的国际中立性，技术标准机构。其致力于开发协议、标准、指南，来确保Web的长期发展。详细信息参考：&lt;a href=&quot;http://www.w3.org/Protocols/&quot;&gt;W3C: HTTP (HTTP Activity statement)&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;ietf&quot;&gt;IETF&lt;/h3&gt;
&lt;p&gt;互联网工程任务组（Internet Engineering Task Force，简称IETF）成立于1985年底，是全球互联网领域，极具权威的技术标准化组织，主要任务是负责互联网相关技术规范的研发和制定，当前绝大多数互联网技术标准都出自IETF。详细信息参考：&lt;a href=&quot;http://www.ietf.org/&quot;&gt;IETF&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;rfc&quot;&gt;RFC&lt;/h3&gt;

&lt;p&gt;IETF（互联网工程任务组）产生两种文件，一个叫Internet Draft，即”互联网草案”，另一个叫RFC（Request For Comments，意见征求书、请求注解书），RFC相对Draft更为正式，一般情况下，RFC文档发布后，其内容不再做变动。&lt;/p&gt;

&lt;p&gt;[O’Reilly - HTTP Pocket Reference]:		
[Sams - HTTP Developers Handbook]:		&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Linux的环境变量</title>
     <link href="http://ningg.github.com/linux-env-var"/>
     <updated>2014-07-28T00:00:00+08:00</updated>
     <id>http://ningg.github.com/linux-env-var</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近某个需求，要去修改jar包内的配置文件，中间几个细节不想多说，但期间有个需求是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将Linux自带的JDK由OpenJDK升级为Oracle(Sun)版本的JDK；&lt;/li&gt;
  &lt;li&gt;要求所有用户都能使用Oracle(Sun)版本的JDK；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;安装软件&lt;/h2&gt;

&lt;p&gt;这次把软件的安装过程拿出来，为了说明几件小事：Linux下安装软件最好通过已成符号链接文件进行，以方便软件今后的升级；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 将jdk的压缩文件解压到目录/usr/java下，解压之后文件夹为jdk-7u51-linux-x64
tar -zxvf jdk-7u51-linux-x64.gz -C /usr/java
// 在目录/usr/java下新建一个符号连接default
ln -n jdk-7u51-linux-x64 default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面添加环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim ~/.bashrc
// 添加环境变量JAVA_HOME（要求：对所有用户有效）
export JAVA_HOME=/usr/java/default
// 将java添加到PATH中（要求：对所有用户有效）
export PATH=$JAVA_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：上面使用符号链接文件的方式，来设置软件安装路径，方便软件升级，很巧妙，仔细体会一下。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;环境变量&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;简介&lt;/h3&gt;

&lt;p&gt;变量的作用范围一般是某个进程（正在运行的程序）之内，如果希望多个进程共享这个变量，也是可以的，将这个变量设置为&lt;code&gt;环境变量&lt;/code&gt;即可。&lt;/p&gt;

&lt;p&gt;上面可以看出：环境变量是在某个进程中设置的，而且，目标是希望其他进程共享。&lt;/p&gt;

&lt;p&gt;设置环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export JAVA_HOME=/usr/java/default
export PATH=$PATH:$JAVA_HOME/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;作用范围&lt;/h3&gt;

&lt;p&gt;当前系统中设置的环境变量，两个基本问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;环境变量在哪设置的？&lt;/li&gt;
  &lt;li&gt;它的作用范围是什么？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;环境变量&lt;/code&gt;是在一个bash进程中定义的，其作用范围是当前进程以及当前进程的所有子进程。&lt;/p&gt;

&lt;p&gt;根据范围大小，可以设置一些环境变量：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;所有bash进程共享的环境变量；&lt;/li&gt;
  &lt;li&gt;某个用户独享的环境变量；&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;/etc/profile：整个系统共享的环境变量；&lt;/li&gt;
  &lt;li&gt;~/.bash_profile 或者 ~/.bash_login 或者 ~/.profile 或者 ~/.bashrc，各个用户独享的环境变量；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（详解：各个文件加载过程？以及各个文件的用途，为什么要分这么多文件/层次来加载？等待补充）&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;《鸟哥私房菜（第三版）》 第11章 认识和学习BASH&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>Linux下用户和组管理</title>
     <link href="http://ningg.github.com/linux-user-and-group"/>
     <updated>2014-07-27T00:00:00+08:00</updated>
     <id>http://ningg.github.com/linux-user-and-group</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;平日里，常遇到几个需求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Linux服务器上，为新人开个账号，并加入到某一组中；&lt;/li&gt;
  &lt;li&gt;查询，组中的所有用户；&lt;/li&gt;
  &lt;li&gt;查询，用户是否存在；&lt;/li&gt;
  &lt;li&gt;查询，某一用户所在组；&lt;/li&gt;
  &lt;li&gt;用户和组管理，如何实现的；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;如何使用&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;几个命令&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;用户相关&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;useradd [LOGIN]&lt;/code&gt;：新增用户&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;passwd [LOGIN]&lt;/code&gt;：设置用户密码&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;usermod [options] [LOGIN]&lt;/code&gt;：修改用户的属性信息，与&lt;code&gt;useradd&lt;/code&gt;类似&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;userdel [LOGIN]&lt;/code&gt;：删除用户&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;whoami&lt;/code&gt;：当前登录的用户&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;用户组相关&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;groups [LOGIN]&lt;/code&gt;：查询用户所属组&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;groupadd [GROUP]&lt;/code&gt;：新增用户组&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;gpasswd [GROUP]&lt;/code&gt;：设置组成员、添加组管理员（参考命令：&lt;code&gt;usermod&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;groupmod [GROUP]&lt;/code&gt;：修改用户组信息，与&lt;code&gt;groupadd&lt;/code&gt;类似&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;groupdel [GROUP]&lt;/code&gt;：删除组&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;newgrp [GROUP]&lt;/code&gt;：设置&lt;code&gt;有效组&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注：作为&lt;code&gt;初始组&lt;/code&gt;的用户组，无法使用命令&lt;code&gt;groupdel&lt;/code&gt;进行删除。&lt;/p&gt;

&lt;p&gt;上面的命令，细节不想多说，用的时候，直接&lt;code&gt;man command&lt;/code&gt;查看帮助文档即可。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;几个文件&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;文件&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;/etc/passwd&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用户信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;/etc/shadow&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用户密码信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;/etc/group&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用户组信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;/etc/gshadow&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用户组管理信息&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;etcpasswd&quot;&gt;/etc/passwd&lt;/h4&gt;

&lt;p&gt;文件片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
hbase:x:1002:507::/home/hbase:/bin/bash
nagios:x:1003:508::/home/nagios:/bin/bash
oozie:x:1004:507::/home/oozie:/bin/bash
hcat:x:1005:507::/home/hcat:/bin/bash
hive:x:1006:507::/home/hive:/bin/bash
yarn:x:1007:507::/home/yarn:/bin/bash
hdfs:x:1008:507::/home/hdfs:/bin/bash
mapred:x:1009:507::/home/mapred:/bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式说明:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`用户名`:`密码`:`UID`:`GID`:`用户说明信息`:`默认登录路径`:`Shell`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;补充说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;密码&lt;/code&gt;列，是历史遗留问题，现在所有的&lt;code&gt;密码&lt;/code&gt;，都已被单独的提出并存储至&lt;code&gt;/etc/passwd&lt;/code&gt;文件中；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;UID&lt;/code&gt;=0，表示系统管理员；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;GID&lt;/code&gt;，与文件&lt;code&gt;/etc/group&lt;/code&gt;有关，这个文件用于规范组名和GID的对应关系；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Shell&lt;/code&gt;，用户登录之后，就会获得一个Shell进程来与系统核心进行沟通，以进行用户的操作任务；&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;etcshadow&quot;&gt;/etc/shadow&lt;/h4&gt;

&lt;p&gt;文件片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root:$6$t...(实际密码较长):15996:0:99999:7:::
bin:*:15422:0:99999:7:::
sshd:!!:15977::::::
dev:!!:15989:0:99999:7:::
devp:$6$...(实际密码较长):15989:0:99999:7:::
mysql:!!:15990::::::
storm:$6$2...(实际密码较长):15991:0:99999:7:::
strom:!!:15991:0:99999:7:::
ambari-qa:!!:16262:0:99999:7:::
hbase:!!:16262:0:99999:7:::
nagios:!!:16262:0:99999:7:::
oozie:!!:16262:0:99999:7:::
hcat:!!:16262:0:99999:7:::
hive:!!:16262:0:99999:7:::
yarn:!!:16262:0:99999:7:::
hdfs:!!:16262:0:99999:7:::
mapred:!!:16262:0:99999:7:::
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式说明(&lt;code&gt;:&lt;/code&gt;分隔各个列)：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;用户名&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;密码&lt;/code&gt;：是加密后的结果，但仍有可能被破解；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;最近改动密码日期&lt;/code&gt;：单位：天，从1970.01.01算起的天数；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;密码不可被改动的天数&lt;/code&gt;：多少天内不能修改；如果为0，表示随时可以更改；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;密码需要重新改动的天数&lt;/code&gt;：多少天内需要修改再次密码；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;需要变更前的警告天数&lt;/code&gt;：在&lt;code&gt;密码需要重新改动的天数&lt;/code&gt;到来之前，提前显示警告信息；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;密码过期后帐号宽限期&lt;/code&gt;：在&lt;code&gt;密码需要重新改动的天数&lt;/code&gt;到来之前，都没有修改密码，那么还有机会，在宽限期内，用户登录，系统会强制用户必须重新设定密码；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;帐号失效日期&lt;/code&gt;：单位：天，从1970.01.01算起的天数；过了这一天，帐号当即失效；&lt;/li&gt;
  &lt;li&gt;（保留）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;补充说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;密码&lt;/code&gt;列，是加密后的结果，但仍有可能被破解；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;最近改动密码日期&lt;/code&gt;列，单位：天，从1970.01.01算起的天数；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;密码不可被改动的天数&lt;/code&gt;列，从&lt;code&gt;最近改动密码日期&lt;/code&gt;向后推迟的天数，如果为0，表示随时可以更改；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;密码需要重新改动的天数&lt;/code&gt;列，强制用户在多少天内必须修改密码；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;chage -l [LOGIN]&lt;/code&gt;命令，可用于查询用户密码相关的详细信息；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;小提示：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有趣的功能：用户第一次登录后，强制其修改密码后才能使用系统资源.
具体命令：&lt;code&gt;chage -d 0 [LOGIN]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;etcgroup&quot;&gt;/etc/group&lt;/h4&gt;

&lt;p&gt;文件片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hadoop:x:507:hbase,hdfs,mapred
nagios:x:508:
mailnull:x:47:
smmsp:x:51:
hdfs:x:481:devp
hbase:x:480:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`组名`:`群组密码`:`GID`:`组内成员`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;补充说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在上面文件片段中，如果想将用户nagios，添加到hdfs组中，则，只需在hdfs的&lt;code&gt;组内成员&lt;/code&gt;列中添加&lt;code&gt;,nagios&lt;/code&gt;即可；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;id&lt;/code&gt;命令，可查询用户组的详细信息；（类似&lt;code&gt;groups&lt;/code&gt;命令）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;疑问：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有的账户，在&lt;code&gt;/etc/passwd&lt;/code&gt;中，看出其&lt;code&gt;GID&lt;/code&gt;项为507，而在&lt;code&gt;/etc/group&lt;/code&gt;中&lt;code&gt;GID&lt;/code&gt;=507的组内成员中，并没有看到这些账户？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个涉及到&lt;code&gt;有效组（effective group）&lt;/code&gt;和&lt;code&gt;初始组（initial group）&lt;/code&gt;的概念，请往下继续看。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;有效组（effective group） vs. 初始组（initial group）&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;文件&lt;code&gt;/etc/passwd&lt;/code&gt;中，每个用户对应有且只有一个&lt;code&gt;GID&lt;/code&gt;，这是&lt;code&gt;初始组&lt;/code&gt;，即用户一登入系统，立即拥有这个群组的权限；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;初始组&lt;/code&gt;，不需要在&lt;code&gt;/etc/group&lt;/code&gt;文件的&lt;code&gt;组内成员&lt;/code&gt;中写入该用户（也可以写入）；&lt;/li&gt;
  &lt;li&gt;若用户还属于&lt;code&gt;非初始组&lt;/code&gt;，则，在&lt;code&gt;/etc/group&lt;/code&gt;文件的&lt;code&gt;组内成员&lt;/code&gt;部分进行标识；&lt;/li&gt;
  &lt;li&gt;用户新建一个文件，这个文件属于&lt;code&gt;有效组&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;groups&lt;/code&gt;命令，查询出的组中，第一个组为&lt;code&gt;有效组&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;用户登录之后，&lt;code&gt;newgrp [GROUP]&lt;/code&gt;命令，可以切换有效组；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;额外，需要说明一下&lt;code&gt;newgrp [GROUP]&lt;/code&gt;，其实质上是有启动了一个shell，来实现切换&lt;code&gt;有效组&lt;/code&gt;的，具体如下：&lt;/p&gt;

&lt;p&gt;如何将用户添加到组中呢？两种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;root用户，使用命令：&lt;code&gt;usermod&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;组管理员，使用命令：&lt;code&gt;gpasswd&lt;/code&gt;；（下文会介绍）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有个问题，记录一下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;疑问：命令&lt;code&gt;newgrp&lt;/code&gt;会重新启动一个shell，shell是kernel之外的一层壳，shell与进程、线程之间什么关系？shell是如何调用内核？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（之前APUE课程上，有个课下作业：写一个自己的shell，类似bash）&lt;/p&gt;

&lt;h4 id=&quot;etcgshadow&quot;&gt;/etc/gshadow&lt;/h4&gt;

&lt;p&gt;文件片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hadoop:!::hbase,hdfs,mapred
nagios:!::
mailnull:!::
smmsp:!::
hdfs:!::
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`组名`:`组密码`:`组管理员帐号`:`组内成员`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;补充说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;组密码&lt;/code&gt;为&lt;code&gt;!&lt;/code&gt;，表示无合法密码，无组管理员；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;组内成员&lt;/code&gt;，与&lt;code&gt;/etc/group&lt;/code&gt;文件中内容相同；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体添加组内成员、设置组的管理员，使用命令：&lt;code&gt;gpasswd&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;特别提示&lt;/h4&gt;

&lt;p&gt;使用&lt;code&gt;useradd&lt;/code&gt;、&lt;code&gt;passwd&lt;/code&gt;等命令添加用户，并为用户设置用户组之后，如果想修改用户的信息，两条途径：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;直接修改&lt;code&gt;/etc/passwd&lt;/code&gt;和&lt;code&gt;/etc/shadow&lt;/code&gt;文件中相应字段；&lt;/li&gt;
  &lt;li&gt;使用&lt;code&gt;usermod&lt;/code&gt;命令进行修改；&lt;strong&gt;[推荐]&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-5&quot;&gt;深入原理&lt;/h2&gt;

&lt;h3 id=&quot;section-6&quot;&gt;为什么存在用户和用户组&lt;/h3&gt;

&lt;p&gt;主机放在这，谁都想用，如果所有人（UserA\UserB\UserC）都使用同一个帐号登录，则，大家都没有隐私可言，而且UserA的文件可能会被UserB给删除；这就要求创建多个帐号（用户），UserA\UserB\UserC每人使用一个不同的帐号来登陆，这样大家的文件就相互隔离了；问题又来了，UserA想与UserB共享文件FileA，但是不想与UserC共享这一文件怎么办？这就产生了&lt;code&gt;用户组&lt;/code&gt;这一概念，只需要UserA\UserB同属某个用户组GroupA，然后设置组GroupA内的人都有权操作FileA就可以了。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;具体实现原理&lt;/h3&gt;

&lt;p&gt;用户登录时，输入&lt;code&gt;用户名&lt;/code&gt;和&lt;code&gt;密码&lt;/code&gt;，实际上，Linux主机是按照 &lt;code&gt;UID&lt;/code&gt;（User ID） 来识别用户的，&lt;code&gt;用户名&lt;/code&gt;是为便于人们记忆才存在的。
同理，Linux主机只识别&lt;code&gt;GID&lt;/code&gt;（Group ID）来标识&lt;code&gt;用户组&lt;/code&gt;。具体，使用&lt;code&gt;ls -l&lt;/code&gt;命令查询文件详情时，系统会按照&lt;code&gt;GID&lt;/code&gt;和&lt;code&gt;UID&lt;/code&gt;分别去文件&lt;code&gt;/etc/group&lt;/code&gt;和&lt;code&gt;/etc/passwd&lt;/code&gt;中查询相应的&lt;code&gt;用户组&lt;/code&gt;和&lt;code&gt;用户&lt;/code&gt;的名字并显示出来。&lt;/p&gt;

&lt;p&gt;上面一段话，总结：系统上文件属性、权限等存储的都是&lt;code&gt;UID&lt;/code&gt;和&lt;code&gt;GID&lt;/code&gt;，只有在登录、显示时，才会用到&lt;code&gt;用户名&lt;/code&gt;和&lt;code&gt;用户组名&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;《鸟哥私房菜基础篇（第三版）》 第6章 Linux的档案权限与目录配置&lt;/li&gt;
  &lt;li&gt;《鸟哥私房菜基础篇（第三版）》 第14章 Linux帐号管理与ACL权限设定&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
 
</feed>
