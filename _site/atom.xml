<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>NingG.github.com</title>
   <link href="http://ningg.github.com/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://ningg.github.com" rel="alternate" type="text/html" />
   <updated>2014-09-04T07:55:12+08:00</updated>
   <id>http://ningg.github.com</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>PHP入门知识</title>
     <link href="http://ningg.github.com/php-intro"/>
     <updated>2014-08-31T00:00:00+08:00</updated>
     <id>http://ningg.github.com/php-intro</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近要快速搭建一个网站，用途：实现团队内容的对外展现，第一反应就是用wordpress框架实现，号称5分钟建站，够快了。问题来了：网站要实现一些特定的效果，这个就需要定制一下了，wordpress后端是PHP写的处理逻辑，OK，熟悉一下PHP。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;学习路线&lt;/h2&gt;

&lt;p&gt;自己之前接触过1个多月的PHP，当时的内容就是搭建web站点；针对一门不熟悉的语言，只需要掌握其基本知识即可开始工作，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义变量；&lt;/li&gt;
  &lt;li&gt;不同数据结构对应的变量；（链表、集合）&lt;/li&gt;
  &lt;li&gt;多个文件之间的组织结构；&lt;/li&gt;
  &lt;li&gt;调试程序；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;变量&lt;/h2&gt;

&lt;p&gt;变量，就是存储数据的容器，对变量进行操作就是处理数据；&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;定义变量&lt;/h3&gt;

&lt;p&gt;变量名，几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量名必须以&lt;code&gt;$&lt;/code&gt;开头；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;$&lt;/code&gt;之后，第一个字符必须为字母、下划线&lt;code&gt;_&lt;/code&gt;，不能为数字；&lt;/li&gt;
  &lt;li&gt;变量名剩余部分，可以包含任意字母、数字、下划线；&lt;/li&gt;
  &lt;li&gt;变量名，区分大小写；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于变量名，建议：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量名，全部小写字母；&lt;/li&gt;
  &lt;li&gt;变量名，表示其含义，举例：&lt;code&gt;$first_name&lt;/code&gt;好于&lt;code&gt;$fn&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;注释变量用途，例：$first_name = ‘Guo’; //the first name&lt;/li&gt;
  &lt;li&gt;保持一致命名模式，如果要大写，就全部大写；举例：预定义变量&lt;code&gt;$_SERVER&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;变量定义，几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PHP是脚本语言，不要求必须先定义变量或者初始化变量；但为了规范开发、减少出错，建议先定义变量后使用；&lt;/li&gt;
  &lt;li&gt;在定义时，对变量用途进行注释；&lt;/li&gt;
  &lt;li&gt;变量命名风格，有两种：驼峰式（&lt;code&gt;$FirstName&lt;/code&gt;）和下划线式（&lt;code&gt;$first_name&lt;/code&gt;），建议下划线式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;变量类型&lt;/h3&gt;

&lt;p&gt;这一部分，将介绍3种变量类型：数值型、字符串型和数组；&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数值
    &lt;ol&gt;
      &lt;li&gt;整数：1、-1；&lt;/li&gt;
      &lt;li&gt;浮点数：1.0、2.2；&lt;/li&gt;
      &lt;li&gt;注：&lt;code&gt;1/3&lt;/code&gt;包含&lt;code&gt;/&lt;/code&gt;是错误表示；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;字符串
    &lt;ol&gt;
      &lt;li&gt;单引号&lt;code&gt;&#39;&lt;/code&gt;、双引号&lt;code&gt;“&lt;/code&gt;包含起来的任意符号；&lt;/li&gt;
      &lt;li&gt;可以包含变量，例：&lt;code&gt;&#39;$field_name&#39;&lt;/code&gt;；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;数组
    &lt;ol&gt;
      &lt;li&gt;基本单元：key-value；&lt;/li&gt;
      &lt;li&gt;key不同，数组分为两类：索引数组（key为数值）、关联数组（key为字符串）；&lt;/li&gt;
      &lt;li&gt;数组的key，又称索引；&lt;/li&gt;
      &lt;li&gt;如果数组的value也是数组，则，为多维数组；&lt;/li&gt;
      &lt;li&gt;PHP中关联数组，在Perl和Ruby中称为散列；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;索引数组如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;key&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;value&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Don&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Jane&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Roger&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;关联数组如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;key&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;value&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;D&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Don&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;J&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Jane&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Roger&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-5&quot;&gt;变量赋值&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;普通变量（数值、字符串）
    &lt;ol&gt;
      &lt;li&gt;等号赋值，例： $number = 1;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;数组
    &lt;ol&gt;
      &lt;li&gt;使用array()函数，例：$list = array();&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;使用变量&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;直接输出变量
    &lt;ul&gt;
      &lt;li&gt;echo $number;&lt;/li&gt;
      &lt;li&gt;print $number;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;上下文中输出变量
    &lt;ul&gt;
      &lt;li&gt;echo “number is $number”;&lt;/li&gt;
      &lt;li&gt;注：上述不能使用单引号&lt;code&gt;‘&lt;/code&gt;，下文会提到；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数组
    &lt;ul&gt;
      &lt;li&gt;print_r “$_SERVER”;&lt;/li&gt;
      &lt;li&gt;注：print “$_SERVER”; 结果是：&lt;code&gt;Array&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;数组是非标量类型，还有其他输出方式；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;特别说明&lt;/strong&gt;：打印出变量内容，是调试脚本的重要方法。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;引号说明&lt;/h3&gt;

&lt;p&gt;这个比较重要，单拎出来说一下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;单引号&lt;code&gt;‘&lt;/code&gt;内容，原样输出；双引号&lt;code&gt;”&lt;/code&gt;内容，进行变量带入；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;针对引号，几点注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;坚持使用双引号&lt;code&gt;&quot;&lt;/code&gt;即可解决大部分问题；&lt;/li&gt;
  &lt;li&gt;当输出&lt;code&gt;\n&lt;/code&gt;、&lt;code&gt;\t&lt;/code&gt;时，需要使用双引号&lt;code&gt;&quot;&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;建议输出所有变量时，都使用双引号&lt;code&gt;&quot;&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;预定义变量&lt;/h3&gt;

&lt;p&gt;PHP中已经预先定义了一些变量，这些变量功能强大，需要熟记。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$_POST，数组，捕获POST方式表单数据；
    &lt;ol&gt;
      &lt;li&gt;使用键访问数组元素：print $_POST[‘name_value’];&lt;/li&gt;
      &lt;li&gt;严格区分大小写，并且以&lt;code&gt;$_&lt;/code&gt;开头，全部大写；&lt;/li&gt;
      &lt;li&gt;双引号内部，不能使用数组的单引号来引用key；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对上面 3. 中提到的情况，说明如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 下面输出会出错
print &quot;Thank U : $_POST[&#39;name&#39;]&quot;;

// 可选解决办法（先取出，后使用）
$input_name_value = $_POST[&#39;name&#39;];
print &quot;Thank U : $input_name_value&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;疑问：能使用双引号，即 $_POST[“name”] 样式，来获取数组中内容吗？当然可以，单引号能做，双引号也能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$_GET，捕获GET方式表单数据，与$_POST类似；&lt;/li&gt;
  &lt;li&gt;$_REQUEST，捕获任意方式提交的数据；(不推荐)&lt;/li&gt;
  &lt;li&gt;$_COOKIE，设置和查询当前cookie中信息；&lt;/li&gt;
  &lt;li&gt;$_SERVER，服务器和执行环境信息；
    &lt;ol&gt;
      &lt;li&gt;‘PHP_SELF’：当前执行脚本的文件名，与document root有关，例如：&lt;code&gt;/test.php/foo.bar&lt;/code&gt;，具体看PHP手册；&lt;/li&gt;
      &lt;li&gt;‘REQUEST_METHOD’：访问页面的请求方法，例如：GET、POST、PUT；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-9&quot;&gt;数组&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;操作数组&lt;/strong&gt;：array()函数创建数组：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$list = array (&#39;appales&#39;, &#39;bananas&#39;, &#39;oranges&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认，数组的索引从0开始；当然有办法从1开始，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$list = array(
	1 =&amp;gt; &#39;apples&#39;,
	2 =&amp;gt; &#39;bananas&#39;,
	3 =&amp;gt; &#39;oranges&#39;
);

//key值也可以为字符串
$list = array(
	&#39;Mon&#39; =&amp;gt; &#39;apples&#39;,
	&#39;Tue&#39; =&amp;gt; &#39;bananas&#39;,
	&#39;Wed&#39; =&amp;gt; &#39;oranges&#39;
);

//range () 函数创建数组
$evens = range (0, 100, 2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于数组的常用操作，小结如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建数组
    &lt;ol&gt;
      &lt;li&gt;$list = array ();&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;输出数组
    &lt;ol&gt;
      &lt;li&gt;print_r()函数&lt;/li&gt;
      &lt;li&gt;var_dump()函数&lt;/li&gt;
      &lt;li&gt;foreach()&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;引用元素
    &lt;ol&gt;
      &lt;li&gt;只能通过key的引用来获取；&lt;/li&gt;
      &lt;li&gt;key区分大小写；&lt;/li&gt;
      &lt;li&gt;key是字符串的，通过$list[1]无法访问任何元素；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;追加元素
    &lt;ol&gt;
      &lt;li&gt;数值索引时：	$list[] = ‘pears’;&lt;/li&gt;
      &lt;li&gt;字符串索引：必须指定key；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;修改元素
    &lt;ol&gt;
      &lt;li&gt;数值索引：$list[2] = ‘pears’;&lt;/li&gt;
      &lt;li&gt;字符串索引：$list[‘Wed’] = ‘pears’;&lt;/li&gt;
      &lt;li&gt;字符串索引时，不能使用数值；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;元素个数
    &lt;ol&gt;
      &lt;li&gt;$how_many = count($array);&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;删除元素
    &lt;ol&gt;
      &lt;li&gt;unset($list[1]);&lt;/li&gt;
      &lt;li&gt;unset($list[‘Wed’]);&lt;/li&gt;
      &lt;li&gt;unset($list);//删除整个数组&lt;/li&gt;
      &lt;li&gt;$list = array();//等价于删除数组&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;合并数组
    &lt;ol&gt;
      &lt;li&gt;array_merge($list1， $list2);&lt;/li&gt;
      &lt;li&gt;$list = $list1 + $list2;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;数组排序：会单独列张表
    &lt;ol&gt;
      &lt;li&gt;sort($array)、rsort()；&lt;/li&gt;
      &lt;li&gt;asort()、arsort();&lt;/li&gt;
      &lt;li&gt;ksort()、krsort();&lt;/li&gt;
      &lt;li&gt;shuffle()：数组元素顺序随机重组；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;字符串与数组间相互转换
    &lt;ol&gt;
      &lt;li&gt;implode()：数组转换为字符串；&lt;/li&gt;
      &lt;li&gt;explode()：字符串转换为数组；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;判断是否为数组
    &lt;ol&gt;
      &lt;li&gt;is_array($array);&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;额外几个函数
    &lt;ol&gt;
      &lt;li&gt;array_key_exists()&lt;/li&gt;
      &lt;li&gt;array_search()&lt;/li&gt;
      &lt;li&gt;in_array()&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数组使用过程总结如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 $list 不存在，$list[] = ‘value’，会去创建数组；&lt;/li&gt;
  &lt;li&gt;数组中使用单引号 &lt;code&gt;&#39;&lt;/code&gt; 来引用 key 和 value，也可以使用双引号&lt;code&gt;&quot;&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;sizeof() 函数是 count() 的别名，返回数组的元素个数；&lt;/li&gt;
  &lt;li&gt;当key为数值、变量、常数时，不用引号引用，即可调用；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特别要说的是foreach遍历数组，举例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//同时，使用key 和value
foreach($array as $key =&amp;gt; $value) {
	print &quot;&amp;lt;p&amp;gt;Key is $key. Value is $value. &amp;lt;/p&amp;gt;&quot;;
}

//只使用value
foreach($array as $value){
	print &quot;&amp;lt;p&amp;gt;Value is $value.&amp;lt;/p&amp;gt;&quot;;
}

//对于数值索引数组
for($n = 0; $n &amp;lt; count($array); $n++){
	print &quot;&amp;lt;p&amp;gt;Value is $array[$n].&amp;lt;/p&amp;gt;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;备注：上述&lt;code&gt;$key =&amp;gt; $value&lt;/code&gt;，可以替换为&lt;code&gt;$k =&amp;gt; $v&lt;/code&gt;等类似形式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多维数组&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$fruits = array (
	1 =&amp;gt; &#39;apples&#39;,
	2 =&amp;gt; &#39;bananas&#39;,
	3 =&amp;gt; &#39;oranges&#39;
);

$meats =array (
	&#39;fruits&#39; =&amp;gt; $fruits,
	&#39;other&#39; =&amp;gt; &#39;peanuts&#39;,
	&#39;cash&#39; =&amp;gt; 30.00
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数组排序，常用函数如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数&lt;/th&gt;
      &lt;th&gt;排序依据&lt;/th&gt;
      &lt;th&gt;是否保持key-value对应关系&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;sort()&lt;/td&gt;
      &lt;td&gt;Values&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rsort()&lt;/td&gt;
      &lt;td&gt;Values&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;asort()&lt;/td&gt;
      &lt;td&gt;Values&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;arsort()&lt;/td&gt;
      &lt;td&gt;Values&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ksort()&lt;/td&gt;
      &lt;td&gt;Keys&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;krsort()&lt;/td&gt;
      &lt;td&gt;Keys&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;natsort()&lt;/td&gt;
      &lt;td&gt;Keys，自然顺序&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;natcasesort()&lt;/td&gt;
      &lt;td&gt;Keys&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;字符串与数组之间转换，通常如下原因：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数组-&amp;gt;字符串，为了在URL中传输数组；&lt;/li&gt;
  &lt;li&gt;数组-&amp;gt;字符串，方便将数组存储到数据库；&lt;/li&gt;
  &lt;li&gt;字符串-&amp;gt;数组，逗号分割的文本，转化为相互独立形式；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数组与字符串间转换实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 将array以&#39;,&#39;为分割，转换为字符串
$string = implode(&#39;,&#39;, $array);

//将string以&#39;,&#39;为分割，转换为数组
$array = explode(&#39;,&#39;, $string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将数组中元素分别指定给不同变量，使用 list() 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$date = array(&#39;Thursday&#39;, 23, &#39;October&#39;);
//为3个变量赋值
list($weekday, $day, $month) = $date;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实践：查看PHP手册中的几个函数，array_key_exists()、array_search()、in_array()。&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;常量&lt;/h2&gt;

&lt;p&gt;与变量不同，常量在脚本的执行过程中，一直保持初始值；常量一旦设定就不能更改。&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;定义常量&lt;/h3&gt;

&lt;p&gt;使用define()函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(&#39;CONSTANT_NAME&#39;, value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;常量名，以字母、下划线开头，全部大写；&lt;/li&gt;
  &lt;li&gt;常量名，不需要以&lt;code&gt;$&lt;/code&gt;开头；&lt;/li&gt;
  &lt;li&gt;定义常量，define()中常量名，使用引号；&lt;/li&gt;
  &lt;li&gt;输出常量，直接使用常量名即可；&lt;/li&gt;
  &lt;li&gt;引号内部（单引号、双引号）无法输出常量；&lt;/li&gt;
  &lt;li&gt;判断是否定义常量：defined(‘CONSTANT_NAME’)；&lt;/li&gt;
  &lt;li&gt;常量是全局作用域的；&lt;/li&gt;
  &lt;li&gt;常量的值不能修改，常量本身也不能修改；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-12&quot;&gt;预定义常量&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;PHP_VERSION：正在运行的PHP版本&lt;/li&gt;
  &lt;li&gt;PHP_OS：服务器操作系统&lt;/li&gt;
  &lt;li&gt;SID：session ID&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-13&quot;&gt;运算符&lt;/h2&gt;

&lt;p&gt;PHP中运算符，参考下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;运算符&lt;/th&gt;
      &lt;th&gt;用法&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;加&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;减&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;乘&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;/&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;除&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;取模&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;++&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;自增&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;自减&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;赋值&lt;/td&gt;
      &lt;td&gt;赋值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;==&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;相等&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;不等&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;小于&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;大于&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;小于等于&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;大于等于&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;!&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;非&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;AND&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;与&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;与&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;OR&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;或&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;||&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;或&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;XOR&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;异或&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;.&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;连接&lt;/td&gt;
      &lt;td&gt;字符串&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-14&quot;&gt;函数&lt;/h2&gt;

&lt;p&gt;特别说明：PHP中函数名与&lt;code&gt;()&lt;/code&gt;之间可以有空格，即，如下两种方式都正确：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;round(100.2);
round (100.2);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-15&quot;&gt;数值格式化&lt;/h3&gt;

&lt;p&gt;round()，进行数值四舍五入，具体参阅[PHP Manual]，举例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
	round(3.4);			//3
	round(4.12, 1);		//4.1
	round(1221, -2);	//1200
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似函数还有：number_format()、printf()、sprintf()；&lt;/p&gt;

&lt;h3 id=&quot;section-16&quot;&gt;随机数&lt;/h3&gt;

&lt;p&gt;rand()、mt_rand()，具体不多说，查看操作手册即可；&lt;/p&gt;

&lt;h3 id=&quot;section-17&quot;&gt;字符串连接&lt;/h3&gt;

&lt;p&gt;字符串连接：句点&lt;code&gt;.&lt;/code&gt;，举例：$result = $first_name . $last_name;&lt;/p&gt;

&lt;h3 id=&quot;html&quot;&gt;转换HTML格式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;nl2br($string);		//将$string内的\n转换为&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;htmlsprcialchars();	//将特定的HTML标签转换为实体版本&lt;/li&gt;
  &lt;li&gt;htmlentities();		//将所有的HTML标签转换为实体版本&lt;/li&gt;
  &lt;li&gt;strip_tags();		//移除所有HTML和PHP标签&lt;/li&gt;
  &lt;li&gt;html_entity_decode();	//将HTML实体转换为相应HTML代码&lt;/li&gt;
  &lt;li&gt;wordwrap();			//按照指定长度，换行处理字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几个问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTML实体是什么？例如：&lt;code&gt;&amp;lt;&lt;/code&gt; 对应HTML实体为 &lt;code&gt;&amp;amp;lt;&lt;/code&gt; ；使用HTML实体主要原因：防止输入文本中包含HTML标签，打乱整个页面的布局，更近一步，防止用户提交JS进行跨站点攻击（XSS，Cross-Site Scripting）。补充：XSS 能够做的事情：破环网站风格、功能；盗取浏览用户的session信息。&lt;/li&gt;
  &lt;li&gt;通常先移除所有HTML、PHP标签，再将&lt;code&gt;\n&lt;/code&gt;等转义符，转换为HTML换行符，即：strip_tags()之后nl2br();&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-18&quot;&gt;字符串编/解码&lt;/h3&gt;

&lt;p&gt;背景：通过URL的query向服务器发送参数时，要求参数不能包含空格、特殊字符等；如果一定要使用URL的query向服务器传送数据，可以先对数据进行编码，即可解决此问题。&lt;/p&gt;

&lt;p&gt;urlencode()，专门解决这一问题，将字符串转换为适合最为URL的一部分来传输。几点说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;表单发送出去的数据，会自动进行URL编码，在服务器端，会自动解码，因此，本例中，只需要在页面上通过urlencode()编码即可，服务器能够自动解码；&lt;/li&gt;
  &lt;li&gt;urldecode()，能够进行解码，但不常用，因为服务器能够自动解码；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-19&quot;&gt;子字符串&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;strtok($string, $token)，按照$token来分割$string，并返回最新的子串；&lt;/li&gt;
  &lt;li&gt;substring($string, 0, 10)，从$string中索引为0的字符开始（包含在内），累计截取10个字符；&lt;/li&gt;
  &lt;li&gt;substring($string, -3, 3)，从$string中倒数第3个字符开始（包含在内），累计截取3个字符；&lt;/li&gt;
  &lt;li&gt;strlen($string)，字符串中字符个数；&lt;/li&gt;
  &lt;li&gt;str_word_count()，字符串中单词个数；&lt;/li&gt;
  &lt;li&gt;str_ireplace($needle, $replacement, $haystack)，将$haystack中$needle替换为$replacement；&lt;/li&gt;
  &lt;li&gt;str_replace()，区分大小写，其余与str_ireplace()类似；&lt;/li&gt;
  &lt;li&gt;trim()，删除字符串首尾的空格、换行符、制表符；&lt;/li&gt;
  &lt;li&gt;rtrim()，删除最右端的空白字符；&lt;/li&gt;
  &lt;li&gt;ltrim()，删除最左端的空白字符；&lt;/li&gt;
  &lt;li&gt;strtoupper()，字符串转换为大写；&lt;/li&gt;
  &lt;li&gt;strtolower()，字符串转换为小写；&lt;/li&gt;
  &lt;li&gt;substr_count($string, $substr)，子字符串出现的次数；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PHP中所有索引的位置都是从0开始的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$evens = range (0, 100, 2); 创建等差数列；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-20&quot;&gt;日期和时间&lt;/h3&gt;

&lt;p&gt;说几个函数，有点印象就行，具体用法去查PHP手册：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;date() 返回某一日期格式；&lt;/li&gt;
  &lt;li&gt;date() 中第二参数为时间戳（timestamp），是表示从1970年1月1日算起的秒数；&lt;/li&gt;
  &lt;li&gt;time() 返回当前时间戳；&lt;/li&gt;
  &lt;li&gt;mktime() 返回一个给定日期和时间对应的时间戳；&lt;/li&gt;
  &lt;li&gt;date_default_timezone_set() 设置时间默认的时区；&lt;/li&gt;
  &lt;li&gt;date_default_timezone_get() 获取当前时间对应的时区；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;额外说明几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PHP是服务器端的技术，函数反映的是服务器上的时间，如果要获取客户端的时间，需要使用JavaScript；&lt;/li&gt;
  &lt;li&gt;PHP 5.3中，加入一个创建、操作日期和时间的类：DateTime类；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-21&quot;&gt;创建函数&lt;/h3&gt;

&lt;p&gt;一个典型函数的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//设置参数默认值
function function_name($arg1 = &#39;world&#39;, $arg2){
	statements;
	//函数的返回值（返回多个值：数组）
	return $name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;函数名，不区分大小写；&lt;/li&gt;
  &lt;li&gt;函数function_exists(function_name)，用于判断一个函数是否存在；&lt;/li&gt;
  &lt;li&gt;PHP中不要求：函数在调用之前就定义好，但，推荐在脚本开头就定义好函数；（放在引入文件中）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-22&quot;&gt;变量作用域&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;通常，变量作用域：整个脚本的声明周期中；&lt;/li&gt;
  &lt;li&gt;函数中传参数时，传递变量值，而不传递变量本身；&lt;/li&gt;
  &lt;li&gt;函数内部定义的变量，为局部变量；&lt;/li&gt;
  &lt;li&gt;global可以将函数内局部变量设置为全局变量；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-23&quot;&gt;控制结构&lt;/h2&gt;

&lt;p&gt;几点注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;{&lt;/code&gt;、&lt;code&gt;}&lt;/code&gt;的前后，不能出现&lt;code&gt;;&lt;/code&gt;，否则报错；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几个验证函数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;empty()，除去变量未定义、值为0、空字符串外，返回FALSE;&lt;/li&gt;
  &lt;li&gt;isset()，仅当变量未定义时，返回False；（能够接受任意个数的变量）&lt;/li&gt;
  &lt;li&gt;is_numeric()，仅当变量为数值时，返回TRUE;&lt;/li&gt;
  &lt;li&gt;checkdate()，验证日期是否存在；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$var1 = 0;
$var2 = &quot;&quot;;
$var3 = &quot;HELLO!&quot;

empty($var);	//TRUE，没有定义的变量
empty($var1);	//TRUE，空值
empty($var2);	//TRUE，空值
empty($var3);	//FALSE，非空（这个是这样吗？）

isset($var);	//FALSE，变量未定义
isset($var1);	//TRUE
isset($var2);	//TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;if&quot;&gt;if条件语句&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if (condition1) {
	statement(s);
} elseif (condition2) {
	statement(s);
} else {
	statements(s);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;switch&quot;&gt;switch条件语句&lt;/h3&gt;

&lt;p&gt;switch($var)，变量$var，可以为字符串、数值，在case后的value，如果是数值，则不需要加引号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;switch ($var) {
	case value1:
		statements1;
		break;
	case value2:
		statements2;
		break;
	default:
		statements3;
		break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-24&quot;&gt;循环语句&lt;/h3&gt;

&lt;p&gt;主要是for、while，以及foreach，不多说，给个示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(condition) {
	statement(s);
}

do {
	statement(s);
} while (condition);

for (init_exp; condition ; closing_exp){
	statement(s);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-25&quot;&gt;调试程序&lt;/h2&gt;

&lt;p&gt;调试程序有2种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;输出变量和错误信息；&lt;/li&gt;
  &lt;li&gt;用IDE，打断点，debug；&lt;/li&gt;
  &lt;li&gt;查看程序运行日志，特别是出错日志；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-26&quot;&gt;输出变量&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;echo “$var”;&lt;/li&gt;
  &lt;li&gt;print “$var”;&lt;/li&gt;
  &lt;li&gt;print_r “$_SERVER”;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-27&quot;&gt;输出错误信息&lt;/h3&gt;

&lt;p&gt;安装PHP之后，默认安全配置下，是不允许向Web端输出任何出错信息的，即，display_errors出于关闭状态；为了方便调试，有两种方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开启display_errors设置；&lt;/li&gt;
  &lt;li&gt;为某些脚本单独开启display_errors设置；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当前首选第一个选项，但是只有root用户才有如此权限；普通用户，可以在php页面中添加代码：&lt;code&gt;ini_set(&#39;display_errors&#39;, 1);&lt;/code&gt; 实现为某些脚本开启display_errors。说明：这种方式进行的设置，只在当前php脚本执行期间有效，脚本结束后恢复原始设置；display_errors只能控制是否向浏览器发送错误信息，而不会控制错误的发生。&lt;/p&gt;

&lt;h3 id=&quot;section-28&quot;&gt;输出错误信息级别&lt;/h3&gt;

&lt;p&gt;通过设置display_errors可以实现输出错误信息，但是要输出哪一类的错误信息呢？警告信息要不要输出？&lt;/p&gt;

&lt;p&gt;PHP中错误的类型，见下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;示例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;通知&lt;/td&gt;
      &lt;td&gt;非致命性错误，程序不一定有问题&lt;/td&gt;
      &lt;td&gt;引用一个没有值的变量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;警告&lt;/td&gt;
      &lt;td&gt;非致命错误，程序有问题&lt;/td&gt;
      &lt;td&gt;函数误用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;解析错误&lt;/td&gt;
      &lt;td&gt;致命错误，语法错误&lt;/td&gt;
      &lt;td&gt;缺少分好、引号、圆括号、花括号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;错误&lt;/td&gt;
      &lt;td&gt;致命错误，一般错误&lt;/td&gt;
      &lt;td&gt;内存分配问题&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;错误报告常量（不完整，完整版查看[PHP Manual]），见下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;E_NOTICE&lt;/td&gt;
      &lt;td&gt;通知&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E_WARRING&lt;/td&gt;
      &lt;td&gt;警告&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E_PARSE&lt;/td&gt;
      &lt;td&gt;解析错误&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E_ERROR&lt;/td&gt;
      &lt;td&gt;错误&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E_ALL&lt;/td&gt;
      &lt;td&gt;所有错误（E_STRICT除外）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E_STRICT&lt;/td&gt;
      &lt;td&gt;PHP代码修改建议&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;注：上面的常量，是二进制位掩码，可以使用按位运算符来对其进行组合，例如，php.ini中，&lt;code&gt;|&lt;/code&gt;、&lt;code&gt;~&lt;/code&gt;、&lt;code&gt;&amp;amp;&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;两种方式可以设置错误提示级别：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;全局设置：PHP配置文件php.ini中，调整error_reporting()级别；&lt;/li&gt;
  &lt;li&gt;局部设置：php脚本中，使用error_reporting()函数；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;举例说明如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//不报告任何错误
error_reporting(0);

//报告所有错误
error_reporting(E_ALL);

//报告除通知之外的所有错误
error_reporting(E_ALL &amp;amp; ~E_NOTICE);

//所有错误以及代码修改建议
error_reporting(E_ALL | E_STRICT);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;web&quot;&gt;Web开发基本过程&lt;/h2&gt;

&lt;p&gt;Web开发的基本过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建模版HTML文件；&lt;/li&gt;
  &lt;li&gt;从模版中抽取：页头文件、页脚文件；&lt;/li&gt;
  &lt;li&gt;将页头、页脚文件导入php主文件中；
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;include(&#39;file.php&#39;);&lt;/code&gt; 若include()函数失败，发出警告；&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;require(&#39;file.php&#39;);&lt;/code&gt; 若require()函数失败，终止脚本；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;通常两个php脚本来处理表单：一个显示表单，一个接收和处理表单数据；
    &lt;ol&gt;
      &lt;li&gt;让同一个脚本来完成整个流程更好；&lt;/li&gt;
      &lt;li&gt;检查变量是否设置：&lt;code&gt;isset($_POST[&#39;something&#39;])；&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;检查表单提交的方法：&lt;code&gt;$_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;POST&#39;&lt;/code&gt;;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;表单粘性：若表单提交后出错，则，重新提交表单，希望能够记录初次填写的表单数值；
    &lt;ol&gt;
      &lt;li&gt;&amp;lt;input … value=”&lt;?php print $_POST[&#39;name&#39;]; ?&gt;” /&amp;gt;&lt;/li&gt;
      &lt;li&gt;不要引用不存在的变量；在引用之前，判断是否存在isset()&lt;/li&gt;
      &lt;li&gt;用户提交的内容，直接显示在表单中有样式问题，可以使用htmlspecialchars()；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;发送Email
    &lt;ol&gt;
      &lt;li&gt;服务器上Email应用程序发送Email；&lt;/li&gt;
      &lt;li&gt;具体：调用函数&lt;code&gt;mail(to, subject, body)&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;substr_count($_POST[&#39;eamil&#39;], &#39;@&#39;) == 1&lt;/code&gt;，邮件验证；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;输出缓冲，只能在服务器发出响应之前进行调用：
    &lt;ol&gt;
      &lt;li&gt;header()：&lt;/li&gt;
      &lt;li&gt;setcookie()：&lt;/li&gt;
      &lt;li&gt;session_start()：&lt;/li&gt;
      &lt;li&gt;ob_start()；开启输出缓存，output buffering；&lt;/li&gt;
      &lt;li&gt;ob_end_flush()；输出缓冲数据；&lt;/li&gt;
      &lt;li&gt;ob_end_clean()；删除缓冲数据，不进行传输；&lt;/li&gt;
      &lt;li&gt;php.ini中可设置输出缓冲区的大写；&lt;/li&gt;
      &lt;li&gt;ob_get_length()；当前输出缓冲区的大小；&lt;/li&gt;
      &lt;li&gt;ob_get_contents()；获取缓冲区内容；&lt;/li&gt;
      &lt;li&gt;ob_flush()；输出当前缓冲区内容，以方便继续缓冲新内容；&lt;/li&gt;
      &lt;li&gt;ob_clean()；清空缓冲区内容，但后续仍会继续缓冲；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP头，header()函数
    &lt;ol&gt;
      &lt;li&gt;重定向：header(‘Location: index.php’);&lt;/li&gt;
      &lt;li&gt;重定向，接着使用函数，exit()；&lt;/li&gt;
      &lt;li&gt;开启输出缓存：ob_start()；&lt;/li&gt;
      &lt;li&gt;如果浏览器已经收到HTTP头，则headers_sent()函数返回TRUE；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cookiesession&quot;&gt;cookie和session&lt;/h3&gt;

&lt;p&gt;cookie、session的作用：跟踪用户，记录用户信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么是cookie&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;客户端保存用户信息的一种方式，服务器通过此信息识别用户身份；将从几点来介绍cookie：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;建立cookie；&lt;/li&gt;
  &lt;li&gt;从cookie中检索信息；&lt;/li&gt;
  &lt;li&gt;删除cookie；&lt;/li&gt;
  &lt;li&gt;限制cookie的可选参数；&lt;/li&gt;
  &lt;li&gt;如何调试与cookie相关的问题；&lt;/li&gt;
  &lt;li&gt;如何传输和接收cookie；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;cookie的访问时间和方式：用户输入URL后，浏览器会将cookie信息包含至HTTP请求内发送给服务器。额外几点说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务器端的PHP和浏览器端的JavaScript都能发送、读取、删除cookie，这是两种脚本重叠的功能之一；&lt;/li&gt;
  &lt;li&gt;cookie必须在服务器发送任何信息之前，从服务器发送到客户端；&lt;/li&gt;
  &lt;li&gt;setcookie(name, value)函数，向浏览器发送cookie；&lt;/li&gt;
  &lt;li&gt;发送cookie，应位于整个HTML页面标签之前（&amp;lt;!DOCTYPE html … &amp;gt;）；&lt;/li&gt;
  &lt;li&gt;若使用输出缓存机制（output buffering），则setcookie()可以位于PHP脚本中任意位置；&lt;/li&gt;
  &lt;li&gt;cookie的总数，限制在4KB；&lt;/li&gt;
  &lt;li&gt;headers_sent()函数可用与测试HTTP头部是否发送出去；&lt;/li&gt;
  &lt;li&gt;cookie的值在发送时，将自动编码，接收时会自动解码；对于PHP表单发送的值也是如此；&lt;/li&gt;
  &lt;li&gt;setcookie()函数在不同的浏览器中，有兼容性问题；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;读取cookie&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;预定义的数组$_COOKIE中存储了所有cookie数据，按照key值，从数组$_COOKIE中读取即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;向cookie中添加参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;函数setcookie()，具体用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//expiration：过期时间点，单位秒(s)；默认关闭浏览器之前有效；
//domain：设置一个子域的cookie；
//secure：为1时，表示只能通过https传送；
//httponly：设置防止JS读取cookie，但不是所有浏览器都支持；
setcookie(name, value, expiration, path, domain, secure, httponly);

setcookie(name, value, time() + 3600)；
setcookie(name, value, time() + 3600, &#39;/subfolder/&#39;);
setcookie(name, value, time() + 3600, &#39;&#39;, &#39;forum.example.com&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;几点注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cookie过期时间的选择：
    &lt;ol&gt;
      &lt;li&gt;cookie持续时间如果同用户浏览网站的时间一样长，则，不需要设置过期时间；&lt;/li&gt;
      &lt;li&gt;如果需要cookie在关闭、重启浏览器之后继续存在，可将过期时间设置为数个月；&lt;/li&gt;
      &lt;li&gt;若cookie可能引发安全隐患，则可将过期时间设置为小于1h；&lt;/li&gt;
      &lt;li&gt;出于安全考虑，可以设定cookie过期时间为5min~10min，同时，让用户每访问一个新页面时，重新发送一次cookie；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;删除cookie&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;删除cookie，本质就是设置一个空值，同时可以设置一个过去的过期时间：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//重设值，同时设置过去的过期时间
setcookie(&#39;username&#39;, FALSE, time() - 600);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特别提醒：删除cookie时，一定要使用与设置cookie一致的参数（除去值和过期时间）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setcookie(&#39;user&#39;, &#39;larry&#39;, time() + 3600, &#39;&#39;, &#39;forums.example.com&#39;);
setcookie(&#39;user&#39;, &#39;&#39;, time() - 600, &#39;&#39;, &#39;forums.example.com&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;什么是session&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;session的数据保存在服务器端，cookie数据保存在客户端；由此，session比cookie拥有更多的优势：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;session通常更安全，因为数据不会在客户端、浏览器之间重复传输；&lt;/li&gt;
  &lt;li&gt;session存储比cookie更多的信息；&lt;/li&gt;
  &lt;li&gt;session能够在禁止cookie的浏览器上，继续工作；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几点说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开启一个session时，PHP会自动创建一个随机的session ID；&lt;/li&gt;
  &lt;li&gt;每个用户都拥有一个自己的Session ID，这也是服务器上存储该用户session数据的文件名称；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;cookie相对于session的优势有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cookie相对容易创建和使用；&lt;/li&gt;
  &lt;li&gt;cookie耗费服务端的资源少；&lt;/li&gt;
  &lt;li&gt;如果希望长期保存用户身份信息，则应采用cookie；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结论：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当保存数据较少，同时安全性要求不高时，推荐首选cookie；&lt;/li&gt;
  &lt;li&gt;保存数据较多或者敏感，同时安全性要求较高时，首选session；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;创建session&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;session_start()函数用于创建一个session，并且在session首次启动时发送一个cookie，因此，必须在所有HTML响应发送回浏览器之前，创建session。
第一次开启session时，随机产生一个session ID，并向Web浏览器发送一个名为PHPSESSID（session的名称）的cookie。&lt;/p&gt;

&lt;p&gt;一旦启用session，就可以通过向数组赋值的方式来存储数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$_SESSION[&#39;first_name&#39;] = &#39;Sam&#39;;
$_SESSION[&#39;age&#39;] = 14；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每次向session中添加数据时，PHP将向服务器上一个临时文件中添加一些数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//session数据在服务器文件中的存储方式
email|s:14:&quot;me@example.com&quot;; loggedin|i:1292;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于session几点信息：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;php.ini中可以配置session信息；&lt;/li&gt;
  &lt;li&gt;ini_set()函数可以设置session信息；&lt;/li&gt;
  &lt;li&gt;session_name()函数可以修改session名称（默认名称PHPSESSID），注意：必须在调用session_start()之前使用；&lt;/li&gt;
  &lt;li&gt;session_set_cookie_params()函数，用户修改session cookie的设置（过期时间、路径、域）；&lt;/li&gt;
  &lt;li&gt;常量SID用格式name=ID的方式保存一个字符串；&lt;/li&gt;
  &lt;li&gt;session中可以保存任意类型数据，甚至对象；&lt;/li&gt;
  &lt;li&gt;在session中，数据都会以纯文本的形式保存在一个开放可读的文本文件中；永远不要将真实的敏感信息存在session中，例如信用卡数据；&lt;/li&gt;
  &lt;li&gt;为提高安全性，可以将数据加密后保存到session中，在读取session后再解密（Mcrypt库）；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;删除session&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;服务器端session中包含的数据都保存在$_SESSION数组中，可以对数组重新赋值，以达到删除session的效果，但也需要删除服务器上保存session数据的临时文件，具体操作如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//重置session
$_SESSION = array();
//删除服务器端session临时文件
session_destroy();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数unset($var)，可用于删除一个变量，也能达到删除$_SESSION的效果；同时，如果浏览器禁用cookie，则可以在URL上添加session ID作为附属参数，以继续使用session，注意：需要在php.ini中启用enable_trans_side。&lt;/p&gt;

&lt;h3 id=&quot;section-29&quot;&gt;文件和目录&lt;/h3&gt;

&lt;p&gt;Web应用程序，不可避免两个问题：数据存储、检索数据。当前数据存储的方法主要有两种：文件（和目录）、数据库。这一部分，主要介绍一下文件的写入、读取和锁定。&lt;/p&gt;

&lt;p&gt;疑问：读取、上传的文件，为什么在Web目录之外？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;file_exists(‘somefile.ext’)，判断文件是否存在；&lt;/li&gt;
  &lt;li&gt;is_readable()测试文件是否可读；&lt;/li&gt;
  &lt;li&gt;touch(‘somefile.ext’)，创建空白文件；&lt;/li&gt;
  &lt;li&gt;chgrp()、chown()、chmod()，修改文件、目录权限；&lt;/li&gt;
  &lt;li&gt;file_put_contents($file, $data)，向文件写入数据；
    &lt;ol&gt;
      &lt;li&gt;文件不存在，则，函数主动创建；&lt;/li&gt;
      &lt;li&gt;文件存在，覆盖文件内容；&lt;/li&gt;
      &lt;li&gt;file_put_contents($file, $data, FILE_APPEND)，追加；&lt;/li&gt;
      &lt;li&gt;如果需要追加的内容独占一行，则需要在内容后，添加换行符，PHP专用常量 PHP_EOL 可以解决这一问题，file_put_contents($file, $data . PHP_EOL, FILE_APPEND)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;file_put_contents($file, $data, LOCK_EX);写文件同时锁定文件；
    &lt;ol&gt;
      &lt;li&gt;若同时追加文件、锁定文件，则，&lt;code&gt;LOCK_EX | FILE_APPEND&lt;/code&gt;；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;file_get_contents($file)，一次读取文件所有内容；&lt;/li&gt;
  &lt;li&gt;file($file)，读取文件内容，并且返回一个数组，每个元素为原文件中的一行；&lt;/li&gt;
  &lt;li&gt;更多文件读取方式：fgets()、fgetcsv()；&lt;/li&gt;
  &lt;li&gt;filesize($file)，返回文件大小（单位Byte）；&lt;/li&gt;
  &lt;li&gt;filetime($file)，返回文件修改时间戳，可使用date()格式化；&lt;/li&gt;
  &lt;li&gt;is_writeable()&lt;/li&gt;
  &lt;li&gt;is_readable()&lt;/li&gt;
  &lt;li&gt;is_dir()&lt;/li&gt;
  &lt;li&gt;is_file()&lt;/li&gt;
  &lt;li&gt;glob()，搜索名字与模式匹配的文件（*.jpg）&lt;/li&gt;
  &lt;li&gt;fileperms()，文件权限；&lt;/li&gt;
  &lt;li&gt;fileatime()，文件最后访问时间；&lt;/li&gt;
  &lt;li&gt;fileowner()，拥有该文件的用户名称；&lt;/li&gt;
  &lt;li&gt;basename()、dirname()，返回文件名、路径名；&lt;/li&gt;
  &lt;li&gt;finfo_file()，文件的MIME类型；&lt;/li&gt;
  &lt;li&gt;mkdir(‘dir_name’, permissions)，创建文件；&lt;/li&gt;
  &lt;li&gt;rmdir()，删除现有目录；&lt;/li&gt;
  &lt;li&gt;fgets()，返回指定长度的字符串；&lt;/li&gt;
  &lt;li&gt;feof()，判断是否达到文件末尾；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;补充几点：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;读取文件&lt;/strong&gt;：PHP 4 以及以下版本，不能使用file_put_contents()，需要按照旧方法来写数据：打开文件、写数据、关闭文件；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//文件模式mode，查PHP手册很详细
$file_pointer = fopen($file, mode);
fwrite($file_pointer, $data . PHP_EOL);
fclose($file_pointer);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;上传文件&lt;/strong&gt;：通过表单上传，修改3处：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;form表单添加enctype，即 &amp;lt;form action=… enctype=”multipart/form-data” method=”post” &amp;gt;；必须使用POST方式；&lt;/li&gt;
  &lt;li&gt;添加银行输入框：&lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;30000&quot; /&gt;，用于建议浏览器最大能够上传的文件；&lt;/li&gt;
  &lt;li&gt;使用file元素，创建所需的表单：&lt;input type=&quot;file&quot; name=&quot;pic&quot; /&gt;，file类型允许用户上传一个文件；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PHP脚本中，使用$_FILES变量能够引用上传的文件。$_FILES数组包含5个成员：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;name，用户上传文件的原始名字；&lt;/li&gt;
  &lt;li&gt;type，文件MIME类型，例：image/jpg；&lt;/li&gt;
  &lt;li&gt;size，文件大小（单位Byte）&lt;/li&gt;
  &lt;li&gt;tmp_name，文件存放在服务器上的临时文件名称；&lt;/li&gt;
  &lt;li&gt;error，发生错误时，保存的错误代码；（查看PHP手册）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;文件上传之后，需要将临时文件移动到最终目标位置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//将临时文件移动到最终位置
move_uploaded_file($_FILES[&#39;pic&#39;][&#39;tmp_name&#39;], &#39;/path/filename&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个php脚本可以同时处理多个文件上传，只要name属性不同即可，此时只需要一个隐含输入框设定MAX_FILE_SIZE。另外，针对移动文件的函数小结：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;move_uplodaded_file()，将上传的临时文件移动到最终位置；&lt;/li&gt;
  &lt;li&gt;unlink()，删除文件，不会进行移动或者复制；&lt;/li&gt;
  &lt;li&gt;copy()，复制文件；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上传文件时，有几点注意：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;php.ini中，开启file_uploads配置；&lt;/li&gt;
  &lt;li&gt;php.ini中，设置upload_tmp_dir，如果没有设置，可能会指定一个隐含值；&lt;/li&gt;
  &lt;li&gt;php.ini中，upload_max_filesize和post_max_size用于设定PHP能够处理的文件大小；&lt;/li&gt;
  &lt;li&gt;form中隐含input元素中设定的MAX_FILE_SIZE只是在前端浏览器处，进行的约束；&lt;/li&gt;
  &lt;li&gt;当缺失要上传大文件时，除了上述相关的配置，还应设置两个参数：memory_limit、max_execution_time，来给PHP脚本足够的处理时间和空间；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;目录相关&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;浏览目录：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;scandir($dir)，返回目录下所有内容，一个数组：包含文件和子目录；&lt;/li&gt;
  &lt;li&gt;旧版本的PHP中，需要使用opendir()、readdir()、closedir()；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mysql&quot;&gt;数据库MySQL&lt;/h3&gt;

&lt;p&gt;PHP中操作MySQL数据库，基本过程，连接数据库、操作、释放连接，具体几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$dbc = mysql_connect(hostname, username, passwd)，获取数据库连接&lt;/li&gt;
  &lt;li&gt;mysql_query($query, $dbc)&lt;/li&gt;
  &lt;li&gt;mysql_query(‘create database somedb’, $dbc);&lt;/li&gt;
  &lt;li&gt;mysql_select_db(‘somedb’, $dbc);&lt;/li&gt;
  &lt;li&gt;$result = mysql_query($query, $dbc)， 执行$query&lt;/li&gt;
  &lt;li&gt;mysql_num_rows($result)，返回查询结果的个数，可用于删除、查询之前判断？&lt;/li&gt;
  &lt;li&gt;$row = mysql_fetch_array($result)，每次返回一行数据，形式：数组；&lt;/li&gt;
  &lt;li&gt;mysql_fetch_array($result, MYSQL_ASSOC or MYSQL_NUM)，关联数组、索引数组；&lt;/li&gt;
  &lt;li&gt;while( $row = mysql_fetch_array($result) ){ … }，用于遍历结果；&lt;/li&gt;
  &lt;li&gt;mysql_affected_rows()，返回INSERT、DELETE、UPDATE等影响到的行数；&lt;/li&gt;
  &lt;li&gt;msyql_close($dbc)，释放连接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;PHP中对MySQL的支持&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PHP操作MySQL，根据扩展不同，分为两类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;标准MySQL，支持所有MySQL版本，函数以 &lt;code&gt;mysql_&lt;/code&gt; 作为前缀；&lt;/li&gt;
  &lt;li&gt;扩展MySQL，MySQLi（Improved MySQL Extension），PHP5之后引入的，支持MySQL4.1以上的版本，能够利用MySQL的一些额外特性，函数以 &lt;code&gt;mysqli_&lt;/code&gt; 最为前缀；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;MySQL错误处理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;常见的错误类型有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;连接MySQL失败；&lt;/li&gt;
  &lt;li&gt;选择数据库失败；&lt;/li&gt;
  &lt;li&gt;无法运行查询；&lt;/li&gt;
  &lt;li&gt;查询没有返回结果；&lt;/li&gt;
  &lt;li&gt;数据没有插入到表中；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体说几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mysql_error()，显示发生错误的详细信息；&lt;/li&gt;
  &lt;li&gt;错误控制符&lt;code&gt;@&lt;/code&gt;，在函数名之前使用，阻止显示错误信息，但并不能阻止错误的发生，仅当希望自己处理错误时，才使用&lt;code&gt;@&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;错误控制符&lt;code&gt;@&lt;/code&gt;，可以用于阻止任何函数的错误、通知、警告，而不仅限于MySQL相关函数；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于PHP中使用MySQL，具体说几点：&lt;/p&gt;

&lt;p&gt;为避免SQL注入攻击，可随意用mysql_real_escape_string()函数，来转义危险字符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$var = mysql_real_escape_string($var, $dbc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有文件编码方式需要与HTML中指定的charset一致；&lt;/li&gt;
  &lt;li&gt;如果为UTF-8编码方式，则，必须为UTF-8 without BOM方式；&lt;/li&gt;
  &lt;li&gt;通过include(‘path/file.php’)，路径为相对与最终php脚本的位置；&lt;/li&gt;
  &lt;li&gt;include_once()、require_once()，表示同一个文件只包含一次；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;特别说明&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/download/php-intro/PHP基础教程（第4版）.pdf&quot;&gt;PHP基础教程（第4版）&lt;/a&gt;的附录部分，有很多进一步学习的建议。&lt;/p&gt;

&lt;h2 id=&quot;section-30&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/download/php-intro/PHP基础教程（第4版）.pdf&quot;&gt;PHP基础教程（第4版）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/download/php-intro/php_enhanced_zh.chm&quot;&gt;PHP Manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>Linux下su和sudo进行身份变换</title>
     <link href="http://ningg.github.com/linux-su-sudo"/>
     <updated>2014-08-16T00:00:00+08:00</updated>
     <id>http://ningg.github.com/linux-su-sudo</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近，一些普通用户要在服务器上，安装软件，不时遇到权限问题，因此，只好将root密码献了出去；太多人知道root密码是件很危险的事，特别是，有的人习惯使用root权限登录，这中情况下，很有可能误操作，删除系统文件；有没有其他办法来避免这个问题呢？&lt;/p&gt;

&lt;p&gt;说几个典型场景：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;场景A&lt;/strong&gt;：用户 &lt;code&gt;UserA&lt;/code&gt; 输入命令 &lt;code&gt;find / -name &quot;hello&quot;&lt;/code&gt;，结果提示: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find: /etc/cups/ssl: Permission denied
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;操作服务器时，不同用户之间的权限差异，概括几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;是否有权限，读（r）、写（w）、执行（x），文件 &lt;code&gt;FileA&lt;/code&gt; ；&lt;/li&gt;
  &lt;li&gt;是否有权限，执行命令&lt;code&gt;commandA&lt;/code&gt;；实质上，命令&lt;code&gt;commandA&lt;/code&gt;对应了某个可执行的文件&lt;code&gt;commandA-File&lt;/code&gt;，有权限执行命令&lt;code&gt;commandA&lt;/code&gt;等价于具有文件&lt;code&gt;commandA-File&lt;/code&gt;的执行（x）权限；&lt;/li&gt;
  &lt;li&gt;用户&lt;code&gt;UserA&lt;/code&gt;，找不到命令&lt;code&gt;commandA&lt;/code&gt;，说明，没有将命令&lt;code&gt;commandA&lt;/code&gt;添加到用户&lt;code&gt;UserA&lt;/code&gt;的环境变量&lt;code&gt;PATH&lt;/code&gt;中；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前介绍的Linux ACL（Access Control List，访问控制列表），已经实现了对文件&lt;code&gt;rwx&lt;/code&gt;权限的控制，因此，问题基本解决。&lt;/p&gt;

&lt;p&gt;Linux下，进行身份变换这一功能，有必要吗？公认的原因有几个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用一般帐号：系统日常维护的好习惯。仅当需要设定系统环境时，才变换为root身份，来进行系统管理；&lt;/li&gt;
  &lt;li&gt;使用较低权限启动系统服务。例如，额外建立一个用户起名：apache，并以此来启动apache软件，这样如果apache程序被攻破了，系统还不至于被摧毁；&lt;/li&gt;
  &lt;li&gt;软件本身的限制：有些远程连接程序（例如ssh），可设置为仅允许非root用户登录；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于上述考虑，通常使用一般帐号登录，在必要的时候，切换成root身份。问题来了：如何使一般用户转换为root用户呢？主要方式有两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;su - root&lt;/code&gt;命令，直接切换为root用户：
    &lt;ul&gt;
      &lt;li&gt;需要输入root密码来确认；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;sudo CMD&lt;/code&gt;命令，利用root身份执行命令&lt;code&gt;CMD&lt;/code&gt;：
    &lt;ul&gt;
      &lt;li&gt;需要事先设定普通用户具备sudo的权限；&lt;/li&gt;
      &lt;li&gt;在进行sudo操作时，需要输入普通用户自己的密码；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;su&quot;&gt;su命令&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;man su&lt;/code&gt;来查看命令使用方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NAME
	   su - run a shell with substitute user and group IDs

SYNOPSIS
	   su [OPTION]... [-] [USER [ARG]...]

DESCRIPTION
	   Change  the  effective  user  id  and group id to that of
	   USER.

	   -, -l, --login
			  make the shell a login shell

	   -c, --command=COMMAND
			  pass a single COMMAND to the shell with -c

	   --session-command=COMMAND
			  pass a single COMMAND to the shell with -c and  do
			  not create a new session

	   -f, --fast
			  pass -f to the shell (for csh or tcsh)

	   -m, --preserve-environment
			  do not reset environment variables

	   -p     same as -m

	   -s, --shell=SHELL
			  run SHELL if /etc/shells allows it

	   --help display this help and exit

	   --version
			  output version information and exit

	   A mere - implies -l.   If USER not given, assume root.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要额外说明的一点：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;命令`su root`与`su - root`命令差异很大：
* `su root`：使用login shell方式登录；
* `su - root`：使用non-login shell方式登录；
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;（疑问：login shell 和 non-login shell之间有什么差异？）&lt;/p&gt;

&lt;p&gt;（说明：non-login shell方式登录，很多环境变量无法读取到，需要使用绝度路径的方式来执行）&lt;/p&gt;

&lt;p&gt;命令&lt;code&gt;su - root&lt;/code&gt;需要root密码，因此不方便多用户之间的使用；有没有既能够以root身份来执行命令，同时也不需要root密码的方式？有，sudo命令，就是干这个的。&lt;/p&gt;

&lt;h2 id=&quot;sudo&quot;&gt;sudo命令&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;man sudo&lt;/code&gt;来查看命令详情：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NAME
	   sudo, sudoedit - execute a command as another user

SYNOPSIS
	   sudo -h | -K | -k | -L | -V

	   sudo -v [-AknS] [-g group name|#gid] [-p prompt]
	   [-u user name|#uid] [command]

	   sudo -l[l] [-AknS] [-g group name|#gid] [-p prompt]
	   [-U user name] [-u user name|#uid] [command]

	   sudo [-AbEHnPS] [-C fd] [-g group name|#gid] [-p prompt]
	   [-r role] [-t type] [-u user name|#uid] [VAR=value]
	   [-i | -s] [command]

	   sudoedit [-AnS] [-C fd] [-g group name|#gid] [-p prompt]
	   [-u user name|#uid] file ...

DESCRIPTION
	   sudo allows a permitted user to execute a command as the
	   superuser or another user, as specified in the sudoers
	   file.  The real and effective uid and gid are set to
	   match those of the target user as specified in the passwd
	   file and the group vector is initialized based on the
	   group file (unless the -P option was specified).  If the
	   invoking user is root or if the target user is the same
	   as the invoking user, no password is required.
	   
	   Otherwise, sudo requires that users authenticate
	   themselves with a password by default (NOTE: in the
	   default configuration this is the user’s password, not
	   the root password).  Once a user has been authenticated,
	   a time stamp is updated and the user may then use sudo
	   without a password for a short period of time (5 minutes
	   unless overridden in sudoers).

	   When invoked as sudoedit, the -e option (described
	   below), is implied.

	   sudo determines who is an authorized user by consulting
	   the file /etc/sudoers.  By running sudo with the -v
	   option, a user can update the time stamp without running
	   a command.  If a password is required, sudo will exit if
	   the user’s password is not entered within a configurable
	   time limit.  The default password prompt timeout is 5
	   minutes.

	   If a user who is not listed in the sudoers file tries to
	   run a command via sudo, mail is sent to the proper
	   authorities, as defined at configure time or in the
	   sudoers file (defaults to root).  Note that the mail will
	   not be sent if an unauthorized user tries to run sudo
	   with the -l or -v option.  This allows users to determine
	   for themselves whether or not they are allowed to use
	   sudo.

	   If sudo is run by root and the SUDO_USER environment
	   variable is set, sudo will use this value to determine
	   who the actual user is.  This can be used by a user to
	   log commands through sudo even when a root shell has been
	   invoked.  It also allows the -e option to remain useful
	   even when being run via a sudo-run script or program.
	   Note however, that the sudoers lookup is still done for
	   root, not the user specified by SUDO_USER.

	   sudo can log both successful and unsuccessful attempts
	   (as well as errors) to syslog(3), a log file, or both.
	   By default sudo will log via syslog(3) but this is
	   changeable at configure time or via the sudoers file.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sudo命令，注意事项：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;默认，只有root能使用&lt;code&gt;sudo&lt;/code&gt;命令；&lt;/li&gt;
  &lt;li&gt;基本用法：&lt;code&gt;sudo -u [username] [command]&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;没有指定&lt;code&gt;-u [username]&lt;/code&gt;选项时，默认&lt;code&gt;-u root&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;root执行sudo时，不需要输入密码；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;sudo -u [username] [command]&lt;/code&gt;中当前用户即为&lt;code&gt;username&lt;/code&gt;时，也不需要输入密码；（即，自己切换为自己身份时，不需要输入密码）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;sudo执行流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用户执行sudo时，系统于/etc/sudoers文件中，查找用户是否有执行sudo的权限；&lt;/li&gt;
  &lt;li&gt;若具有执行sudo的权限，则让用户输入自己密码来确认执行；&lt;/li&gt;
  &lt;li&gt;密码正确，则执行命令；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用户是否具有sudo执行权限，依据是/etc/sudoers文件，因此，为某一用户开通sudo权限，本质就是修改/etc/sudoers文件，直接使用vim来编辑，有可能会破坏文件的规范，推荐使用命令&lt;code&gt;visudo&lt;/code&gt;来修改这一文件。&lt;/p&gt;

&lt;h2 id=&quot;visudo&quot;&gt;visudo命令&lt;/h2&gt;

&lt;h3 id=&quot;aroot&quot;&gt;场景A：单个用户拥有root所有命令&lt;/h3&gt;

&lt;p&gt;（分析：拥有root的所有命令？命令难道不是添加到PATH环境变量中就可以了吗？不是的，命令添加到PATH变量中，也是需要用户有这个命令的执行&lt;code&gt;x&lt;/code&gt;权限的。）&lt;/p&gt;

&lt;p&gt;如果希望dev用户使用root的所有命令，那么可以进行如下修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# visudo
...
## Allow root to run any commands anywhere
root    ALL=(ALL)       ALL
# 新增的一行
dev		ALL=(ALL)       ALL
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面对新增行的格式进行简要说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;用户      用户登录来源主机名=(可切换的身份)	可执行的命令
root                     ALL=(ALL)	       	ALL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面四个组件含义进行简要说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用户：这个用户可以使用sudo命令，默认为root用户；&lt;/li&gt;
  &lt;li&gt;用户登录来源主机：设定允许用户通过哪些主机登录过来；&lt;/li&gt;
  &lt;li&gt;可切换的身份：可以切换为什么身份来执行命令，默认root可以切换为任何用户；&lt;/li&gt;
  &lt;li&gt;可执行的命令：务必使用绝对路径；&lt;/li&gt;
  &lt;li&gt;ALL关键词：代表任何身份、主机、命令；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在dev用户就可以执行sudo命令了，按照下面操作试一试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[dev@localhost /]$ head -n 1 /etc/shadow
head: cannot open `/etc/shadow&#39; for reading: Permission denied
[dev@localhost /]$ sudo head -n 1 /etc/shadow
[sudo] password for devp:
root:$6$2t1NiW.e$SM0:16296:0:99999:7:::
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;授予sudo命令的执行权限之前，需调查用户的人品，除非必要，一概不授予普通用户sudo权限。上述设置中，dev用户相当于拥有了整个系统的所有权限，通过&lt;code&gt;sudo visudo&lt;/code&gt;命令，用户&lt;code&gt;dev&lt;/code&gt;也能够像&lt;code&gt;root&lt;/code&gt;用户一样设定所有用户的sudo权限，欧，这也太危险了。&lt;/p&gt;

&lt;h3 id=&quot;bsudo&quot;&gt;场景B：群组的sudo权限及免密码功能&lt;/h3&gt;

&lt;p&gt;如果希望&lt;code&gt;group=dev&lt;/code&gt;内的所有成员都具有sudo命令权限，则进行如下设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# visudo
...
## Allows people in group wheel to run all commands
# %wheel        ALL=(ALL)       ALL
# 新增的一行
%dev   ALL=(ALL)       ALL
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上述设置，&lt;code&gt;group=dev&lt;/code&gt;内成员都具有了sudo权限命令，今后赋予新的成员sudo权限时，只需要将其加入&lt;code&gt;dev&lt;/code&gt;组内即可，而不必每次都修改&lt;code&gt;/etc/sudoers&lt;/code&gt;文件。补充：如何设置用户免密码使用sudo权限？OK，请看如下操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# visudo
...
## Same thing without a password
# %wheel        ALL=(ALL)       NOPASSWD: ALL
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;csudo&quot;&gt;场景C：命令受限的sudo权限&lt;/h3&gt;

&lt;p&gt;前面两个场景中，普通用户获得了与root相当的权限，甚至普通用户反过来能修改root的密码（使用命令：&lt;code&gt;sudo -u root passwd&lt;/code&gt;），这是篡权啊，想想就害怕。然而，害怕并不能解决问题，一些情况下，又必须给普通用户sudo权限，好了，能不能只给用户受限制的sudo权限呢？&lt;/p&gt;

&lt;p&gt;下面以添加用户dev，使其辅助root修改其他用户的密码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# visudo
...
## 为`dev`用户添加权限，使其辅助root修改其他用户密码
dev        ALL=(root)       /usr/bin/passwd [A-Za-Z]*,!/usr/bin/passwd,!/usr/bin/passwd root
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;几点说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过sudo授权用户可执行的命令&lt;code&gt;/usr/bin/passwd&lt;/code&gt;等，要使用绝对路径；&lt;/li&gt;
  &lt;li&gt;多个授权命令之间，使用逗号&lt;code&gt;,&lt;/code&gt;分割；&lt;/li&gt;
  &lt;li&gt;在命令前添加感叹号&lt;code&gt;!&lt;/code&gt;，表示禁止执行此命令；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dvisudo&quot;&gt;场景D：visudo用别名简化配置&lt;/h3&gt;

&lt;p&gt;针对这个情况，举个例子，就清晰了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;User_Alias ADMPW = pro1,pro2
Cmnd_Alias ADMPWCMD = !/usr/bin/passwd, \
		/usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root

ADMPW ALL=(root) ADMPWCOM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际场景中如果忘记了这个例子，没有关系的，只需要&lt;code&gt;visudo&lt;/code&gt;命令，就能看到文件&lt;code&gt;/etc/sudoers&lt;/code&gt;中注释部分的提示了。&lt;/p&gt;

&lt;h3 id=&quot;sudo-1&quot;&gt;sudo命令密码有效时长&lt;/h3&gt;

&lt;p&gt;如果第一次执行sudo命令，则需要输入用户密码，但短时间内T，再次使用sudo命令时，并不需要输入密码。因为系统相信短时间T内，你不会离开服务器，所以再次执行sudo命令，是同一个人。&lt;/p&gt;

&lt;p&gt;（如何设置sudo命令密码的有效时长？）&lt;/p&gt;

&lt;h3 id=&quot;sudosu&quot;&gt;sudo搭配su的使用方式&lt;/h3&gt;

&lt;p&gt;很多时候，我们需要大量的执行很多root的工作，所以，一直使用sudo觉得很烦！那有没有方法使用sudo搭配su，一口气身份转换为root，并且还用用户自己的密码来编程root呢？是有的，而且方法简单的会让你想笑！具体如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@www ~]visudo
...
User_Alias ADMINS =pro1,pro2,pro3
ADMINS ALL=(root) /bin/su -
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，上述pro1、pro2、pro3共计3个用户，只需要输入&lt;code&gt;sudo su -&lt;/code&gt;命令，并且输入自己的密码后，立即转换为root身份了！但root密码不会外流。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特别说明&lt;/strong&gt;：所有sudo用户，都是经过人格调查后，服务器管理员绝对信任的用户，否则，禁掉这一用户的sudo权限。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;《&lt;a href=&quot;&quot;&gt;鸟哥的Linux私房菜 基础版（第三版）–Chapter 14&lt;/a&gt;》&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>ACL入门</title>
     <link href="http://ningg.github.com/linux-acl"/>
     <updated>2014-08-14T00:00:00+08:00</updated>
     <id>http://ningg.github.com/linux-acl</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;文件系统上，文件权限管理的时候，通常有一个词语：ACL。ACL到底是什么？&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;是什么&lt;/h2&gt;

&lt;p&gt;（侧重于ACL能做什么事）&lt;/p&gt;

&lt;p&gt;ACL（&lt;code&gt;Access Control List&lt;/code&gt;，访问控制列表），并不用于设定&lt;code&gt;文件&lt;/code&gt;/&lt;code&gt;目录&lt;/code&gt;的owner、group、others的read、write、execute（&lt;code&gt;r&lt;/code&gt;,&lt;code&gt;w&lt;/code&gt;,&lt;code&gt;x&lt;/code&gt;）权限，而是除此权限设置之外的更细节的权限设置。&lt;/p&gt;

&lt;p&gt;特别说明：实际上，ACL也可以设置文件owner、group、others对应的&lt;code&gt;r&lt;/code&gt;/&lt;code&gt;w&lt;/code&gt;/&lt;code&gt;e&lt;/code&gt;权限，但我们通常使用&lt;code&gt;chmod&lt;/code&gt;命令来实现此功能，而倾向将ACL用于除此之外的权限设置。&lt;/p&gt;

&lt;p&gt;ACL设定的权限主要有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用者（&lt;code&gt;user&lt;/code&gt;）：设置某个使用者（&lt;code&gt;user&lt;/code&gt;）读、写、执行一个文件的权限；解释：此处的&lt;code&gt;user&lt;/code&gt;，不是&lt;code&gt;owner&lt;/code&gt;，而是其他的用户；&lt;/li&gt;
  &lt;li&gt;群组（&lt;code&gt;group&lt;/code&gt;）：设置某个群组（&lt;code&gt;group&lt;/code&gt;）读、写、执行一个文件的权限；解释：此处的&lt;code&gt;group&lt;/code&gt;不是指，文件对应的&lt;code&gt;owning group&lt;/code&gt;的执行权限，而是除&lt;code&gt;owning group&lt;/code&gt;之外的其他&lt;code&gt;group&lt;/code&gt;，操作此文件的权限；&lt;/li&gt;
  &lt;li&gt;默认属性（&lt;code&gt;mask&lt;/code&gt;）：设定某一个&lt;code&gt;目录&lt;/code&gt;之下，新建&lt;code&gt;文件&lt;/code&gt;/&lt;code&gt;目录&lt;/code&gt;时，这些新建的&lt;code&gt;文件&lt;/code&gt;/&lt;code&gt;目录&lt;/code&gt;的默认权限;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（上面内容有待补充）&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;怎么用&lt;/h2&gt;

&lt;p&gt;ACL（&lt;code&gt;访问控制列表&lt;/code&gt;），是Unix-like操作系统权限的额外支持项目，需要文件系统（&lt;code&gt;File System&lt;/code&gt;）的支持。当前大部分文件系统都支持ACL，例如：EXT2/3
、JFS、XFS等。&lt;/p&gt;

&lt;h3 id=&quot;acl&quot;&gt;是否支持ACL&lt;/h3&gt;

&lt;p&gt;使用命令&lt;code&gt;dumpe2fs -h /dev/sda1&lt;/code&gt;查看某一分区上文件系统是否支持ACL，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost devp]# dumpe2fs -h /dev/sda1
dumpe2fs 1.41.12 (17-May-2010)
...
Default mount options:    user_xattr acl
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：&lt;code&gt;dumpe2fs&lt;/code&gt;含义：dump ext2/ext3/ext4 filesystem information.	&lt;/p&gt;

&lt;h3 id=&quot;acl-1&quot;&gt;是否启用ACL&lt;/h3&gt;

&lt;p&gt;文件系统支持ACL，即有能力开启ACL，但是文件系统需要开启ACL，通过如下方式来查询是否开启ACL：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 直接参阅挂载参数
[root@localhost ~]# mount
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
tmpfs on /dev/shm type tmpfs (rw)
/dev/sda1 on /boot type ext4 (rw)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;备注：“是否支持ACL”和“是否启用ACL”这两部分，自己理解不能肯定，需要补充。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;两个命令&lt;/h3&gt;

&lt;p&gt;filesystem启动ACL支持之后，就可以设定和查看ACL了，主要是两条命令：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;getfacl&lt;/code&gt;：查看文件的ACL；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;setfacl&lt;/code&gt;：设置文件的ACL；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两个命令侧重于使用命令：&lt;code&gt;man [COMMAND]&lt;/code&gt;来查看命令细节。两个命令相互配合使用，通常&lt;code&gt;setfacl&lt;/code&gt;之后，跟着一个&lt;code&gt;getfacl&lt;/code&gt;来查看设置是否成功。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;几个场景和实例&lt;/h3&gt;

&lt;h4 id=&quot;section-5&quot;&gt;简介&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;setfacl&lt;/code&gt;：&lt;code&gt;set file access control list&lt;/code&gt;，设置ACL。命令详情如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[superman@localhost /]$ setfacl --help
setfacl 2.2.49 -- `set file access control lists`
Usage: setfacl [-bkndRLP] { -m|-M|-x|-X ... } file ...
  -m, --modify=acl        modify the current ACL(s) of file(s)
  -M, --modify-file=file  read ACL entries to modify from file
  -x, --remove=acl        remove entries from the ACL(s) of file(s)
  -X, --remove-file=file  read ACL entries to remove from file
  -b, --remove-all        remove all extended ACL entries
  -k, --remove-default    remove the default ACL
	  --set=acl           set the ACL of file(s), replacing the current ACL
	  --set-file=file     read ACL entries to set from file
	  --mask              do recalculate the effective rights mask
  -n, --no-mask           don&#39;t recalculate the effective rights mask
  -d, --default           operations apply to the default ACL
  -R, --recursive         recurse into subdirectories
  -L, --logical           logical walk, follow symbolic links
  -P, --physical          physical walk, do not follow symbolic links
	  --restore=file      restore ACLs (inverse of `getfacl -R&#39;)
	  --test              test mode (ACLs are not modified)
  -v, --version           print version and exit
  -h, --help              this help text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getfacl&lt;/code&gt;：&lt;code&gt;get file access control lists&lt;/code&gt;，查看ACL。命令详情如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[god@localhost /]$ getfacl -h
getfacl 2.2.49 -- get file access control lists
Usage: getfacl [-aceEsRLPtpndvh] file ...
  -a,  --access           display the file access control list only
  -d, --default           display the default access control list only
  -c, --omit-header       do not display the comment header
  -e, --all-effective     print all effective rights
  -E, --no-effective      print no effective rights
  -s, --skip-base         skip files that only have the base entries
  -R, --recursive         recurse into subdirectories
  -L, --logical           logical walk, follow symbolic links
  -P, --physical          physical walk, do not follow symbolic links
  -t, --tabular           use tabular output format
  -n, --numeric           print numeric user/group identifiers
  -p, --absolute-names    don&#39;t strip leading &#39;/&#39; in pathnames
  -v, --version           print version and exit
  -h, --help              this help text
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;user&quot;&gt;场景1：设置user权限&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;场景描述：让devp用户获取查看&lt;code&gt;/root&lt;/code&gt;目录的权限。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;设置user权限的命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setfacl -m u:devp:rx /root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 查看目录详情（不是目录下内容列表）
// 查询结果中`dr-xr-x---+`，最后的`+`表示有ACL附加权限；
[god@localhost /]# ll -d root
dr-xr-x---+ 18 root root 4096 Aug  5 09:32 root
// 查看ACL详情
[god@localhost /]# getfacl root
# file: root 
# owner: root
# group: root
user::r-x       //`owner`的权限
user:devp:r-x   //用户`devp`的权限（ACL设置的细节）
group::r-x      //`owning group`的权限
mask::r-x       //什么含义？（ACL设置的细节）
other::---
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;user-1&quot;&gt;场景2：取消user权限&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;场景描述：在场景1中设置了devp用户查看&lt;code&gt;/root&lt;/code&gt;目录的权限，如何取消devp用户的这一权限呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;取消&lt;code&gt;user&lt;/code&gt;权限的命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setfacl -x u:devp /root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 查看ACL详情
[god@localhost /]# getfacl root
# file: root 
# owner: root
# group: root
user::r-x       //`owner`的权限
group::r-x      //`owning group`的权限
mask::r-x       
other::---
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;group&quot;&gt;场景3：设置group权限&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;场景描述：如何设置&lt;code&gt;devp&lt;/code&gt;组拥有&lt;code&gt;/root&lt;/code&gt;目录的查看权限？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;设置命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set -m g:devp:rx /root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询结果：&lt;/p&gt;

&lt;p&gt;（未完待续，各个典型场景）	&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;什么原理&lt;/h2&gt;

&lt;p&gt;（参考：Hadoop技术内幕中HDFS的架构设计与实现原理）&lt;/p&gt;

&lt;h2 id=&quot;hdfsacl&quot;&gt;HDFS中的ACL&lt;/h2&gt;

&lt;p&gt;Hadoop从2.4.0版本开始支持ACL（英文原版的出处），并且已经有人对此进行了测试：http://blog.csdn.net/j2eelamp/article/details/24594159&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>HTTP协议</title>
     <link href="http://ningg.github.com/protocol-http-intro"/>
     <updated>2014-08-13T00:00:00+08:00</updated>
     <id>http://ningg.github.com/protocol-http-intro</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;最近要用java来构造HTTP请求、接收HTTP响应，并从HTTP响应中获取尽可能多的上下文信息，自己每次都查看JAVA的API，不过结果总是浑浑噩噩的感觉，因为自己并不确定HTTP响应中包含了哪些详细的信息，更何谈要提取这些信息了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（备注：不要求大而全，而要求先能够解决问题）&lt;/p&gt;

&lt;h2 id=&quot;http&quot;&gt;HTTP协议的由来&lt;/h2&gt;

&lt;p&gt;OSI模型把网络通信分成七层：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层，对于开发网络应用人员来说，一般把网络分成五层，这样比较容易理解。这五层为：物理层、数据链路层、网络层、传输层和应用层（最顶层），如下图所示：&lt;/p&gt;

&lt;p&gt;网络中的计算机互相通信就是实现了层与层之间的通信，要实现层与层之间的通信，则各层都要遵守规则，这样才能完成更好的通信， 我们就把它们之间遵守的规则就叫个“协议”，然而网络上的五层之间遵守的协议不一样，每层都有各自的协议。下面就对各层进行简要介绍：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;物理层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;物理层是五层模型中的最底层，物理层为计算机之间的数据通信提供了传输媒体和互连设备的标准，为数据传输提供了可靠的环境，媒体包括电缆、光纤、无线信道等，互连设备指是计算机和调制解调器之间的互连设备，如各种插头、插座等。该层的作用是透明的传输比特流（即二进制流），为数据链路层提供一个传输原始比特流的物理连接。&lt;/p&gt;

&lt;p&gt;总结一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;目标：透明地传输bit。&lt;/li&gt;
  &lt;li&gt;传输单元：bit。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;数据链路层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据链路层是模型中的第2层，该层对接受到物理层传输过来的比特流进行分组，一组电信号构成的数据包，就叫做”帧”，数据链链路层就是来传输以”帧”为单位的数据包，把数据传递给上一层（网络层），帧数据由两部分组成：帧头和帧数据，帧头包括接受方物理地址（就是网卡的地址）和其他的网络信息，帧数据就是要传输的数据体。数据帧的最长为1500字节，如果数据很长，就必须分割成多个帧进行发送。&lt;/p&gt;

&lt;p&gt;总结一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;目标：通过&lt;code&gt;MAC地址&lt;/code&gt;来标识设备，并且在两个相邻设备之间，透明、可靠地传输&lt;code&gt;数据帧&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;传输单元：&lt;code&gt;帧&lt;/code&gt;，包含帧头和帧数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该层通过寻址（寻址地址）来建立两个节点之间的连接，大家都知道我们的电脑连接上网络后都一个IP地址，我们可以通过IP地址来确定不同的计算机是否在同一个子网内。如果我们的电脑连接上网络后就有两种地址：物理地址和网络地址（IP地址），网络上的计算机要通信，必须要知道通信的计算机“在哪里”， 首先通过网络地址来判断是否处于同一个子网，然后再对物理地址（MAC）地址进行处理，从而准确确定要通信计算机的位置。&lt;/p&gt;

&lt;p&gt;在网络层中有我们熟悉的IP协议（即规定网络地址的协议），目前广泛采用的是IP协议第四版（IPv4）,这个版本规定，网络地址由32位二进制位组成。&lt;/p&gt;

&lt;p&gt;网络层中以IP数据包的形式来传递数据，IP数据包也包括两部分：头（Head）和数据(Data)，IP数据包放进数据帧中的数据部分进行传输。&lt;/p&gt;

&lt;p&gt;总结一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;目标：通过&lt;code&gt;IP地址&lt;/code&gt;来标识网络节点，并且在网络中任意两个节点之间，透明、可靠地传输&lt;code&gt;IP数据包&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;传输单元：&lt;code&gt;IP数据包&lt;/code&gt;，包含包头和数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过MAC和IP地址，我们可以找到互联网上任意两台主机来建立通信。然而这里有一个问题，找到主机后，主机上有很多程序都需要用到网络，比如说你在一边听歌和好用QQ聊天，当网络上发送来一个数据包时，是怎么知道它是表示聊天的内容还是歌曲的内容的， 这时候就需要一个参数来表示这个数据包是发送给那个程序（进程）来使用的，这个参数我们就叫做&lt;code&gt;端口号&lt;/code&gt;，主机上用端口号来标识不同的程序（进程），端口是0到65535之间的一个整数，0到1023的端口被系统占用，用户只能选择大于1023的端口。&lt;/p&gt;

&lt;p&gt;传输层的功能就是建立端口到端口的通信，网络层就是建立主机与主机的通信，这样如果我们确定了主机和端口，这样就可以实现程序之间的通信了。我们所说的Socket编程就是通过代码来实现传输层之间的通信。因为初始化Socket类对象要指定IP地址和端口号。&lt;/p&gt;

&lt;p&gt;在传输层有两个非常重要的协议：UDP 协议和TCP协议&lt;/p&gt;

&lt;p&gt;采用UDP协议话传输的就是UDP数据包，同样UDP数据包也由头和数据两部分组成，头部分主要标识了发送端口和接受端口，数据部分就是具体的内容信息。同样UDP数据包是放入IP数据包中的”数据”部分，IP数据包再放入数据帧中在网络上传输。&lt;/p&gt;

&lt;p&gt;由于UDP协议的可靠性差（数据发送后无法确定对方是否收到），所以又定义了一个可靠性高的协议——TCP协议，TCP协议采取了握手的方式要确保对方收到了数据。&lt;/p&gt;

&lt;p&gt;总结一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;目标：通过&lt;code&gt;IP地址：端口号&lt;/code&gt;来标识网络节点上的一个进程，并在网络中任意两个节点上的两个进程之间，实现消息的透明传输。&lt;/li&gt;
  &lt;li&gt;传输单元：数据包，TCP数据包或者UDP数据包。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;应用层是模型中的最顶层，是用户与网络的接口，HTTP协议就属于这一层。HTTP协议能做什么？
很多人首先一定会想到：浏览网页。没错，浏览网页是HTTP的主要应用，但是这并不代表HTTP就只能应用于网页的浏览。HTTP是一种协议，只要通信的双方都遵守这个协议，HTTP就能有用武之地。比如咱们常用的QQ，迅雷这些软件，都会使用HTTP协议(还包括其他的协议)。需要说明的是，应用层HTTP协议传输的数据，在传输层，是由TCP协议承载的。&lt;/p&gt;

&lt;p&gt;数据流动的时候，发送端，应用数据从上层向下，层层打包（添加包头），接收端，数据从下层向上，层层解包（去除包头）。&lt;/p&gt;

&lt;p&gt;（应用层到底是什么？应用层与端口之间什么关系？会话层、表示层、应用层之间又有什么差异？）&lt;/p&gt;

&lt;h2 id=&quot;http-1&quot;&gt;HTTP协议如何工作&lt;/h2&gt;

&lt;p&gt;利用HTTP协议传输数据时，其基本过程：Client发送HTTP请求，Server返回HTTP响应；如下图所示：&lt;/p&gt;

&lt;p&gt;（插入一个图片）&lt;/p&gt;

&lt;h3 id=&quot;requestresponse&quot;&gt;Request\Response格式&lt;/h3&gt;

&lt;p&gt;详细信息请参考：&lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;关于HTTP headers的简要汇总和介绍，请参看：&lt;a href=&quot;http://www.cs.tut.fi/~jkorpela/http.html&quot;&gt;Quick reference to HTTP headers&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;request&quot;&gt;Request&lt;/h4&gt;

&lt;p&gt;Request格式：&lt;/p&gt;

&lt;p&gt;（插入一张图片：Request格式）&lt;/p&gt;

&lt;p&gt;备注：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;cr&gt;&lt;lf&gt;为回车换行，其中：CR，Carriage Return，回车，打字机头部位置；LF，Line Feed，换行，打字机向下换一行；
&lt;/lf&gt;&lt;/cr&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Null Line&lt;/code&gt;中必须只有&lt;cr&gt;&lt;lf&gt;而无其他空格；&lt;/lf&gt;&lt;/cr&gt;&lt;/li&gt;
  &lt;li&gt;在HTTP/1.1协议中，所有的&lt;code&gt;Headers&lt;/code&gt;中，除Host外，都是可选的；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Requset实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET http://www.cnblogs.com/gpcuster/ HTTP/1.1
Host: www.cnblogs.com
Proxy-Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36
Referer: http://www.baidu.com/s?wd=http%3A%2F%2Fwww.cnblogs.com%2Fgpcuster%2F&amp;amp;rsv_spt=1&amp;amp;issp=1&amp;amp;rsv_bp=0&amp;amp;ie=utf-8&amp;amp;tn=baiduhome_pg&amp;amp;rsv_n=2&amp;amp;rsv_sug3=1&amp;amp;rsv_sug4=271&amp;amp;inputT=2186
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: __gads=ID=d58f6aafc2b1682a:T=1399182693:S=ALNI_MbGQmpINTGEw1DKhg8-v-WGcqmDGg; CNZZDATA4902471=cnzz_eid%3D780096130-1402377079-http%253A%252F%252Fwww.baidu.com%252F%26ntime%3D1403490466; CNZZDATA3980738=cnzz_eid%3D371156967-1402987944-http%253A%252F%252Fwww.baidu.com%252F%26ntime%3D1404384515; CNZZDATA1923552=cnzz_eid%3D857445479-1402888944-http%253A%252F%252Fwww.cnblogs.com%252F%26ntime%3D1405079579; AJSTAT_ok_times=5; gs_u_GSN-690926-A=567797657:3115:11443:1407743725372; _ga=GA1.2.1054927095.1399182860; __utma=226521935.1054927095.1399182860.1407743656.1407743991.33; __utmb=226521935.2.10.1407743991; __utmc=226521935; __utmz=226521935.1407743991.33.27.utmcsr=baidu|utmccn=(organic)|utmcmd=organic|utmctr=http%3A%2F%2Fwww.cnblogs.com%2Fgpcuster%2F
If-Modified-Since: Mon, 11 Aug 2014 07:59:18 GMT
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;response&quot;&gt;Response&lt;/h4&gt;

&lt;p&gt;Response格式：&lt;/p&gt;

&lt;p&gt;（插入一张图片：Response格式）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Date: Mon, 11 Aug 2014 07:59:41 GMT
Content-Type: text/html; charset=utf-8
Transfer-Encoding: chunked
Proxy-Connection: keep-alive
Vary: Accept-Encoding
Cache-Control: private, max-age=10
Expires: Mon, 11 Aug 2014 07:59:33 GMT
Last-Modified: Mon, 11 Aug 2014 07:59:23 GMT
X-UA-Compatible: IE=10
Content-Encoding: gzip
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;headers&quot;&gt;常用的Headers&lt;/h4&gt;

&lt;p&gt;（doing…）&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;http://blog.csdn.net/adparking/article/details/7265496
http://blog.csdn.net/kfanning/article/details/6062118
http://www.cnblogs.com/loveyakamoz/archive/2011/07/22/2113614.html
http://blog.sina.com.cn/s/blog_5dd2af0901012oko.html
http://canrry.iteye.com/blog/1331292&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;建立连接的方式&lt;/h3&gt;

&lt;p&gt;HTTP支持2种建立连接的方式：非持久连接和持久连接（HTTP 1.0 默认：持久连接的带流水线方式）&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;非持久连接&lt;/h4&gt;

&lt;p&gt;让我们查看一下非持久连接情况下，从Server到Client传送一个Web页面的步骤。假设该页面由：1个基本HTML文件和10个JPEG图像构成，而且所有这些对象都存放在同一台服务器中。再假设该基本HTML文件的URL为：&lt;code&gt;gpcuster.cnblogs.com/index.html&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;下面是具体步骡:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;HTTP Client&lt;/code&gt;初始化一个与&lt;code&gt;HTTP Server&lt;/code&gt;之间的TCP连接。&lt;code&gt;HTTP Server&lt;/code&gt;使用默认端口号80监听来自&lt;code&gt;HTTP Client&lt;/code&gt;的连接建立请求。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;HTTP Client&lt;/code&gt;经由与TCP连接相关联的本地套接字，发出—个HTTP请求消息。这个消息中包含路径名/somepath/index.html。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;HTTP Server&lt;/code&gt; 经由与TCP连接相关联的本地套接字，接收这个请求消息，再从服务器主机的内存或硬盘中取出对象/somepath/index.html，经由同一个套接字发出包含该对象的响应消息。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;HTTP Server&lt;/code&gt;告知TCP关闭这个TCP连接(不过TCP要到客户收到刚才这个响应消息之后才会真正终止这个连接)。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;HTTP Client&lt;/code&gt;经由同一个套接字接收这个响应消息，TCP连接随后终止。&lt;/li&gt;
  &lt;li&gt;HTTP响应中，所封装的对象是一个HTML文件。&lt;code&gt;HTTP Server&lt;/code&gt;从响应中取出这个HTML文件，加以分析后发现其中有10个JPEG对象的引用。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;HTTP Client&lt;/code&gt;针对每一个JPEG对象引用，重复步骡1-5。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述步骤之所以称为&lt;code&gt;非持久连接&lt;/code&gt;，原因是每次&lt;code&gt;HTTP Server&lt;/code&gt;返回一个HTTP响应后，相应的TCP连接就被关闭，即，每个TCP连接只用于传输一个请求消息和一个响应消息。针对上述例子，用户每请求一次那个web页面，就反复建立、释放了11个TCP连接。&lt;/p&gt;

&lt;p&gt;关于非持久连接，总结一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP请求之前，建立TCP连接，HTTP响应之后，释放TCP连接；&lt;/li&gt;
  &lt;li&gt;每个TCP连接只承载一组HTTP请求和响应消息；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;备注：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;名词&lt;code&gt;套接字&lt;/code&gt;socket是什么？&lt;/li&gt;
  &lt;li&gt;TCP连接建立时，有3次握手，详细过程；&lt;/li&gt;
  &lt;li&gt;TCP连接释放时，也有4次握手，详细过程；&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;持久连接&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;非持久连接&lt;/code&gt;有几点效率问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每个等待请求的对象，都需要建立并维护一个独立的TCP连接；对于每个这样的连接，TCP得在客户端和服务器端分配TCP缓冲区，并维持TCP变量。对于有可能同时为来自数百个不同客户的请求提供服务的web服务器来说，这会严重增加其负担。&lt;/li&gt;
  &lt;li&gt;如前所述，每个对象都有2个RTT的响应延长——一个RTT用于建立TCP连接，另—个RTT用于请求和接收对象。&lt;/li&gt;
  &lt;li&gt;每个对象都受TCP慢启动影响，因为每个TCP连接都有一个慢启动阶段。&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;（优点）&lt;/em&gt;也有优势：并行TCP连接的使用，能够部分减轻RTT延迟和慢启动延迟的影响。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为解决非持久连接情况下，反复建立、释放TCP连接时，所产生的资源占用、效率低下的问题，提出了&lt;code&gt;持久连接&lt;/code&gt;，其核心：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;HTTP Server&lt;/code&gt;返回一个HTTP响应之后，TCP连接保持存活一段时间，用于承载后续的其他HTTP请求/响应;&lt;/li&gt;
  &lt;li&gt;TCP连接的存活时间是可以设定的;&lt;/li&gt;
  &lt;li&gt;超过存活时间之后，TCP连接自动释放；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;持久连接分为&lt;code&gt;不带流水线(without pipelining)&lt;/code&gt;和&lt;code&gt;带流水线(with pipelining)&lt;/code&gt;两个版本。&lt;/p&gt;

&lt;p&gt;不带流水线的持久化连接，特点如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Client只在收到前一个请求的响应后才发出新的请求，这种情况下，web页面所引用的每个对象(上例中的10个图像)都经历1个RTT的延迟，用于请求和接收该对象；&lt;/li&gt;
  &lt;li&gt;服务器返回一个响应后，开始等待下一个请求，而这个新请求却不能马上到达，这段时间服务器资源便闲置了；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;带流水线的持久化连接，特点如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HTTP/1.1的默认模式；&lt;/li&gt;
  &lt;li&gt;HTTP Client每碰到一个对象引用，就立即发出一个请求（如果没有可用的TCP连接，则新建一个），&lt;code&gt;HTTP Server&lt;/code&gt;每收到一个请求，就立即返回一个响应；&lt;/li&gt;
  &lt;li&gt;所有引用到的对象一共只经历1个RTT的延迟(而不是像不带流水线的版本那样，每个引用到的对象都各有1个RTT的延迟)；&lt;/li&gt;
  &lt;li&gt;带流水线的持久连接中服务器空等请求的时间比较少；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-4&quot;&gt;缓存机制&lt;/h3&gt;

&lt;p&gt;HTTP/1.1中缓存机制主要目标：提高页面访问速度；实现途径，有两条：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;减少Client发送请求的次数：Client本地缓存页面，发送请求之前先检查一下，当前缓存页面是否&lt;code&gt;过期（expiration）&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;Server只发送局部响应信息：即，Server不返回完整的响应信息，以此减少网络带宽的占用，&lt;code&gt;验证（validation）&lt;/code&gt;机制能够实现此目标；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实际上，HTTP定义了3中缓存机制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Freshness&lt;/strong&gt; allows a response to be used without re-checking it on the origin server, and can be controlled by both the server and the client. For example, the Expires response header gives a date when the document becomes stale, and the Cache-Control: max-age directive tells the cache how many seconds the response is fresh for.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Validation&lt;/strong&gt; can be used to check whether a cached response is still good after it becomes stale. For example, if the response has a Last-Modified header, a cache can make a conditional request using the If-Modified-Since header to see if it has changed.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Invalidation&lt;/strong&gt; is usually a side effect of another request that passes through the cache. For example, if URL associated with a cached response subsequently gets a POST, PUT or DELETE request, the cached response will be invalidated.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于web缓存方面的内容可以参考：Caching Tutorial for Web Authors and Webmasters（&lt;a href=&quot;https://www.mnot.net/cache_docs/#DEFINITION&quot;&gt;英文版&lt;/a&gt;）（&lt;a href=&quot;http://www.chedong.com/tech/cache_docs.html&quot;&gt;中文版&lt;/a&gt;）&lt;/p&gt;

&lt;h2 id=&quot;http-2&quot;&gt;基于HTTP的应用&lt;/h2&gt;

&lt;h3 id=&quot;http-3&quot;&gt;HTTP代理&lt;/h3&gt;

&lt;p&gt;（doing…）&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html&quot;&gt;浅析HTTP协议&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;透明代理&lt;/li&gt;
  &lt;li&gt;非透明代理&lt;/li&gt;
  &lt;li&gt;反向代理&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-5&quot;&gt;多线程下载&lt;/h3&gt;

&lt;p&gt;（doing…）&lt;/p&gt;

&lt;p&gt;基本过程如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;下载工具开启多个线程，来发出HTTP请求；&lt;/li&gt;
  &lt;li&gt;每个HTTP请求只请求资源文件的一部分：Content-Range:bytes 20000-40000/47000&lt;/li&gt;
  &lt;li&gt;合并每个线程下载的文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;https&quot;&gt;HTTPS传输协议原理&lt;/h3&gt;

&lt;p&gt;（doing…）&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html&quot;&gt;浅析HTTP协议&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;webrequest-methods&quot;&gt;WEB开发过程中常用的Request Methods&lt;/h3&gt;

&lt;p&gt;（doing…）&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html&quot;&gt;浅析HTTP协议&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HEAD
  *（Head方法）要求响应与相应的GET请求的响应一样，但是没有的响应体（response body）。这用来获得响应头（response header）中的元数据信息（meta-infomation）有（很）帮助，（因为）它不需要传输所有的内容。&lt;/li&gt;
  &lt;li&gt;TRACE
  *（Trace方法告诉服务器端）返回收到的请求。客户端可以（通过此方法）察看在请求过程中中间服务器添加或者改变哪些内容。&lt;/li&gt;
  &lt;li&gt;OPTIONS
    &lt;ul&gt;
      &lt;li&gt;返回服务器（在指定URL上）支持的HTTP方法。通过请求“*”而不是指定的资源，这个方法可以用来检查网络服务器的功能。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CONNECT
    &lt;ul&gt;
      &lt;li&gt;将请求的连接转换成透明的TCP/IP通道，通常用来简化通过非加密的HTTP代理的SSL-加密通讯（HTTPS）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;用户与服务器交互&lt;/h3&gt;

&lt;p&gt;（doing…）&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html&quot;&gt;浅析HTTP协议&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;身份认证；&lt;/li&gt;
  &lt;li&gt;cookie；&lt;/li&gt;
  &lt;li&gt;待条件的GET；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;javahttp&quot;&gt;java中的HTTP协议&lt;/h2&gt;

&lt;p&gt;（doing…）&lt;/p&gt;

&lt;h3 id=&quot;javahttp-1&quot;&gt;java中HTTP协议&lt;/h3&gt;

&lt;p&gt;（主要两种方式：java api 和 http-common.jar?）&lt;/p&gt;

&lt;h3 id=&quot;servlethttp&quot;&gt;servlet中HTTP协议&lt;/h3&gt;

&lt;h2 id=&quot;section-7&quot;&gt;参考来源&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.w3.org/Protocols/&quot;&gt;W3C: HTTP (HTTP Activity statement)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.chinaw3c.org/about.html&quot;&gt;W3C中文版简介&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/qiqibo/p/3143964.html&quot;&gt;HTTP协议原理解析第一篇&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html&quot;&gt;浅析HTTP协议&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.chedong.com/tech/cache_docs.html&quot;&gt;面向站长和网站管理员的Web缓存加速指南-翻译&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cs.tut.fi/~jkorpela/http.html&quot;&gt;Quick reference to HTTP headers&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;[O’Reilly - HTTP Pocket Reference]&lt;/li&gt;
  &lt;li&gt;[Sams - HTTP Developers Handbook]&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-8&quot;&gt;附录&lt;/h2&gt;

&lt;p&gt;对与几个名词/组织的简介&lt;/p&gt;

&lt;h3 id=&quot;w3c&quot;&gt;W3C&lt;/h3&gt;
&lt;p&gt;万维网联盟（World Wide Web Consortium，简称W3C）创建与1994年，是Web技术领域，影响力较强的国际中立性，技术标准机构。其致力于开发协议、标准、指南，来确保Web的长期发展。详细信息参考：&lt;a href=&quot;http://www.w3.org/Protocols/&quot;&gt;W3C: HTTP (HTTP Activity statement)&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;ietf&quot;&gt;IETF&lt;/h3&gt;
&lt;p&gt;互联网工程任务组（Internet Engineering Task Force，简称IETF）成立于1985年底，是全球互联网领域，极具权威的技术标准化组织，主要任务是负责互联网相关技术规范的研发和制定，当前绝大多数互联网技术标准都出自IETF。详细信息参考：&lt;a href=&quot;http://www.ietf.org/&quot;&gt;IETF&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;rfc&quot;&gt;RFC&lt;/h3&gt;

&lt;p&gt;IETF（互联网工程任务组）产生两种文件，一个叫Internet Draft，即”互联网草案”，另一个叫RFC（Request For Comments，意见征求书、请求注解书），RFC相对Draft更为正式，一般情况下，RFC文档发布后，其内容不再做变动。&lt;/p&gt;

&lt;p&gt;[O’Reilly - HTTP Pocket Reference]:		
[Sams - HTTP Developers Handbook]:		&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Linux的环境变量</title>
     <link href="http://ningg.github.com/linux-env-var"/>
     <updated>2014-07-28T00:00:00+08:00</updated>
     <id>http://ningg.github.com/linux-env-var</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近某个需求，要去修改jar包内的配置文件，中间几个细节不想多说，但期间有个需求是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将Linux自带的JDK由OpenJDK升级为Oracle(Sun)版本的JDK；&lt;/li&gt;
  &lt;li&gt;要求所有用户都能使用Oracle(Sun)版本的JDK；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;安装软件&lt;/h2&gt;

&lt;p&gt;这次把软件的安装过程拿出来，为了说明几件小事：Linux下安装软件最好通过已成符号链接文件进行，以方便软件今后的升级；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 将jdk的压缩文件解压到目录/usr/java下，解压之后文件夹为jdk-7u51-linux-x64
tar -zxvf jdk-7u51-linux-x64.gz -C /usr/java
// 在目录/usr/java下新建一个符号连接default
ln -n jdk-7u51-linux-x64 default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面添加环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim ~/.bashrc
// 添加环境变量JAVA_HOME（要求：对所有用户有效）
export JAVA_HOME=/usr/java/default
// 将java添加到PATH中（要求：对所有用户有效）
export PATH=$JAVA_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：上面使用符号链接文件的方式，来设置软件安装路径，方便软件升级，很巧妙，仔细体会一下。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;环境变量&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;简介&lt;/h3&gt;

&lt;p&gt;变量的作用范围一般是某个进程（正在运行的程序）之内，如果希望多个进程共享这个变量，也是可以的，将这个变量设置为&lt;code&gt;环境变量&lt;/code&gt;即可。&lt;/p&gt;

&lt;p&gt;上面可以看出：环境变量是在某个进程中设置的，而且，目标是希望其他进程共享。&lt;/p&gt;

&lt;p&gt;设置环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export JAVA_HOME=/usr/java/default
export PATH=$PATH:$JAVA_HOME/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;作用范围&lt;/h3&gt;

&lt;p&gt;当前系统中设置的环境变量，两个基本问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;环境变量在哪设置的？&lt;/li&gt;
  &lt;li&gt;它的作用范围是什么？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;环境变量&lt;/code&gt;是在一个bash进程中定义的，其作用范围是当前进程以及当前进程的所有子进程。&lt;/p&gt;

&lt;p&gt;根据范围大小，可以设置一些环境变量：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;所有bash进程共享的环境变量；&lt;/li&gt;
  &lt;li&gt;某个用户独享的环境变量；&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;/etc/profile：整个系统共享的环境变量；&lt;/li&gt;
  &lt;li&gt;~/.bash_profile 或者 ~/.bash_login 或者 ~/.profile 或者 ~/.bashrc，各个用户独享的环境变量；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（详解：各个文件加载过程？以及各个文件的用途，为什么要分这么多文件/层次来加载？等待补充）&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;《鸟哥私房菜（第三版）》 第11章 认识和学习BASH&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>Linux下用户和组管理</title>
     <link href="http://ningg.github.com/linux-user-and-group"/>
     <updated>2014-07-27T00:00:00+08:00</updated>
     <id>http://ningg.github.com/linux-user-and-group</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;平日里，常遇到几个需求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Linux服务器上，为新人开个账号，并加入到某一组中；&lt;/li&gt;
  &lt;li&gt;查询，组中的所有用户；&lt;/li&gt;
  &lt;li&gt;查询，用户是否存在；&lt;/li&gt;
  &lt;li&gt;查询，某一用户所在组；&lt;/li&gt;
  &lt;li&gt;用户和组管理，如何实现的；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;如何使用&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;几个命令&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;用户相关&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;useradd [LOGIN]&lt;/code&gt;：新增用户&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;passwd [LOGIN]&lt;/code&gt;：设置用户密码&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;usermod [options] [LOGIN]&lt;/code&gt;：修改用户的属性信息，与&lt;code&gt;useradd&lt;/code&gt;类似&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;userdel [LOGIN]&lt;/code&gt;：删除用户&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;whoami&lt;/code&gt;：当前登录的用户&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;用户组相关&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;groups [LOGIN]&lt;/code&gt;：查询用户所属组&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;groupadd [GROUP]&lt;/code&gt;：新增用户组&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;gpasswd [GROUP]&lt;/code&gt;：设置组成员、添加组管理员（参考命令：&lt;code&gt;usermod&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;groupmod [GROUP]&lt;/code&gt;：修改用户组信息，与&lt;code&gt;groupadd&lt;/code&gt;类似&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;groupdel [GROUP]&lt;/code&gt;：删除组&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;newgrp [GROUP]&lt;/code&gt;：设置&lt;code&gt;有效组&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注：作为&lt;code&gt;初始组&lt;/code&gt;的用户组，无法使用命令&lt;code&gt;groupdel&lt;/code&gt;进行删除。&lt;/p&gt;

&lt;p&gt;上面的命令，细节不想多说，用的时候，直接&lt;code&gt;man command&lt;/code&gt;查看帮助文档即可。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;几个文件&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;文件&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;/etc/passwd&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用户信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;/etc/shadow&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用户密码信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;/etc/group&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用户组信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;/etc/gshadow&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用户组管理信息&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;etcpasswd&quot;&gt;/etc/passwd&lt;/h4&gt;

&lt;p&gt;文件片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
hbase:x:1002:507::/home/hbase:/bin/bash
nagios:x:1003:508::/home/nagios:/bin/bash
oozie:x:1004:507::/home/oozie:/bin/bash
hcat:x:1005:507::/home/hcat:/bin/bash
hive:x:1006:507::/home/hive:/bin/bash
yarn:x:1007:507::/home/yarn:/bin/bash
hdfs:x:1008:507::/home/hdfs:/bin/bash
mapred:x:1009:507::/home/mapred:/bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式说明:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`用户名`:`密码`:`UID`:`GID`:`用户说明信息`:`默认登录路径`:`Shell`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;补充说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;密码&lt;/code&gt;列，是历史遗留问题，现在所有的&lt;code&gt;密码&lt;/code&gt;，都已被单独的提出并存储至&lt;code&gt;/etc/passwd&lt;/code&gt;文件中；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;UID&lt;/code&gt;=0，表示系统管理员；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;GID&lt;/code&gt;，与文件&lt;code&gt;/etc/group&lt;/code&gt;有关，这个文件用于规范组名和GID的对应关系；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Shell&lt;/code&gt;，用户登录之后，就会获得一个Shell进程来与系统核心进行沟通，以进行用户的操作任务；&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;etcshadow&quot;&gt;/etc/shadow&lt;/h4&gt;

&lt;p&gt;文件片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root:$6$t...(实际密码较长):15996:0:99999:7:::
bin:*:15422:0:99999:7:::
sshd:!!:15977::::::
dev:!!:15989:0:99999:7:::
devp:$6$...(实际密码较长):15989:0:99999:7:::
mysql:!!:15990::::::
storm:$6$2...(实际密码较长):15991:0:99999:7:::
strom:!!:15991:0:99999:7:::
ambari-qa:!!:16262:0:99999:7:::
hbase:!!:16262:0:99999:7:::
nagios:!!:16262:0:99999:7:::
oozie:!!:16262:0:99999:7:::
hcat:!!:16262:0:99999:7:::
hive:!!:16262:0:99999:7:::
yarn:!!:16262:0:99999:7:::
hdfs:!!:16262:0:99999:7:::
mapred:!!:16262:0:99999:7:::
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式说明(&lt;code&gt;:&lt;/code&gt;分隔各个列)：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;用户名&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;密码&lt;/code&gt;：是加密后的结果，但仍有可能被破解；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;最近改动密码日期&lt;/code&gt;：单位：天，从1970.01.01算起的天数；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;密码不可被改动的天数&lt;/code&gt;：多少天内不能修改；如果为0，表示随时可以更改；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;密码需要重新改动的天数&lt;/code&gt;：多少天内需要修改再次密码；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;需要变更前的警告天数&lt;/code&gt;：在&lt;code&gt;密码需要重新改动的天数&lt;/code&gt;到来之前，提前显示警告信息；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;密码过期后帐号宽限期&lt;/code&gt;：在&lt;code&gt;密码需要重新改动的天数&lt;/code&gt;到来之前，都没有修改密码，那么还有机会，在宽限期内，用户登录，系统会强制用户必须重新设定密码；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;帐号失效日期&lt;/code&gt;：单位：天，从1970.01.01算起的天数；过了这一天，帐号当即失效；&lt;/li&gt;
  &lt;li&gt;（保留）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;补充说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;密码&lt;/code&gt;列，是加密后的结果，但仍有可能被破解；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;最近改动密码日期&lt;/code&gt;列，单位：天，从1970.01.01算起的天数；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;密码不可被改动的天数&lt;/code&gt;列，从&lt;code&gt;最近改动密码日期&lt;/code&gt;向后推迟的天数，如果为0，表示随时可以更改；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;密码需要重新改动的天数&lt;/code&gt;列，强制用户在多少天内必须修改密码；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;chage -l [LOGIN]&lt;/code&gt;命令，可用于查询用户密码相关的详细信息；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;小提示：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有趣的功能：用户第一次登录后，强制其修改密码后才能使用系统资源.
具体命令：&lt;code&gt;chage -d 0 [LOGIN]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;etcgroup&quot;&gt;/etc/group&lt;/h4&gt;

&lt;p&gt;文件片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hadoop:x:507:hbase,hdfs,mapred
nagios:x:508:
mailnull:x:47:
smmsp:x:51:
hdfs:x:481:devp
hbase:x:480:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`组名`:`群组密码`:`GID`:`组内成员`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;补充说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在上面文件片段中，如果想将用户nagios，添加到hdfs组中，则，只需在hdfs的&lt;code&gt;组内成员&lt;/code&gt;列中添加&lt;code&gt;,nagios&lt;/code&gt;即可；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;id&lt;/code&gt;命令，可查询用户组的详细信息；（类似&lt;code&gt;groups&lt;/code&gt;命令）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;疑问：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有的账户，在&lt;code&gt;/etc/passwd&lt;/code&gt;中，看出其&lt;code&gt;GID&lt;/code&gt;项为507，而在&lt;code&gt;/etc/group&lt;/code&gt;中&lt;code&gt;GID&lt;/code&gt;=507的组内成员中，并没有看到这些账户？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个涉及到&lt;code&gt;有效组（effective group）&lt;/code&gt;和&lt;code&gt;初始组（initial group）&lt;/code&gt;的概念，请往下继续看。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;有效组（effective group） vs. 初始组（initial group）&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;文件&lt;code&gt;/etc/passwd&lt;/code&gt;中，每个用户对应有且只有一个&lt;code&gt;GID&lt;/code&gt;，这是&lt;code&gt;初始组&lt;/code&gt;，即用户一登入系统，立即拥有这个群组的权限；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;初始组&lt;/code&gt;，不需要在&lt;code&gt;/etc/group&lt;/code&gt;文件的&lt;code&gt;组内成员&lt;/code&gt;中写入该用户（也可以写入）；&lt;/li&gt;
  &lt;li&gt;若用户还属于&lt;code&gt;非初始组&lt;/code&gt;，则，在&lt;code&gt;/etc/group&lt;/code&gt;文件的&lt;code&gt;组内成员&lt;/code&gt;部分进行标识；&lt;/li&gt;
  &lt;li&gt;用户新建一个文件，这个文件属于&lt;code&gt;有效组&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;groups&lt;/code&gt;命令，查询出的组中，第一个组为&lt;code&gt;有效组&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;用户登录之后，&lt;code&gt;newgrp [GROUP]&lt;/code&gt;命令，可以切换有效组；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;额外，需要说明一下&lt;code&gt;newgrp [GROUP]&lt;/code&gt;，其实质上是有启动了一个shell，来实现切换&lt;code&gt;有效组&lt;/code&gt;的，具体如下：&lt;/p&gt;

&lt;p&gt;如何将用户添加到组中呢？两种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;root用户，使用命令：&lt;code&gt;usermod&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;组管理员，使用命令：&lt;code&gt;gpasswd&lt;/code&gt;；（下文会介绍）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有个问题，记录一下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;疑问：命令&lt;code&gt;newgrp&lt;/code&gt;会重新启动一个shell，shell是kernel之外的一层壳，shell与进程、线程之间什么关系？shell是如何调用内核？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（之前APUE课程上，有个课下作业：写一个自己的shell，类似bash）&lt;/p&gt;

&lt;h4 id=&quot;etcgshadow&quot;&gt;/etc/gshadow&lt;/h4&gt;

&lt;p&gt;文件片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hadoop:!::hbase,hdfs,mapred
nagios:!::
mailnull:!::
smmsp:!::
hdfs:!::
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`组名`:`组密码`:`组管理员帐号`:`组内成员`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;补充说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;组密码&lt;/code&gt;为&lt;code&gt;!&lt;/code&gt;，表示无合法密码，无组管理员；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;组内成员&lt;/code&gt;，与&lt;code&gt;/etc/group&lt;/code&gt;文件中内容相同；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体添加组内成员、设置组的管理员，使用命令：&lt;code&gt;gpasswd&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;特别提示&lt;/h4&gt;

&lt;p&gt;使用&lt;code&gt;useradd&lt;/code&gt;、&lt;code&gt;passwd&lt;/code&gt;等命令添加用户，并为用户设置用户组之后，如果想修改用户的信息，两条途径：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;直接修改&lt;code&gt;/etc/passwd&lt;/code&gt;和&lt;code&gt;/etc/shadow&lt;/code&gt;文件中相应字段；&lt;/li&gt;
  &lt;li&gt;使用&lt;code&gt;usermod&lt;/code&gt;命令进行修改；&lt;strong&gt;[推荐]&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-5&quot;&gt;深入原理&lt;/h2&gt;

&lt;h3 id=&quot;section-6&quot;&gt;为什么存在用户和用户组&lt;/h3&gt;

&lt;p&gt;主机放在这，谁都想用，如果所有人（UserA\UserB\UserC）都使用同一个帐号登录，则，大家都没有隐私可言，而且UserA的文件可能会被UserB给删除；这就要求创建多个帐号（用户），UserA\UserB\UserC每人使用一个不同的帐号来登陆，这样大家的文件就相互隔离了；问题又来了，UserA想与UserB共享文件FileA，但是不想与UserC共享这一文件怎么办？这就产生了&lt;code&gt;用户组&lt;/code&gt;这一概念，只需要UserA\UserB同属某个用户组GroupA，然后设置组GroupA内的人都有权操作FileA就可以了。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;具体实现原理&lt;/h3&gt;

&lt;p&gt;用户登录时，输入&lt;code&gt;用户名&lt;/code&gt;和&lt;code&gt;密码&lt;/code&gt;，实际上，Linux主机是按照 &lt;code&gt;UID&lt;/code&gt;（User ID） 来识别用户的，&lt;code&gt;用户名&lt;/code&gt;是为便于人们记忆才存在的。
同理，Linux主机只识别&lt;code&gt;GID&lt;/code&gt;（Group ID）来标识&lt;code&gt;用户组&lt;/code&gt;。具体，使用&lt;code&gt;ls -l&lt;/code&gt;命令查询文件详情时，系统会按照&lt;code&gt;GID&lt;/code&gt;和&lt;code&gt;UID&lt;/code&gt;分别去文件&lt;code&gt;/etc/group&lt;/code&gt;和&lt;code&gt;/etc/passwd&lt;/code&gt;中查询相应的&lt;code&gt;用户组&lt;/code&gt;和&lt;code&gt;用户&lt;/code&gt;的名字并显示出来。&lt;/p&gt;

&lt;p&gt;上面一段话，总结：系统上文件属性、权限等存储的都是&lt;code&gt;UID&lt;/code&gt;和&lt;code&gt;GID&lt;/code&gt;，只有在登录、显示时，才会用到&lt;code&gt;用户名&lt;/code&gt;和&lt;code&gt;用户组名&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;《鸟哥私房菜基础篇（第三版）》 第6章 Linux的档案权限与目录配置&lt;/li&gt;
  &lt;li&gt;《鸟哥私房菜基础篇（第三版）》 第14章 Linux帐号管理与ACL权限设定&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>HDFS:Hadoop Distributed File System简介</title>
     <link href="http://ningg.github.com/hdfs-intro"/>
     <updated>2014-07-14T00:00:00+08:00</updated>
     <id>http://ningg.github.com/hdfs-intro</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近要做一件事：调研远端节点向HDFS上传/下载文件的方法，并确定一个高效率的方案，这个最终方案初步确定了WebHDFS REST API方式，不过一些HDFS内部的实现细节/原理，自己很想一窥究竟，OK，既然有这份心情，那就走起，趁热打铁、一鼓作气。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;文件系统&lt;/h2&gt;

&lt;p&gt;为了实现多个应用可以并发的向存储介质上写入信息，出现了文件（File）这一概念，即把信息以一种单元（File，文件）的形式存储在介质上。文件是一个命名的、存储在设备上的信息的线性字节流。对文件的管理，包括文件的逻辑组成结构、命名、操作（读、写、删除）、权限管理、具体实现（如何组织存储区域），称为&lt;code&gt;文件系统&lt;/code&gt;（FileSystem，FS）。&lt;/p&gt;

&lt;p&gt;总结一下，文件系统需要解决文件相关的几个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;怎么找到文件？（文件的命名）&lt;/li&gt;
  &lt;li&gt;可以对文件进行哪些操作？（读、写、删除、复制等）&lt;/li&gt;
  &lt;li&gt;哪些人可以对这个文件进行操作？（权限管理）&lt;/li&gt;
  &lt;li&gt;为保证上面的功能，并且，兼顾文件读写等操作的效率，逻辑上，一个文件可以划分为几个部分？（逻辑组成结构）&lt;/li&gt;
  &lt;li&gt;说一千道一万，上面这些东西，如何在物理磁盘上实现？（具体实现）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;无结构的文件 vs. 结构化的文件&lt;/p&gt;

&lt;p&gt;无结构的文件：大部分文件系统，不关系文件里保存的数据，把文件内容作为无结构的字节序列保存。也有一些文件系统支持结构化的文件，以记录为单位组织信息，免去文件系统使用者将“原始的”字节流转换成记录流的麻烦。&lt;/p&gt;

&lt;p&gt;一个文件，通常包含：文件名和文件数据，还包括，创建日期、文件长度、引用计数等额外信息，通常将这些额外项，称为文件属性，也称文件元数据。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;目录与目录树&lt;/h3&gt;

&lt;p&gt;如何找到一个文件呢？为了能够高效地找到文件，引入了“目录”这一概念。“目录”，又称“文件夹”，就是一个虚拟容器，其内部可能包含着一组文件和其他的目录（子目录）。目录和子目录，就形成了一个层次结构，称为目录树。&lt;/p&gt;

&lt;p&gt;为什么要有目录？没有行不行？没有目录可以，但是文件命名就比较麻烦，因为没有目录，所有的文件都不能同名，哪怕是简单的 &lt;code&gt;index.html&lt;/code&gt;、&lt;code&gt;default.css&lt;/code&gt;等文件也都只能有一个，所以说，本质上，目录实现了文件命名空间的分割，不同命名空间内，可以有同名文件存在。&lt;/p&gt;

&lt;p&gt;不同物理磁盘上，格式化得到的多个文件系统，可以相互挂载（嫁接），例如两个文件系统 FS1 和 FS2 ，将 FS2 挂载到 FS1 的 &lt;code&gt;/home&lt;/code&gt; 目录下，则，可以通过 &lt;code&gt;/home/user1&lt;/code&gt;
访问原来 FS2 上的 &lt;code&gt;/user1&lt;/code&gt; 目录。有一点需要说明的是：原来 FS1 目录 &lt;code&gt;/home&lt;/code&gt; 下的所有内容，都被隐藏而无法访问了，但是将 FS2 从 FS1 上卸载之后，仍能正常访问。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;文件系统的实现&lt;/h3&gt;

&lt;p&gt;文件，是逻辑上的概念，其实际上在物理磁盘上是如何存储的呢？&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;常见问题&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;小文件个数多&lt;/h3&gt;

&lt;p&gt;HDFS支持超大文件（几百MB、几百GB、甚至TB=1024GB、PB=1024TB的文件），是通过将数据分布在数据节点（DataNode），并且将文件的元数据（目录树结构、文件-数据块索引等信息）存放在名字节点（NameNode）上，来实现的。名字节点（NameNode）的内存大小，决定了HDFS可以保存的文件数量；虽然现在内存数量比较大，但大量的小文件仍然严重影响名字节点（NameNode）的性能。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;《Hadoop技术内幕：深入解析Hadoop Common和HDFS架构的设计和实现原理》&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>LVM入门介绍</title>
     <link href="http://ningg.github.com/lvm-intro"/>
     <updated>2014-07-10T00:00:00+08:00</updated>
     <id>http://ningg.github.com/lvm-intro</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;这两天重装Hadoop，由Intel发行版本（试用）变更为Hortonworks发行版本（试用），这样，我需要卸载原始Intel版本的Hadoop，最好将HDFS存储数据的分区进行格式化。使用 &lt;code&gt;lsblk&lt;/code&gt; 查看了一下，当前机器上磁盘分区 &lt;code&gt;/dev/sda&lt;/code&gt; 的结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# lsblk
NAME                            MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda                               8:0    0 558.9G  0 disk
├─sda1                            8:1    0   500M  0 part /boot
└─sda2                            8:2    0 558.4G  0 part
  ├─vg_localhost-lv_root (dm-0) 253:0    0    50G  0 lvm  /
  ├─vg_localhost-lv_swap (dm-1) 253:1    0  15.7G  0 lvm  [SWAP]
  └─vg_localhost-lv_home (dm-2) 253:2    0 492.7G  0 lvm  /home
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在有个问题，上面 &lt;code&gt;lv_root&lt;/code&gt;、&lt;code&gt;lv_swap&lt;/code&gt;、&lt;code&gt;lv_home&lt;/code&gt; 都是什么分区？其 &lt;code&gt;TYPE=lvm&lt;/code&gt;，那LVM到底是怎么回事？&lt;/p&gt;

&lt;p&gt;还有几个问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# df -hT
文件系统    					  类型   容量  已用  可用 已用%% 挂载点
/dev/mapper/vg_localhost-lv_root  ext4   50G   17G   31G   36%   /
tmpfs        					  tmpfs  16G   60K   16G   1%    /dev/shm
/dev/sda1   					  ext4   485M  38M   422M  9%    /boot
/dev/mapper/vg_localhost-lv_home  ext4   485G  156G  305G  34%   /home
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面 &lt;code&gt;df -hT&lt;/code&gt; 命令查询查询结果中:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;/dev/mapper/vg_localhost-lv_home&lt;/code&gt; 与之前lsblk查询得知的 &lt;code&gt;/sda2/vg_localhost-lv_home&lt;/code&gt; 之间什么关系？&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;tmpfs&lt;/code&gt; 与之前 &lt;code&gt;vg_localhost-lv_swap [SWAP]&lt;/code&gt; 之间的关系？&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>maven坐标和依赖</title>
     <link href="http://ningg.github.com/maven-coordinate"/>
     <updated>2014-07-07T00:00:00+08:00</updated>
     <id>http://ningg.github.com/maven-coordinate</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;题记：&lt;a href=&quot;http://www.infoq.com/cn/minibooks/maven-in-action&quot;&gt;《Maven实战（迷你版）》&lt;/a&gt;这本书写的太好了，我忍不住把其中的内容又敲一遍。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;maven&quot;&gt;何为Maven坐标&lt;/h3&gt;

&lt;p&gt;Maven来管理项目依赖。为了能自动化解析任何一个java构建，Maven必须将他们唯一标识，这是依赖管理的基础——坐标（coordinate）。本文将详细介绍Maven坐标的作用，并在此基础上介绍Maven的配置。&lt;/p&gt;

&lt;p&gt;Maven坐标的元素包括：&lt;code&gt;groupId&lt;/code&gt;，&lt;code&gt;artifactId&lt;/code&gt;，&lt;code&gt;version&lt;/code&gt;，&lt;code&gt;packaging&lt;/code&gt;，&lt;code&gt;classifier&lt;/code&gt;。根据坐标，Maven能够从中央仓库（http://repo1.maven.org/maven2）中，找出java构件并进行下载。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;坐标详解&lt;/h3&gt;

&lt;p&gt;先看一个坐标定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;groupId&amp;gt;org.sonatype.nexus&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;nexus-indexer&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;2.0.0&amp;lt;/version&amp;gt;
&amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码中，并没有classifier。下面详细解释一下各个坐标元素：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;groupId&lt;/strong&gt;；定义当前Maven项目所属的实际项目。首先，Maven项目与实际项目不是一一对应的关系，因为Maven中有一个模块的概念，因此实际的项目会被分为很多模块，比如，SpringFramework实际项目对应的maven项目有spring-core，spring-context等。其次，groupId不应对应到项目所属的组织或公司，原因很简单，一个组织下有很多实际项目，每个项目又要包含很多模块（Maven项目），应将groupId指定到实际项目，然后，通过artifactId来定义项目模块，并以此作为一个Maven项目。最后，groupId与java包名的表示方式类似，通常与域名反向一一对应。上述例子中，groupId为org.sonatype.nexus，其中，org.sonatype表示Sonatype公司建立的一个非营利组织，nexus表示Nexus这一实际项目，该groupId与实际域名nexus.sonatype.org对应。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;artifactId&lt;/strong&gt;：对应实际项目中的一个模块（Maven项目），推荐使用实际项目名最为前缀，例如，nexus-indexer，使用实际nexus作为前缀，这样的好处是方便寻找实际构建。默认情况下，Maven生成的构建，以 &lt;code&gt;artifactId-version.packaging&lt;/code&gt; 格式命名，以实际项目名命名，方便区分不同项目。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;version&lt;/strong&gt;：标识当前Maven项目的版本。特别说明：Maven定义了一套完整的版本规范，以及快照（SNAPSHOT）的概念，后文会涉及到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;packaging&lt;/strong&gt;：声明项目打包方式。首先，其常作为生成构件的扩展名，例如，jar，war；其次，打包方式会影响到构建过程的声明周期，比如，jar打包、war打包使用不同的命令；最后，不定义packaging时，默认jar。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;classifier&lt;/strong&gt;：&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>maven使用入门</title>
     <link href="http://ningg.github.com/maven-intro"/>
     <updated>2014-07-04T00:00:00+08:00</updated>
     <id>http://ningg.github.com/maven-intro</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;题记：&lt;a href=&quot;http://www.infoq.com/cn/minibooks/maven-in-action&quot;&gt;《Maven实战（迷你版）》&lt;/a&gt;这本书写的太好了，我忍不住把其中的内容又敲一遍。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;0. 背景&lt;/h2&gt;

&lt;p&gt;今天在GitHub上找了一个java语言编写的HDFS client，其使用Maven来进行工程的管理和构建；作为Maven工程导入Eclipse，提示pom.xml相关错误近10条。&lt;/p&gt;

&lt;p&gt;好吧，pom.xml是Maven的配置文件，看来Maven逃脱不了关系了。（之前，多次接触/使用Maven，不过都没有整理资料，导致每次使用都需要重新学习，如此反复，浪费时间，引以为戒，故有此博客）。&lt;/p&gt;

&lt;p&gt;要学东西，需要先找些可靠、严谨的书籍，大概搜索了一下，&lt;a href=&quot;http://www.juvenxu.com/mvn-in-action/&quot;&gt;《Maven实战》&lt;/a&gt; 的评价较高，那就他了。 一两天内，也无法拿到纸质版的书籍，索性在InfoQ上找了一个&lt;a href=&quot;http://www.infoq.com/cn/minibooks/maven-in-action&quot;&gt;《Maven实战（迷你版）》&lt;/a&gt;。 &lt;/p&gt;

&lt;h3 id=&quot;maven&quot;&gt;0.1 Maven是什么？能做什么？&lt;/h3&gt;

&lt;p&gt;在开始正式介绍之前，还总结一下Maven到底能做什么吧，所谓&lt;strong&gt;学以致用&lt;/strong&gt;，还是希望能够在今后的开发中，把Maven用起来的。&lt;/p&gt;

&lt;p&gt;Maven能做什么？&lt;/p&gt;

&lt;h2 id=&quot;maven-1&quot;&gt;1. Maven的安装与配置&lt;/h2&gt;

&lt;h3 id=&quot;maven-2&quot;&gt;1.1 Maven的安装&lt;/h3&gt;

&lt;p&gt;从Maven官网下载软件，根据官方文档安装即可。基本步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下载并解压文件；&lt;/li&gt;
  &lt;li&gt;添加环境变量：&lt;code&gt;$M2_HOME&lt;/code&gt;=&lt;code&gt;Maven安装目录&lt;/code&gt;，并将&lt;code&gt;$M2_HOME/bin&lt;/code&gt;添加到&lt;code&gt;$PATH&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;：安装软件，就不可避免会遇到软件版本升级问题，现有较成熟的方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;win环境下，升级新版本的软件后，直接修改环境变量，指向新版本目录即可；&lt;/li&gt;
  &lt;li&gt;Linux环境下，升级软件版本之后，修改环境变量；&lt;/li&gt;
  &lt;li&gt;特别说明：Linux下，还有更简便的办法：在软件安装目录下，新建一个符号链接文件，环境变量指向此文件，软件升级后，只需更新此符号链接文件即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Linux下，使用符号链接文件，来作为软件升级方案：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#新建符号链接apache-maven，指向apache-maven-3.0文件
ln -s apache-maven-3.0 apache-maven

#在配置文件~/.bashrc中，添加环境变量
export M2_HOME=/home/devp/apache-maven
export PATH=$M2_HOME/bin:$PATH

#升级软件时，更新符号连接文件apache-maven
rm apache-maven
ln -s apache-maven-3.1 apache-maven
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.2 安装目录分析&lt;/h3&gt;

&lt;p&gt;前文简要说明了Maven的安装与升级步骤，现在我们简要分析一下Maven的安装文件。&lt;/p&gt;

&lt;h4 id=&quot;m2home&quot;&gt;安装目录：M2_HOME&lt;/h4&gt;

&lt;p&gt;前面的讲解中，我们都是将环境变量&lt;code&gt;M2_HOME&lt;/code&gt;指向Maven的安装目录，本文之后所有使用&lt;code&gt;M2_HOME&lt;/code&gt;的地方都代表了该安装目录，让我们看一下该目录的安装结构和内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|--bin
|   |--m2.conf
|   |--mvn
|   |--mvnDebug
|
|--boot
|   |--plexus-classworlds-xxx.jar
| 	
|--conf
|   |--settings.xml
|   |--logging
|       |--simplelogger.properties
|
|--lib
|   |--... ...
|
|--LICENSE
|--NOTICE
|--README.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;bin&lt;/strong&gt;：该目录包含了mvn运行的脚本，用来配置java命令，准备好classpath和相关的java命令参数，然后执行java命令。其中包含了mvn和mvnDebug两类脚本，打开来查看，就会看到mvnDebug只是比mvn多一条MAVEN_DEBUG_OPTS配置，作用就是在运行Maven时开启debug，方便调试Maven自身。此外，该目录还包含m2.conf文件，这是classworlds的配置文件，如果有必要，下文会对其进行介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;boot&lt;/strong&gt;：以Maven 3.2.2为例，其中只包含了一个jar包plexus-classworlds-2.5.1.jar。这是一个类加载器框架，相对于默认的java类加载器，它提供了丰富的语法以方便配置，Maven使用该框架加载自己的类库。更多关于classworlds的信息请参考&lt;a href=&quot;http://classworlds.codehaus.org&quot;&gt;http://classworlds.codehaus.org&lt;/a&gt;。 对于普通的Maven用户，不必关心这一文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;conf&lt;/strong&gt;：该目录包含了一个非常重要的配置文件settings.xml，直接修改此文件，能够在机器上，全局定制Maven的行为。一般情况下，我们更偏向于复制该文件到 &lt;code&gt;~/.m2/&lt;/code&gt; 目录下（此处 &lt;code&gt;~&lt;/code&gt; 代表用户目录），然后修改该配置文件，在用户范围内定制Maven行为。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;lib&lt;/strong&gt;：该目录包含了Maven运行所需的各类java类库，Maven本身是分模块开发的，因此用户能够看到诸如：maven-compact-3.2.2.jar、maven-core-3.2.2.jar、maven-model-3.2.2.jar等文件，此外这里含包含了一些Maven用到的第三方依赖，例如：guava-14.0.1.jar、commons-cli-1.2.jar等。（对于Maven2来说，该目录只包含一个如maven-2.2.1-uber.jar的文件，它是由原本相互独立的jar文件的Maven模块以及依赖的第三方类库拆解后，重新合并而成的）。可以说，这个目录才是真正的Maven。&lt;/p&gt;

&lt;p&gt;其他几个文件的简介：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LICENSE：记录了Maven使用的软件许可证，Apache License Version 2.0。&lt;/li&gt;
  &lt;li&gt;NOTICE：记录了Maven的发行机构。&lt;/li&gt;
  &lt;li&gt;README.txt：包含了Maven的简要介绍、安装步骤以及参考资料的链接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;m2&quot;&gt;本地仓库：~/.m2目录&lt;/h4&gt;

&lt;p&gt;安装完Maven之后，运行命令&lt;code&gt;mvn help:system&lt;/code&gt; ，该命令打印出所有的Java系统属性和环境变量，这些信息对我们日常的编程工作很有帮助。这条命令执行之后，可以看到Maven会下载&lt;code&gt;maven-help-plugin&lt;/code&gt;，包括pom文件和jar文件，这些文件都被存储在本地仓库中。&lt;/p&gt;

&lt;p&gt;打开当前登录用户的主目录（即，用户目录），下文使用&lt;code&gt;~&lt;/code&gt; 来表示用户目录。在用户目录下，可以看到 &lt;code&gt;.m2&lt;/code&gt; 目录。默认情况下，该文件夹下放置了Maven本地仓库：&lt;code&gt;.m2/repository&lt;/code&gt; 。所有的Maven构建（artifact）都被存储在本仓库中，以方便重用。我们可以在&lt;code&gt;~/.m2/repository/org/apache/maven/plugins/maven-help-plugins/&lt;/code&gt; 目录下，找到刚才下载的pom文件和jar文件（两文件缺一不可）。Maven根据几套规则来确定任何一个构建（artifact）在仓库中的位置。&lt;strong&gt;特别说明&lt;/strong&gt;：由于Maven仓库是通过简单文件系统，透明地展示给Maven用户的，有时候可以绕过Maven直接查看或修改仓库文件，在遇到疑难问题时，这往往十分有用。&lt;/p&gt;

&lt;h3 id=&quot;http&quot;&gt;1.3 配置HTTP代理&lt;/h3&gt;

&lt;p&gt;有时候公司处于安全考虑，要求通过安全认证的代理访问因特网。这就要求设置Maven通过HTTP代理方式，来访问外网的仓库，以下载所需的资源。&lt;/p&gt;

&lt;p&gt;确认当前代理可用，然后编辑 &lt;code&gt;~\.m2\settings.xml&lt;/code&gt; 文件（如果没有这一文件，就将&lt;code&gt;$M2_HOME\conf\settings.xml&lt;/code&gt; 复制过来）。添加代理配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;proxies&amp;gt;
   &amp;lt;!-- proxy
    | Specification for one proxy, to be used in connecting to the network.
    |--&amp;gt;
   &amp;lt;proxy&amp;gt;
     &amp;lt;id&amp;gt;optional&amp;lt;/id&amp;gt;
     &amp;lt;active&amp;gt;true&amp;lt;/active&amp;gt;
     &amp;lt;protocol&amp;gt;http&amp;lt;/protocol&amp;gt;
     &amp;lt;!-- 
     &amp;lt;username&amp;gt;proxyuser&amp;lt;/username&amp;gt;
     &amp;lt;password&amp;gt;proxypass&amp;lt;/password&amp;gt;
     --&amp;gt;
     &amp;lt;host&amp;gt;proxy.host.net&amp;lt;/host&amp;gt;
     &amp;lt;port&amp;gt;80&amp;lt;/port&amp;gt;
     &amp;lt;nonProxyHosts&amp;gt;local.net|some.host.com&amp;lt;/nonProxyHosts&amp;gt;
   &amp;lt;/proxy&amp;gt;
&amp;lt;/proxies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代理的配置方式十分简单，porxies下可以配置多个proxy，如果声明了多个proxy元素，默认第一个proxy被激活，否则active值为true表示被激活。当代理服务需要认证时，需要配置username和password。nonProxyHosts元素用于指定哪些主机名不需要代理，可以使用 &lt;code&gt;|&lt;/code&gt; 来分隔多个主机名。此外，该配置也支持通配符，例如，*.google.com表示所有以google.com结尾的域名访问都不通过代理。&lt;/p&gt;

&lt;h3 id=&quot;eclipsemaven&quot;&gt;1.4 安装Eclipse的Maven插件&lt;/h3&gt;

&lt;p&gt;对于一个稍微大一点的项目来说，没有IDE是不可想象的，还好很多IDE都有Maven的插件。&lt;/p&gt;

&lt;p&gt;Eclipse平台下，插件名称：m2eclipse，我下载的Eclispe版本中，默认已经安装了此插件，因此，本文不暂讨论此问题。&lt;/p&gt;

&lt;h3 id=&quot;maven-3&quot;&gt;1.5 Maven安装最佳实践&lt;/h3&gt;

&lt;p&gt;本节介绍一些配置要点，在Maven安装过程中，这些要点是非必要的，但这些要点却比较实用。&lt;/p&gt;

&lt;h4 id=&quot;settingsxml&quot;&gt;1.5.1 配置用户范围的settings.xml&lt;/h4&gt;

&lt;p&gt;Maven用户可以选择配置 &lt;code&gt;$M2_HOME/settings.xml&lt;/code&gt; 或者 &lt;code&gt;~/.m2/settings.xml&lt;/code&gt; 。前者是全局范围的配置，整台机器上的所有用户都会受这一配置的影响，而后者是用户范围的，只有当前用户会受到该配置的影响。&lt;/p&gt;

&lt;p&gt;推荐使用用户范围的配置，避免影响其他用户的配置，另一方面，也便于Maven升级：直接修改conf 目录下的settings.xml文件，这样每次升级时，都需要复制该文件，而如果使用&lt;code&gt;.m2/settings.xml&lt;/code&gt;，则升级时，不需要触动settings.xml文件。&lt;/p&gt;

&lt;h4 id=&quot;idemaven&quot;&gt;1.5.2 不使用IDE内嵌的Maven&lt;/h4&gt;

&lt;p&gt;无论Eclipse还是NetBeans，当我们集成Maven时，都会安装一个内嵌的Maven：一方面，这个Maven通常比较新，但不一定很稳定；另一方面，通常我们还需要使用Maven的命令行方式，如果两个Maven版本不同的话，可能造成项目构建过程不一致，这也是我们不希望看到的。因此，建议单独下载安装一个Maven，并将恰配置到IDE中。&lt;/p&gt;

&lt;p&gt;Eclipse下，配置Maven：&lt;code&gt;Windows&lt;/code&gt;–&lt;code&gt;Preferences&lt;/code&gt;–&lt;code&gt;Maven&lt;/code&gt;–&lt;code&gt;Installations&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.6 常见错误&lt;/h3&gt;

&lt;p&gt;这一节，记录一些可能会遇到的问题，以及解决办法。&lt;/p&gt;

&lt;h4 id=&quot;maven-project&quot;&gt;1.6.1 创建/导入 Maven Project&lt;/h4&gt;

&lt;p&gt;错误详情：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;An internal error occurred during: “Updating Maven Project”. Lorg/codehaus/plexus/archiver/jar/JarArchiver;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;解决办法：在pom.xml中&lt;code&gt;&amp;lt;project&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt;&lt;/code&gt;下添加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;plugin&amp;gt;
  &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新更新&lt;code&gt;Maven Project...&lt;/code&gt;（默认快捷键：&lt;code&gt;Alt + F5&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&quot;http://stackoverflow.com/questions/14491298/an-internal-error-occurred-during-updating-maven-dependencies&quot;&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;eclipsemavenjar&quot;&gt;1.6.2 Eclipse环境下，Maven报错找不到某些jar包&lt;/h4&gt;

&lt;p&gt;如果命令行方式下，使用&lt;code&gt;mvn&lt;/code&gt;的命令编译没有问题，而使用Eclipse时，&lt;code&gt;mvn install&lt;/code&gt;等出现问题，则，解决办法：在pom.xml中指定&lt;code&gt;&amp;lt;project&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt;&lt;/code&gt;内添加&lt;code&gt;&amp;lt;plugin&amp;gt;&lt;/code&gt;，设置成与命令行条件下&lt;code&gt;mvn&lt;/code&gt;调用的&lt;code&gt;&amp;lt;plugin&amp;gt;&lt;/code&gt;保持一致。&lt;a href=&quot;http://blog.csdn.net/imlmy/article/details/8268293&quot;&gt;参考1&lt;/a&gt;、&lt;a href=&quot;http://blog.csdn.net/huang86411/article/details/17548481&quot;&gt;参考2&lt;/a&gt;，当然还有另一种办法：&lt;a href=&quot;http://central.maven.org/maven2/org/apache/maven/plugins/&quot;&gt;手动下载jar和pom&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;疑问&lt;/strong&gt;：在POM中 &lt;code&gt;&amp;lt;project&amp;gt; &amp;lt;dependencies&amp;gt;&lt;/code&gt; 下添加 &lt;code&gt;&amp;lt;dependency&amp;gt;&lt;/code&gt;元素 和 &lt;code&gt;&amp;lt;project&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt;&lt;/code&gt; 下添加 &lt;code&gt;&amp;lt;plugin&amp;gt;&lt;/code&gt; 元素，有差异吗？有什么差异？（备注：当前调试结果，可得有差异）。&lt;/p&gt;

&lt;p&gt;如果当前使用了代理等方式导致网络连接局部受限，造成命令行方式 &lt;code&gt;mvn&lt;/code&gt;能够正常下载依赖的jar包，但在Eclipse环境下，无法下载所需的项目的依赖包，可以在命令行方式下，先进行下载，然后，在Eclipse下进行更新、运行即可。（命令行方式为主）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;思考&lt;/strong&gt;：Maven已经在settings.xml中配置了代理，那么，在Eclipse中开发调试Maven工程时，需要再配置Eclipse的代理吗？RE：不需要，只需要在Maven的配置中指定代理即可。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;2. 入门实例&lt;/h2&gt;

&lt;p&gt;在此之前，需要安装配置好Maven，如果要在Eclipse下建立Maven工程，则需要安装配置Eclipse下的Maven的插件。具体信息，参考：&lt;a href=&quot;/download/maven/Maven+in+action.pdf&quot;&gt;《Maven实战（迷你版）》&lt;/a&gt;中第一章 Maven的安装与配置。&lt;/p&gt;

&lt;h3 id=&quot;pom&quot;&gt;2.1 编写POM&lt;/h3&gt;

&lt;p&gt;Maven项目的核心是：pom.xml文件。POM：（Project Object Model，项目对象模型）定义了项目的基本信息：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;项目如何构建（源文件编译、复制、打包）；&lt;/li&gt;
  &lt;li&gt;项目所需的依赖（项目所需的依赖包，也可能需要依赖额外的包）；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在我们新建一个Hello World项目，并编写一个最简单的pom.xml文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 
       http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt;
  
  &amp;lt;!-- POM模型的版本，对于Maven2和Maven3只能是4.0.0 --&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
  
  &amp;lt;!-- groupId,artifactId,version 唯一定位项目（任何jar、pom、war） --&amp;gt;
  &amp;lt;!-- 定义project属于哪个组 --&amp;gt;
  &amp;lt;!-- 例如，公司为mycom，项目为myapp，则groupId：com.mycom.myapp --&amp;gt;
  &amp;lt;groupId&amp;gt;com.github.ningg.mvnbook&amp;lt;/groupId&amp;gt;
  
  &amp;lt;!-- 定义project在组内的代号，例如，你可能会为不同的子项目(模块)分配artifactId，
  例如，myapp组下，myapp-util,myapp-domain --&amp;gt;
  &amp;lt;artifactId&amp;gt;hello-world&amp;lt;/artifactId&amp;gt;
  
  &amp;lt;!-- 定义当前artifact的版本，SNAPSHOT:快照，说明项目仍在开发中，当前还不稳定 --&amp;gt;
  &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
  
  &amp;lt;!-- 声明一个别名，用户可理解的别名，不是必须的，但为方便交流，推荐每个POM --&amp;gt;
  &amp;lt;name&amp;gt;Maven Hello World Project&amp;lt;/name&amp;gt;
  
  &amp;lt;properties&amp;gt;
    &amp;lt;!-- 告知Maven进行复制、编译等操作时，使用的编码方式 --&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
  &amp;lt;/properties&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码第一行是XML头，指定版本和编码方式。project是所有pom.xml的根元素，它还声明了一些命名空间和xsd（XML Schemas Definition，XML结构定义）元素，虽然这些属性是非必须的，但它们能够让第三方工具（如IDE中的XML编辑器）帮助我们快速编译POM。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;2.2 编写主代码&lt;/h3&gt;

&lt;p&gt;项目主代码与测试代码不同。项目主代码会被打包到最终发布的构件中（例如jar包），而测试代码只在运行测试的时候使用，不会被打包发布。
默认情况下，Maven假设项目的主代码位于src/main/java目录下，我们遵循Maven的约定，创建该目录，并在该项目下创建文件com/github/ningg/mvnbook/helloworld/HelloWorld.java，其内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.github.ningg.mvnbook.helloworld;

public class HelloWorld {

	public String sayHello(){
		return &quot;Hello Maven&quot;;
	}
	
	public static void main(String[] args){
		System.out.println(new HelloWorld().sayHello());
	}
	
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;补充说明如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;95%情况下，应将项目主代码放在src/main/java/目录下（Maven默认的约定），这样无需额外配置，Maven会自动搜索该项目主代码。&lt;/li&gt;
  &lt;li&gt;Java类的包名（package），应该与POM中定义的groupId和artifactId相吻合，例如，本例中的com.github.ningg.mvnbook.helloworld，这样代码结构清晰，符合基本逻辑，方便搜索构件或者java类。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-5&quot;&gt;2.3 进行编译&lt;/h3&gt;

&lt;p&gt;运行命令&lt;code&gt;mvn clean compile&lt;/code&gt;，则输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E:\reference\blogOfGit\maven-intro\hello-world&amp;gt;mvn clean compile
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building Maven Hello World Project 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ hello-world ---
[INFO] Deleting E:\reference\blogOfGit\maven-intro\hello-world\target
[INFO]
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hello-world ---
[INFO] Using &#39;UTF-8&#39; encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory E:\reference\blogOfGit\maven-intro\hello-world\src\main\resources
[INFO]
[INFO] --- maven-compiler-plugin:2.5.1:compile (default-compile) @ hello-world ---
[INFO] Compiling 1 source file to E:\reference\blogOfGit\maven-intro\hello-world\target\classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 0.828 s
[INFO] Finished at: 2014-07-01T20:46:45+08:00
[INFO] Final Memory: 6M/15M
[INFO] ------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从输出信息上可以看出，Maven具体包含3个操作：clean、resources、compile&lt;/li&gt;
  &lt;li&gt;clean：清理目录target/；&lt;/li&gt;
  &lt;li&gt;resources：（本实例中，没有定义项目资源，暂时略过）；&lt;/li&gt;
  &lt;li&gt;compile：编译项目主代码，默认输出到target/目录下；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;说明：上文提到的3个操作，对应了Maven的插件以及插件目标，例如：clean操作，实际上是maven-clean-plugin:2.5插件的clean目标；（Maven插件的编写是很重要的一个方向）&lt;/p&gt;

&lt;p&gt;至此，Maven在没有修改pom.xml配置的情况下，就进行了项目的清理和编译任务，在下文中，将继续编写一些测试单元代码并让Maven自动化测试。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;2.4 编写测试代码&lt;/h3&gt;

&lt;p&gt;为保持项目结构清晰，主代码与测试代码分别在独立的目录中，前文提到过，主代码在src/main/java/目录下，对应的测试代码的目录是src/test/java/。因此，在编写代码前，应先创建这两个目录。&lt;/p&gt;

&lt;p&gt;在java世界中，JUnit是事实上的单元测试标准。要使用JUnit需要在项目的配置文件中添加一个JUnit依赖，修改项目POM如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
   &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.7&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
   &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在project元素下，添加了dependencies元素，该元素下可以包含多个dependency元素，用与声明项目所需的依赖，这里我们添加的是(groupId,artifactId,version)为(junit,junit,4.7)的project，有了这段声明，Maven会自动下载junit-4.7.jar包。你可能会问，Maven从哪里下载这个jar呢？实际上，没有使用Maven时，我们需要自己去JUnit官网下载这个jar；而使用了Maven，它会自动访问自己的&lt;a href=&quot;http://repo1.maven.org/maven2/&quot;&gt;中央仓库&lt;/a&gt; ，下载所需要的文件，我们也可以自己访问这个中央仓库，打开&lt;a href=&quot;http://repo1.maven.org/maven2/junit/junit/4.7/&quot;&gt;junit/junit/4.7/&lt;/a&gt; 路径，就能看到junit-4.7.pom和junit-4.7.jar。&lt;/p&gt;

&lt;p&gt;上述POM代码中，还设置了scope=test，其表示当前依赖仅对测试代码有效，换句话说，测试代码中import junit代码是正确的，而主代码中如果使用import junit就会编译出错。如果不设定scope，默认scope=compile，表示该依赖对主代码和测试代码都有效。&lt;/p&gt;

&lt;p&gt;配置好了测试依赖，就可以编写测试代码了，前面HelloWorld类中，需要测试sayHello()方法的返回值是否为“Hello Maven”。在src/test/java目录下创建文件，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.github.ningg.mvnbook.helloworld;

import org.junit.Assert;
import org.junit.Test;

public class HelloWorldTest {

	@Test
	public void testSayHello(){
		HelloWorld helloWorld = new HelloWorld();
		String result = helloWorld.sayHello();
		Assert.assertEquals(&quot;Hello Maven&quot;, result);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（&lt;strong&gt;注意&lt;/strong&gt;：Eclipse集成开发环境下，在src/main/java/以及src/test/java/目录下编写java文件时，如何使用代码提示，特别是，很多jar的依赖都在pom.xml中配置的，当前工程暂时看不到jar包，import jar包都会提示出错。&lt;strong&gt;简要答复&lt;/strong&gt;：在Eclipse环境下，创建Maven工程，使用Maven来管理项目，只要Maven能够连接到Internet来下载依赖的包，就不会出现找不到jar的情况，而且能够使用Eclipse下的代码提示功能；额外补充一点：Eclipse下，Maven管理项目时，当要查看依赖jar包对应的源码包时，Maven会自动下载相应的源码包）&lt;/p&gt;

&lt;p&gt;典型的单元测试，包含3个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;准备测试类及数据；&lt;/li&gt;
  &lt;li&gt;执行要测试的行为；&lt;/li&gt;
  &lt;li&gt;检查结果；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述测试代码中，我们首先初始化一个要测试的HelloWorld实例，接着执行该实例的sayHello()方法并将结果保存到result变量中，最后使用JUnit框架的Assert类检查结果是否为我们期望的“Hello Maven”。在JUnit 3中，约定所有需要执行测试的方法都以test开头，这里我们使用JUnit 4，但我们仍遵守这一约定，在JUnit中，需要执行的测试方法都以&lt;code&gt;@Test&lt;/code&gt;进行标注。&lt;/p&gt;

&lt;p&gt;测试代码编写完成之后，调用Maven执行测试，运行命令：&lt;code&gt;mvn clean test&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E:\reference\blogOfGit\maven-intro\hello-world&amp;gt;mvn clean test
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building Maven Hello World Project 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]

...
Downloading: http://repo.maven.apache.org/maven2/junit/junit/4.7/junit-4.7.pom
Downloaded: http://repo.maven.apache.org/maven2/junit/junit/4.7/junit-4.7.pom (2 KB at 0.7 KB/sec)
Downloading: http://repo.maven.apache.org/maven2/junit/junit/4.7/junit-4.7.jar
Downloaded: http://repo.maven.apache.org/maven2/junit/junit/4.7/junit-4.7.jar (227 KB at 87.0 KB/sec)
...

[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ hello-world ---
[INFO] Deleting E:\reference\blogOfGit\maven-intro\hello-world\target
[INFO]
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hello-world ---
[INFO] Using &#39;UTF-8&#39; encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory E:\reference\blogOfGit\maven-intro\hello-world\src\main\resources
[INFO]
[INFO] --- maven-compiler-plugin:2.5.1:compile (default-compile) @ hello-world ---
[INFO] Compiling 1 source file to E:\reference\blogOfGit\maven-intro\hello-world\target\classes
[INFO]
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ hello-world ---
[INFO] Using &#39;UTF-8&#39; encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory E:\reference\blogOfGit\maven-intro\hello-world\src\test\resources
[INFO]
[INFO] --- maven-compiler-plugin:2.5.1:testCompile (default-testCompile) @ hello-world ---
[INFO] Compiling 1 source file to E:\reference\blogOfGit\maven-intro\hello-world\target\test-classes
[INFO]
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ hello-world ---
[INFO] Surefire report directory: E:\reference\blogOfGit\maven-intro\hello-world\target\surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running com.github.ningg.mvnbook.helloworld.HelloWorldTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.016 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1.359 s
[INFO] Finished at: 2014-07-01T21:41:33+08:00
[INFO] Final Memory: 7M/16M
[INFO] ------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从输出结果可以看出，执行&lt;code&gt;mvn clean test&lt;/code&gt;时，Maven实际执行了：clean: clean，resources: resources，compiler: compile，resources: testResources，compiler: testCompile，surefire: test。详细来说，Maven在执行测试（test）之前，会先执行：目录清理、主资源处理、主代码编译、测试资源处理、测试代码编译、执行测试等过程，这是Maven生命周期的一个特性，本文后续部分会详细介绍Maven的生命周期。（注：surefire是执行测试的插件，其运行测试用例，并输出测试报告。）&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;2.5 打包和运行&lt;/h3&gt;

&lt;p&gt;项目进行编译、测试之后，下一步就是打包（package）。Hello World项目的POM中没有设置打包类型，默认为jar；执行命令：&lt;code&gt;mvn clean package&lt;/code&gt;进行打包，可以看到如下输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;... ...

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running com.github.ningg.mvnbook.helloworld.HelloWorldTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.016 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO]
[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ hello-world ---
[INFO] Building jar: E:\reference\blogOfGit\maven-intro\hello-world\target\hello-world-1.0-SNAPSHOT.jar
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1.531 s
[INFO] Finished at: 2014-07-01T22:00:37+08:00
[INFO] Final Memory: 7M/17M
[INFO] ------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的，Maven在打包之前，会执行编译、测试等操作。这里我们看到jar:jar负责打包，实际上，就是jar插件的jar目标，将项目主代码打包成为一个名为hello-world-1.0-SNAPSHOT.jar的文件，该文件也位于target/目录下，它是根据artifactId-version.jar规则进行命名的，如有需要，可以使用finalName来定义文件名称。&lt;/p&gt;

&lt;p&gt;至此，我们得到了最终的jar包，如有需要，可以将这个jar包复制到其他项目的classpath中，从而使用HelloWorld类。但是，如何才能让其他Maven项目直接引用这个jar包呢？我们需要一个安装步骤，执行&lt;code&gt;mvn clean install&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;... ...

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running com.github.ningg.mvnbook.helloworld.HelloWorldTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.031 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO]
[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ hello-world ---
[INFO]
[INFO] --- maven-install-plugin:2.4:install (default-install) @ hello-world ---
[INFO] Installing E:\reference\blogOfGit\maven-intro\hello-world\target\hello-world-1.0-SNAPSHOT.jar to C:\Documents and
 Settings\Luious\.m2\repository\com\github\ningg\mvnbook\hello-world\1.0-SNAPSHOT\hello-world-1.0-SNAPSHOT.jar
[INFO] Installing E:\reference\blogOfGit\maven-intro\hello-world\pom.xml to C:\Documents and Settings\Luious\.m2\reposit
ory\com\github\ningg\mvnbook\hello-world\1.0-SNAPSHOT\hello-world-1.0-SNAPSHOT.pom
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1.219 s
[INFO] Finished at: 2014-07-01T22:11:04+08:00
[INFO] Final Memory: 5M/15M
[INFO] ------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从输出结果可知，在jar:jar之后，Maven又执行了install:install，其将当前项目的jar包以及其POM配置文件，安装到了Maven的本地库中(&lt;code&gt;~/.m2/repository/&lt;/code&gt;)。前文讲述JUnit的POM及jar下载的时候，我们说只有构件被下载到本地仓库后，才能由所有Maven项目使用类似，只有将Hello World的构件安装到本地仓库后，
其他Maven项目才能使用它。&lt;/p&gt;

&lt;p&gt;我们已经尝试使用了Maven的主要命令：mvn clean compile，mvn clean test，mvn clean package，mvn clean install。
执行test之前会先执行compile，执行package之前会先执行test，执行install之前会先执行package。至此，我们已经知道这些命令是用来干什么的了，可以在其他任何Maven项目中执行这些命令。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要提示&lt;/strong&gt;：到目前为止，我们还没有运行Hello World项目，不要忘了HelloWorld类可能有一个main方法。默认打包生成的jar包并不能直接运行其中的main方法，因为带有main方法的类信息不会添加到manifest中（我们可以打开jar文件中的META-INF/MANIFEST.MF文件，将无法看到Main-Class一行）。为了生成可执行的jar文件，我们需要借助maven-shade-plugin，配置该插件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;build&amp;gt;
 &amp;lt;plugins&amp;gt;
  &amp;lt;plugin&amp;gt;
   &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;maven-shade-plugin&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;1.2.1&amp;lt;/version&amp;gt;
   &amp;lt;executions&amp;gt;
     &amp;lt;execution&amp;gt;
       &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
       &amp;lt;goals&amp;gt;
         &amp;lt;goal&amp;gt;shade&amp;lt;/goal&amp;gt;
       &amp;lt;/goals&amp;gt;
       &amp;lt;configuration&amp;gt;
         &amp;lt;transformers&amp;gt;
         &amp;lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&amp;gt;
           &amp;lt;mainClass&amp;gt;com.github.ningg.mvnbook.helloworld.HelloWorld&amp;lt;/mainClass&amp;gt;
         &amp;lt;/transformer&amp;gt;
         &amp;lt;/transformers&amp;gt;
       &amp;lt;/configuration&amp;gt;
     &amp;lt;/execution&amp;gt;
   &amp;lt;/executions&amp;gt;
  &amp;lt;/plugin&amp;gt;
 &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的plugin元素在POM中的相对位置应该在 &lt;code&gt;&amp;lt;project&amp;gt;&amp;lt;build&amp;gt;&amp;lt;plugins&amp;gt;&lt;/code&gt; 下面。其中我们配置，mainClass 为 com.github.ningg.mvnbook.helloworld.HelloWorld ，项目在打包时，会将该信息放在MANIFEST中。执行完 &lt;code&gt;mvn clean package&lt;/code&gt; 之后，在target/目录下，我们可以看到 hello-world-1.0-SNAPSHOT.jar 
和 original-hello-world-1.0-SNAPSHOT.jar，前者是带有Main-class信息的可运行jar，后者是原始的jar，打开 hello-world-1.0-SNAPSHOT.jar 的 META-INF/MANIFEST.MF，可以看到 Main-class 信息。&lt;/p&gt;

&lt;p&gt;我们在项目根目录中执行该jar文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E:\...\hello-world&amp;gt;java -jar target/hello-world-1.0-SNAPSHOT.jar
Hello Maven
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（&lt;strong&gt;注意&lt;/strong&gt;：java命令行的使用方法，jar包等知识的补充）&lt;/p&gt;

&lt;p&gt;控制台输出：&lt;code&gt;Hello Maven&lt;/code&gt;，这正是我们所期望的。&lt;/p&gt;

&lt;p&gt;本小节介绍了一个Hello World实例，侧重点是Maven而非Java代码，介绍了POM，Maven项目结构，以及如何编译、测试、打包、发布、运行。&lt;/p&gt;

&lt;h3 id=&quot;archetype&quot;&gt;2.6 使用Archetype生成项目骨架&lt;/h3&gt;

&lt;p&gt;Hello World项目中有一些Maven的约定：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;pom.xml在项目的根目录；&lt;/li&gt;
  &lt;li&gt;主代码在src/main/java/目录下；&lt;/li&gt;
  &lt;li&gt;测试代码在src/test/java/目录下；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们称这些基本的目录结构和pom.xml文件内容为项目的骨架。每次创建项目都要手动创建项目骨架，会让程序员不高兴，为此，Maven提供了Archetype以帮助我们快速勾勒出项目骨架。&lt;/p&gt;

&lt;p&gt;以Hello World为例，我们使用maven archetype来创建该项目的骨架，新建一个Maven项目目录。&lt;/p&gt;

&lt;p&gt;如果是Maven3，简单运行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mvn archetype:generate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（如果是Maven2，请参考：&lt;a href=&quot;/download/maven/Maven+in+action.pdf&quot;&gt;《Maven实战（迷你版）》&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;实际上，我们运行的是maven-archetype-plugin插件，其输入格式是：groupId: artifactId: version: goal ，注意冒号的分隔。紧接着，我们会看到很长的输出，有很多可用的archetype供我们选择，包括注明的Appfuse项目、JPA项目的archetype等等。每一个archetype前面都会对应一个编号，同时命令行会提示一个默认的编号，对应archetype为maven-archetype-quickstart，直接回车选择该archetype，紧接着Maven会提示我们输入要创建的项目的groupId，artifactId，version以及包名（package，默认与groupId和artifactId保持对应关系），具体如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Define value for property &#39;groupId&#39;: : com.github.ningg.mvnbook
Define value for property &#39;artifactId&#39;: : hello-world-archetype
Define value for property &#39;version&#39;:  1.0-SNAPSHOT: :
Define value for property &#39;package&#39;:  com.github.ningg.mvnbook: : com.github.ningg.mvnbook.helloworldarchetype
Confirm properties configuration:
groupId: com.github.ningg.mvnbook
artifactId: hello-world-archetype
version: 1.0-SNAPSHOT
package: com.github.ningg.mvnbook.helloworldarchetype
 Y: : Y
[INFO] ----------------------------------------------------------------------------
[INFO] Using following parameters for creating project from Old (1.x) Archetype: maven-archetype-quickstart:RELEASE
[INFO] ----------------------------------------------------------------------------
[INFO] Parameter: groupId, Value: com.github.ningg.mvnbook
[INFO] Parameter: packageName, Value: com.github.ningg.mvnbook.helloworldarchetype
[INFO] Parameter: package, Value: com.github.ningg.mvnbook.helloworldarchetype
[INFO] Parameter: artifactId, Value: hello-world-archetype
[INFO] Parameter: basedir, Value: E:\reference\blogOfGit\maven-intro
[INFO] Parameter: version, Value: 1.0-SNAPSHOT
[INFO] project created from Old (1.x) Archetype in dir: E:\reference\blogOfGit\maven-intro\hello-world-archetype
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行完毕之后，在当前目录下会生成一个hello-world-archetype目录，其下是一个完整的项目骨架。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特别说明&lt;/strong&gt;：如果你有很多项目拥有类似的项目骨架（项目结构和配置文件），你可以一劳永逸的开发自己的archetype，然后在项目中使用自定义的archetype来快速生成项目骨架。（具体请参考：&lt;a href=&quot;/download/maven/Maven+in+action.pdf&quot;&gt;《Maven实战（迷你版）》&lt;/a&gt;）&lt;/p&gt;

</content>
   </entry>
   
 
</feed>
