<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>NingG.github.com</title>
   <link href="http://ningg.github.com/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://ningg.github.com" rel="alternate" type="text/html" />
   <updated>2014-05-11T23:24:58+08:00</updated>
   <id>http://ningg.github.com</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>Pig入门5h</title>
     <link href="http://ningg.github.com/use-pig"/>
     <updated>2014-05-10T00:00:00+08:00</updated>
     <id>http://ningg.github.com/use-pig</id>
     <content type="html">&lt;p&gt;&lt;strong&gt;致谢&lt;/strong&gt;：本篇博客转载至codelast的博客&lt;a href=&quot;http://www.codelast.com/?p=3621&quot;&gt;Apache Pig的一些基础概念及用法总结&lt;/a&gt; ；在此，对codelast致敬，其分享精神温暖人心。&lt;em&gt;(本文会在codelast原博客的基础上陆续做一些调整)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;下面开始学习Pig。&lt;/p&gt;

&lt;p&gt;（1）关系（relation）、包（bag）、元组（tuple）、字段（field）、数据（data）的关系&lt;/p&gt;

&lt;p&gt;一个关系（relation）是一个包（bag），更具体地说，是一个外部的包（outer bag）。
一个包（bag）是一个元组（tuple）的集合。在pig中表示数据时，用大括号{}括起来的东西表示一个包——无论是在教程中的实例演示，还是在pig交互模式下的输出，都遵循这样的约定，请牢记这一点，因为不理解的话就会对数据结构的掌握产生偏差。
一个元组（tuple）是若干字段（field）的一个有序集（ordered set）。在pig中表示数据时，用小括号()括起来的东西表示一个元组。
一个字段是一块数据（data）。
“元组”这个词很抽象，你可以把它想像成关系型数据库表中的一行，它含有一个或多个字段，其中，每一个字段可以是任何数据类型，并且可以有或者没有数据。
“关系”可以比喻成关系型数据库的一张表，而上面说了，“元组”可以比喻成数据表中的一行，那么这里有人要问了，在关系型数据库中，同一张表中的每一行都有固定的字段数，pig中的“关系”与“元组”之间，是否也是这样的情况呢？不是的。“关系”并不要求每一个“元组”都含有相同数量的字段，并且也不会要求各“元组”中在相同位置处的字段具有相同的数据类型（太随意了，是吧？）&lt;/p&gt;

&lt;p&gt;（2）一个 计算多维度组合下的平均值 的实际例子
为了帮助大家理解pig的一个基本的数据处理流程，我造了一些简单的数据来举个例子——
假设有数据文件：a.txt（各数值之间是以tab分隔的）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost pig]$ cat a.txt 
a 1 2 3 4.2 9.8
a 3 0 5 3.5 2.1
b 7 9 9 - -
a 7 9 9 2.6 6.2
a 1 2 5 7.7 5.9
a 1 2 3 1.4 0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题如下：怎样求出在第2、3、4列的所有组合的情况下，最后两列的平均值分别是多少？
例如，第2、3、4列有一个组合为（1，2，3），即第一行和最后一行数据。对这个维度组合来说，最后两列的平均值分别为：
（4.2+1.4）/2＝2.8
（9.8+0.2）/2＝5.0
而对于第2、3、4列的其他所有维度组合，都分别只有一行数据，因此最后两列的平均值其实就是它们自身。
特别地，组合（7，9，9）有两行记录：第三、四行，但是第三行数据的最后两列没有值，因此它不应该被用于平均值的计算，也就是说，在计算平均值时，第三行是无效数据。所以（7，9，9）组合的最后两列的平均值为 2.6 和 6.2。
我们现在用pig来算一下，并且输出最终的结果。
先进入本地调试模式（pig -x local），再依次输入如下pig代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;a.txt&#39; AS (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double);
B = GROUP A BY (col2, col3, col4);
C = FOREACH B GENERATE group, AVG(A.col5), AVG(A.col6);
DUMP C;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pig输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;((1,2,3),2.8,5.0)
((1,2,5),7.7,5.9)
((3,0,5),3.5,2.1)
((7,9,9),2.6,6.2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个结果对吗？手工算一下就知道是对的。&lt;/p&gt;

&lt;p&gt;下面，我们依次来看看每一句pig代码分别得到了什么样的数据。
①加载 a.txt 文件，并指定每一列的数据类型分别为 chararray（字符串），int，int，int，double，double。同时，我们还给予了每一列别名，分别为 col1，col2，……，col6。这个别名在后面的数据处理中会用到——如果你不指定别名，那么在后面的处理中，就只能使用索引（$0，$1，……）来标识相应的列了，这样可读性会变差，因此，在列固定的情况下，还是指定别名的好。
将数据加载之后，保存到变量A中，A的数据结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A: {col1: chararray,col2: int,col3: int,col4: int,col5: double,col6: double}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，A是用大括号括起来的东西。根据本文前面的说法，A是一个包（bag）。
这个时候，A与你想像中的样子应该是一致的，也就是与前面打印出来的 a.txt 文件的内容是一样的，还是一行一行的类似于“二维表”的数据。&lt;/p&gt;

&lt;p&gt;②按照A的第2、3、4列，对A进行分组。pig会找出所有第2、3、4列的组合，并按照升序进行排列，然后将它们与对应的包A整合起来，得到如下的数据结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;B: {group: (col2: int,col3: int,col4: int),A: {col1: chararray,col2: int,col3: int,col4: int,col5: double,col6: double}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，A的第2、3、4列的组合被pig赋予了一个别名：group，这很形象。同时我们也观察到，B的每一行其实就是由一个group和若干个A组成的——注意，是若干个A。这里之所以只显示了一个A，是因为这里表示的是数据结构，而不表示具体数据有多少组。
实际的数据为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;((1,2,3),{(a,1,2,3,4.2,9.8),(a,1,2,3,1.4,0.2)})
((1,2,5),{(a,1,2,5,7.7,5.9)})
((3,0,5),{(a,3,0,5,3.5,2.1)})
((7,9,9),{(b,7,9,9,,),(a,7,9,9,2.6,6.2)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，与前面所说的一样，组合（1，2，3）对应了两行数据，组合（7，9，9）也对应了两行数据。
这个时候，B的结构就不那么明朗了，可能与你想像中有一点不一样了。&lt;/p&gt;

&lt;p&gt;③计算每一种组合下的最后两列的平均值。
根据上面得到的B的数据，你可以把B想像成一行一行的数据（只不过这些行不是对称的），FOREACH 的作用是对 B 的每一行数据进行遍历，然后进行计算。
GENERATE 可以理解为要生成什么样的数据，这里的 group 就是上一步操作中B的第一项数据（即pig为A的第2、3、4列的组合赋予的别名），所以它告诉了我们：在数据集 C 的每一行里，第一项就是B中的group——类似于（1，2，5）这样的东西）。
而 AVG(A.col5) 这样的计算，则是调用了pig的一个求平均值的函数 AVG，用于对 A 的名为 col5 的列求平均值。前文说了，在加载数据到A的时候，我们已经给每一列起了个别名，col5就是倒数第二列。
到这里，可能有人要迷糊了：难道 AVG(A.col5) 不是表示对 A 的col5这一列求平均值吗？也就是说，在遍历B（FOREACH B）的每一行时候，计算结果都是相同的啊！
事实上并不是这样。我们遍历的是B，我们需要注意到，B的数据结构中，每一行数据里，一个group对应的是若干个A，因此，这里的 A.col5，指的是B的每一行中的A，而不是包含全部数据的那个A。拿B的第一行来举例：
((1,2,3),{(a,1,2,3,4.2,9.8),(a,1,2,3,1.4,0.2)})
遍历到B的这一行时，要计算AVG(A.col5)，pig会找到 (a,1,2,3,4.2,9.8) 中的4.2，以及(a,1,2,3,1.4,0.2)中的1.4，加起来除以2，就得到了平均值。
同理，我们也知道了AVG(A.col6)是怎么算出来的。但还有一点要注意的：对(7,9,9)这个组，它对应的数据(b,7,9,9,,)里最后两列是无值的，这是因为我们的数据文件对应位置上不是有效数字，而是两个“-”，pig在加载数据的时候自动将它置为空了，并且计算平均值的时候，也不会把这一组数据考虑在内（相当于忽略这组数据的存在）。
到了这里，我们不难理解，为什么C的数据结构是这样的了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C: {group: (col2: int,col3: int,col4: int),double,double}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;④DUMP C就是将C中的数据输出到控制台。如果要输出到文件，需要使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;STORE C INTO &#39;output&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样pig就会在当前目录下新建一个“output”目录（该目录必须事先不存在），并把结果文件放到该目录下。&lt;/p&gt;

&lt;p&gt;请想像一下，如果要实现相同的功能，用Java或C++写一个Map-Reduce应用程序需要多少时间？可能仅仅是写一个build.xml或者Makefile，所需的时间就是写这段pig代码的几十倍了！
正因为pig有如此优势，它才得到了广泛应用。&lt;/p&gt;

&lt;p&gt;（3）怎样统计数据行数
在SQL语句中，要统计表中数据的行数，很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT COUNT(*) FROM table_name WHERE condition
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在pig中，也有一个COUNT函数，在pig手册中，对COUNT函数有这样的说明：&lt;/p&gt;

&lt;p&gt;Computes the number of elements in a bag.
假设要计算数据文件a.txt的行数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost pig]$ cat a.txt 
a 1 2 3 4.2 9.8
a 3 0 5 3.5 2.1
b 7 9 9 - -
a 7 9 9 2.6 6.2
a 1 2 5 7.7 5.9
a 1 2 3 1.4 0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你是否可以这样做呢：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;a.txt&#39; AS (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double);
B = COUNT(*);
DUMP B;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;答案是：绝对不行。pig会报错。pig手册中写得很明白：&lt;/p&gt;

&lt;p&gt;Note: You cannot use the tuple designator (&lt;em&gt;) with COUNT; that is, COUNT(&lt;/em&gt;) will not work.
那么，这样对某一列计数行不行呢：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;B = COUNT(A.col2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;答案是：仍然不行。pig会报错。
这就与我们想像中的“正确做法”有点不一样了：我为什么不能直接统计一个字段的数目有多少呢？刚接触pig的时候，一定非常疑惑这样明显“不应该出错”的写法为什么行不通。
要统计A中含col2字段的数据有多少行，正确的做法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;a.txt&#39; AS (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double);
B = GROUP A ALL;
C = FOREACH B GENERATE COUNT(A.col2);
DUMP C;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;p&gt;(6)
表明有6行数据。
如此麻烦？没错。这是由pig的数据结构决定的。&lt;/p&gt;

&lt;p&gt;在这个例子中，统计COUNT(A.col2)和COUNT(A)的结果是一样的，但是，如果col2这一列中含有空值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost pig]$ cat a.txt 
a 1 2 3 4.2 9.8
a   0 5 3.5 2.1
b 7 9 9 - -
a 7 9 9 2.6 6.2
a 1 2 5 7.7 5.9
a 1 2 3 1.4 0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则以下pig程序及执行结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; A = LOAD &#39;a.txt&#39; AS (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double);
grunt&amp;gt; B = GROUP A ALL;
grunt&amp;gt; C = FOREACH B GENERATE COUNT(A.col2);
grunt&amp;gt; DUMP C;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(5)
可见，结果为5行。那是因为你LOAD数据的时候指定了col2的数据类型为int，而a.txt的第二行数据是空的，因此数据加载到A以后，有一个字段就是空的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; DUMP A;
(a,1,2,3,4.2,9.8)
(a,,0,5,3.5,2.1)
(b,7,9,9,,)
(a,7,9,9,2.6,6.2)
(a,1,2,5,7.7,5.9)
(a,1,2,3,1.4,0.2) 在COUNT的时候，null的字段不会被计入在内，所以结果是5。
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;The COUNT function follows syntax semantics and ignores nulls. What this means is that a tuple in the bag will not be counted if the first field in this tuple is NULL. If you want to include NULL values in the count computation, use COUNT_STAR.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（4）FLATTEN操作符的作用
这个玩意一开始还是挺让我费解的。从字面上看，flatten就是“弄平”的意思，但是在对一个pig的数据结构操作时，flatten到底是“弄平”了什么，又有什么作用呢？
我们还是采用前面的a.txt数据文件来说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost pig]$ cat a.txt 
a 1 2 3 4.2 9.8
a 3 0 5 3.5 2.1
b 7 9 9 - -
a 7 9 9 2.6 6.2
a 1 2 5 7.7 5.9
a 1 2 3 1.4 0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们按照前文的做法，计算多维度组合下的最后两列的平均值，则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; A = LOAD &#39;a.txt&#39; AS (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double);
grunt&amp;gt; B = GROUP A BY (col2, col3, col4);
grunt&amp;gt; C = FOREACH B GENERATE group, AVG(A.col5), AVG(A.col6);
grunt&amp;gt; DUMP C;
((1,2,3),2.8,5.0)
((1,2,5),7.7,5.9)
((3,0,5),3.5,2.1)
((7,9,9),2.6,6.2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，输出结果中，每一行的第一项是一个tuple（元组），我们来试试看 FLATTEN 的作用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; A = LOAD &#39;a.txt&#39; AS (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double);
grunt&amp;gt; B = GROUP A BY (col2, col3, col4);
grunt&amp;gt; C = FOREACH B GENERATE FLATTEN(group), AVG(A.col5), AVG(A.col6);
grunt&amp;gt; DUMP C;
(1,2,3,2.8,5.0)
(1,2,5,7.7,5.9)
(3,0,5,3.5,2.1)
(7,9,9,2.6,6.2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到了吗？被 FLATTEN 的group本来是一个元组，现在变成了扁平的结构了。按照pig文档的说法，FLATTEN用于对元组（tuple）和包（bag）“解嵌套”（un-nest）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The FLATTEN operator looks like a UDF syntactically, but it is actually an operator that changes the structure of tuples and bags in a way that a UDF cannot. Flatten un-nests tuples as well as bags. The idea is the same, but the operation and result is different for each type of structure.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;For tuples, flatten substitutes the fields of a tuple in place of the tuple. For example, consider a relation that has a tuple of the form (a, (b, c)). The expression GENERATE $0, flatten($1), will cause that tuple to become (a, b, c).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以我们就看到了上面的结果。
在有的时候，不“解嵌套”的数据结构是不利于观察的，输出这样的数据可能不利于外围数程序的处理（例如，pig将数据输出到磁盘后，我们还需要用其他程序做后续处理，而对一个元组，输出的内容里是含括号的，这就在处理流程上又要多一道去括号的工序），因此，FLATTEN提供了一个让我们在某些情况下可以清楚、方便地分析数据的机会。&lt;/p&gt;

&lt;p&gt;（5）关于GROUP操作符
在上文的例子中，已经演示了GROUP操作符会生成什么样的数据。在这里，需要说得更理论一些：&lt;/p&gt;

&lt;p&gt;用于GROUP的key如果多于一个字段（正如本文前面的例子），则GROUP之后的数据的key是一个元组（tuple），否则它就是与用于GROUP的key相同类型的东西。
GROUP的结果是一个关系（relation），在这个关系中，每一组包含一个元组（tuple），这个元组包含两个字段：（1）第一个字段被命名为“group”——这一点非常容易与GROUP关键字相混淆，但请区分开来。该字段的类型与用于GROUP的key类型相同。（2）第二个字段是一个包（bag），它的类型与被GROUP的关系的类型相同。&lt;/p&gt;

&lt;p&gt;（6）把数据当作“元组”（tuple）来加载
还是假设有如下数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost pig]$ cat a.txt 
a 1 2 3 4.2 9.8
a 3 0 5 3.5 2.1
b 7 9 9 - -
a 7 9 9 2.6 6.2
a 1 2 5 7.7 5.9
a 1 2 3 1.4 0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们按照以下方式来加载数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;a.txt&#39; AS (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么得到的A的数据结构为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; DESCRIBE A;
A: {col1: chararray,col2: int,col3: int,col4: int,col5: double,col6: double}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你要把A当作一个元组（tuple）来加载：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;a.txt&#39; AS (T : tuple (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是想要得到这样的数据结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; DESCRIBE A;
A: {T: (col1: chararray,col2: int,col3: int,col4: int,col5: double,col6: double)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，上面的方法将得到一个空的A：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; DUMP A;
()
()
()
()
()
()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那是因为数据文件a.txt的结构不适合于这样加载成元组（tuple）。&lt;/p&gt;

&lt;p&gt;如果有数据文件b.txt：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost pig]$ cat b.txt 
(a,1,2,3,4.2,9.8)
(a,3,0,5,3.5,2.1)
(b,7,9,9,-,-)
(a,7,9,9,2.6,6.2)
(a,1,2,5,7.7,5.9)
(a,1,2,3,1.4,0.2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则使用上面所说的加载方法及结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; A = LOAD &#39;b.txt&#39; AS (T : tuple (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double));
grunt&amp;gt; DUMP A;
((a,1,2,3,4.2,9.8))
((a,3,0,5,3.5,2.1))
((b,7,9,9,,))
((a,7,9,9,2.6,6.2))
((a,1,2,5,7.7,5.9))
((a,1,2,3,1.4,0.2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，加载的数据的结构确实被定义成了元组（tuple）。&lt;/p&gt;

&lt;p&gt;（7）在多维度组合下，如何计算某个维度组合里的不重复记录的条数
以数据文件 c.txt 为例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost pig]$ cat c.txt 
a 1 2 3 4.2 9.8 100
a 3 0 5 3.5 2.1 200
b 7 9 9 - - 300
a 7 9 9 2.6 6.2 300
a 1 2 5 7.7 5.9 200
a 1 2 3 1.4 0.2 500
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题：如何计算在第2、3、4列的所有维度组合下，最后一列不重复的记录分别有多少条？例如，第2、3、4列有一个维度组合是（1，2，3），在这个维度维度下，最后一列有两种值：100 和 500，因此不重复的记录数为2。同理可求得其他的记录条数。
pig代码及输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; A = LOAD &#39;c.txt&#39; AS (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double, col7:int);
grunt&amp;gt; B = GROUP A BY (col2, col3, col4);
grunt&amp;gt; C = FOREACH B {D = DISTINCT A.col7; GENERATE group, COUNT(D);};
grunt&amp;gt; DUMP C;
((1,2,3),2)
((1,2,5),1)
((3,0,5),1)
((7,9,9),1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来看看每一步分别生成了什么样的数据：
①LOAD不用说了，就是加载数据；
②GROUP也不用说了，和前文所说的一样。GROUP之后得到了这样的数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; DUMP B;
((1,2,3),{(a,1,2,3,4.2,9.8,100),(a,1,2,3,1.4,0.2,500)})
((1,2,5),{(a,1,2,5,7.7,5.9,200)})
((3,0,5),{(a,3,0,5,3.5,2.1,200)})
((7,9,9),{(b,7,9,9,,,300),(a,7,9,9,2.6,6.2,300)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实到这里，我们肉眼就可以看出来最后要求的结果是什么了，当然，必须要由pig代码来完成，要不然怎么应对海量数据？&lt;/p&gt;

&lt;p&gt;③这里的 FOREACH 与前面有点不一样，这就是所谓的“嵌套的FOREACH”。第一次看到这种写法，肯定会觉得很奇怪。先看一下用于去重的DISTINCT关键字的说明：&lt;/p&gt;

&lt;p&gt;Removes duplicate tuples in a relation.
然后再解释一下：FOREACH 是对B的每一行进行遍历，其中，B的每一行里含有一个包（bag），每一个包中含有若干元组（tuple）A，因此，FOREACH 后面的大括号里的操作，其实是对所谓的“内部包”（inner bag）的操作（详情请参看FOREACH的说明），在这里，我们指定了对A的col7这一列进行去重，去重的结果被命名为D，然后再对D计数（COUNT），就得到了我们想要的结果。
④输出结果数据，与前文所述的差不多。
这样就达成了我们的目的。从总体上说，刚接触pig不久的人会觉得这些写法怪怪的，就是扭不过来，但是要坚持，时间长了，连倒影也会让你觉得是正的了。&lt;/p&gt;

&lt;p&gt;（8）如何将关系（relation）转换为标量（scalar）
在前文中，我们要统计符合某些条件的数据的条数，使用了COUNT函数来计算，但在COUNT之后，我们得到的还是一个关系（relation），而不是一个标量的数字，如何把一个关系转换为标量，从而可以在后续处理中便于使用呢？
具体请看这个链接。&lt;/p&gt;

&lt;p&gt;（9）pig中如何使用shell进行辅助数据处理
pig中可以嵌套使用shell进行辅助处理，下面，就以一个实际的例子来说明。
假设我们在某一步pig处理后，得到了类似于下面 b.txt 中的数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost pig]$ cat b.txt 
1 5 98  = 7
34  8 6 3 2
62  0 6 = 65
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题：如何将数据中第4列中的“=”符号全部替换为9999？
pig代码及输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; A = LOAD &#39;b.txt&#39; AS (col1:int, col2:int, col3:int, col4:chararray, col5:int);
grunt&amp;gt; B = STREAM A THROUGH `awk &#39;{if($4 == &quot;=&quot;) print $1&quot;\t&quot;$2&quot;\t&quot;$3&quot;\t9999\t&quot;$5; else print $0}&#39;`;
grunt&amp;gt; DUMP B;
(1,5,98,9999,7)
(34,8,6,3,2)
(62,0,6,9999,65)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来看看这段代码是如何做到的：
①加载数据，这个没什么好说的。
②通过“STREAM … THROUGH …”的方式，我们可以调用一个shell语句，用该shell语句对A的每一行数据进行处理。此处的shell逻辑为：当某一行数据的第4列为“=”符号时，将其替换为“9999”；否则就照原样输出这一行。
③输出B，可见结果正确。&lt;/p&gt;

&lt;p&gt;（10）向pig脚本中传入参数
假设你的pig脚本输出的文件是通过外部参数指定的，则此参数不能写死，需要传入。在pig中，使用传入的参数如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;STORE A INTO &#39;$output_dir&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则这个“output_dir”就是个传入的参数。在调用这个pig脚本的shell脚本中，我们可以这样传入参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pig -param output_dir=&quot;/home/my_ourput_dir/&quot; my_pig_script.pig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里传入的参数“output_dir”的值为“/home/my_output_dir/”。&lt;/p&gt;

&lt;p&gt;（11）就算是同样一段pig代码，多次计算所得的结果也有可能是不同的
例如用AVG函数来计算平均值时，同样一段pig代码，多次计算所得的结果中，小数点的最后几位也有可能是不相同的（当然也有可能相同），大概是因为精度的原因吧。不过，一般来说小数点的最后几位已经不重要了。例如我对一个数据集进行处理后，小数点后13位才开始有不同，这样的精度完全足够了。&lt;/p&gt;

&lt;p&gt;（12）如何编写及使用自定义函数（UDF）
请看这个链接：《Apache Pig中文教程（进阶）》&lt;/p&gt;

&lt;p&gt;（13）什么是聚合函数（Aggregate Function）
在pig中，聚合函数就是那些接受一个输入包（bag），返回一个标量（scalar）值的函数。COUNT函数就是一个例子。&lt;/p&gt;

&lt;p&gt;（14）COGROUP做了什么
与GROUP操作符一样，COGROUP也是用来分组的，不同的是，COGROUP可以按多个关系中的字段进行分组。
还是以一个实例来说明，假设有以下两个数据文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost pig]$ cat a.txt 
uidk  12  3
hfd 132 99
bbN 463 231
UFD 13  10
 
[root@localhost pig]$ cat b.txt 
908 uidk  888
345 hfd 557
28790 re  00000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们用pig做如下操作及得到的结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; A = LOAD &#39;a.txt&#39; AS (acol1:chararray, acol2:int, acol3:int);
grunt&amp;gt; B = LOAD &#39;b.txt&#39; AS (bcol1:int, bcol2:chararray, bcol3:int);
grunt&amp;gt; C = COGROUP A BY acol1, B BY bcol2;
grunt&amp;gt; DUMP C;
(re,{},{(28790,re,0)})
(UFD,{(UFD,13,10)},{})
(bbN,{(bbN,463,231)},{})
(hfd,{(hfd,132,99)},{(345,hfd,557)})
(uidk,{(uidk,12,3)},{(908,uidk,888)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一行输出的第一项都是分组的key，第二项和第三项分别都是一个包（bag），其中，第二项是根据前面的key找到的A中的数据包，第三项是根据前面的key找到的B中的数据包。
来看看第一行输出：“re”作为group的key时，其找不到对应的A中的数据，因此第二项就是一个空的包“{}”，“re”这个key在B中找到了对应的数据（28790    re    00000），因此第三项就是包{(28790,re,0)}。
其他输出数据也类似。&lt;/p&gt;

&lt;p&gt;（15）安装pig后，运行pig命令时提示“Cannot find hadoop configurations in classpath”等错误的解决办法
pig安装好后，运行pig命令时提示以下错误：&lt;/p&gt;

&lt;p&gt;ERROR org.apache.pig.Main - ERROR 4010: Cannot find hadoop configurations in classpath (neither hadoop-site.xml nor core-site.xml was found in the classpath).If you plan to use local mode, please put -x local option in command line
显而易见，提示找不到与hadoop相关的配置文件。所以我们需要把hadoop安装目录下的“conf”子目录添加到系统环境变量PATH中：
修改 /etc/profile 文件，添加：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export HADOOP_HOME=/usr/local/hadoop
export PIG_CLASSPATH=$HADOOP_HOME/conf
 
PATH=$JAVA_HOME/bin:$HADOOP_HOME/bin:$PIG_CLASSPATH:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后重新加载 /etc/profile 文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source /etc/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（16）piggybank是什么东西&lt;/p&gt;

&lt;p&gt;Pig also hosts a UDF repository called piggybank that allows users to share UDFs that they have written.
说白了就是Apache把大家写的自定义函数放在一块儿，起了个名字，就叫做piggybank。你可以把它理解为一个SVN代码仓库。具体请看这里。&lt;/p&gt;

&lt;p&gt;（17）UDF的构造函数会被调用几次
你可能会想在UDF的构造函数中做一些初始化的工作，例如创建一些文件，等等。但是你不能假设UDF的构造函数只被调用一次，因此，如果你要在构造函数中做一些只能做一次的工作，你就要当心了——可能会导致错误。&lt;/p&gt;

&lt;p&gt;（18）LOAD数据时，如何一次LOAD多个目录下的数据
例如，我要LOAD两个HDFS目录下的数据：/abc/2010 和 /abc/2011，则我们可以这样写LOAD语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;/abc/201{0,1}&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（19）怎样自己写一个UDF中的加载函数(load function)
请看这个链接：《Apache Pig中文教程（进阶）》&lt;/p&gt;

&lt;p&gt;（20）重载(overloading)一个UDF
请看这个链接：《Apache Pig中文教程（进阶）》。&lt;/p&gt;

&lt;p&gt;（21）pig运行不起来，提示“org.apache.hadoop.ipc.Client - Retrying connect to server: 
请看这个链接：《Apache Pig中文教程（进阶）》&lt;/p&gt;

&lt;p&gt;（22）用含有null的字段来GROUP，结果会如何
假设有数据文件 a.txt 内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 2 5
1   3
1 3 
6 9 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，每两列数据之间是用tab分割的，第二行的第2列、第三行的第3列没有内容（也就是说，加载到Pig里之后，对应的数据会变成null），如果把这些数据按第1、第2列来GROUP的话，第1、2列中含有null的行会被忽略吗？
来做一下试验：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;a.txt&#39; AS (col1:int, col2:int, col3:int);
B = GROUP A BY (col1, col2);
DUMP B;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;((1,2),{(1,2,5)})
((1,3),{(1,3,)})
((1,),{(1,,3)})
((6,9),{(6,9,8)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的结果（第三行）可见，原数据中第1、2列里含有null的行也被计入在内了，也就是说，GROUP操作是不会忽略null的，这与COUNT有所不同（见本文前面的部分）。&lt;/p&gt;

&lt;p&gt;（23）如何统计数据中某些字段的组合有多少种
假设有如下数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost]# cat a.txt 
1 3 4 7
1 3 5 4
2 7 0 5
9 8 6 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们要统计第1、2列的不同组合有多少种，对本例来说，组合有三种：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 3
2 7
9 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说我们要的答案是3。
用Pig怎么计算？&lt;/p&gt;

&lt;p&gt;先写出全部的Pig代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;a.txt&#39; AS (col1:int, col2:int, col3:int, col4:int);
B = GROUP A BY (col1, col2); 
C = GROUP B ALL;
D = FOREACH C GENERATE COUNT(B); 
DUMP D;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再来看看这些代码是如何计算出上面的结果的：
①第一行代码加载数据，没什么好说的。
②第二行代码，得到第1、2列数据的所有组合。B的数据结构为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; DESCRIBE B;
B: {group: (col1: int,col2: int),A: {col1: int,col2: int,col3: int,col4: int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把B DUMP出来，得到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;((1,3),{(1,3,4,7),(1,3,5,4)})
((2,7),{(2,7,0,5)})
((9,8),{(9,8,6,6)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;非常明显，(1,3)，(2,7)，(9,8)的所有组合已经被排列出来了，这里得到了若干行数据。下一步我们要做的就是统计这样的数据一共有多少行，也就得到了第1、2列的组合有多少组。
③第三和第四行代码，就实现了统计数据行数的功能。参考本文前面部分的“怎样统计数据行数”一节。就明白这两句代码是什么意思了。
这里需要特别说明的是：
a)为什么倒数第二句代码中是COUNT(B)，而不是COUNT(group)？
我们是对C进行FOREACH，所以要先看看C的数据结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; DESCRIBE C;
C: {group: chararray,B: {group: (col1: int,col2: int),A: {col1: int,col2: int,col3: int,col4: int}}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，你可以把C想像成一个map的结构，key是一个group，value是一个包（bag），它的名字是B，这个包中有N个元素，每一个元素都对应到②中所说的一行。根据②的分析，我们就是要统计B中元素的个数，因此，这里当然就是COUNT(B)了。
b)COUNT函数的作用是统计一个包（bag）中的元素的个数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;COUNT
Computes the number of elements in a bag.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从C的数据结构看，B是一个bag，所以COUNT函数是可以用于它的。
如果你试图把COUNT应用于一个非bag的数据结构上，会发生错误，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java.lang.ClassCastException: org.apache.pig.data.BinSedesTuple cannot be cast to org.apache.pig.data.DataBag
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是把Tuple传给COUNT函数时发生的错误。&lt;/p&gt;

&lt;p&gt;（24）两个整型数相除，如何转换为浮点型，从而得到正确的结果
这个问题其实很傻，或许不用说你也知道了：假设有int a = 3 和 int b = 2两个数，在大多数编程语言里，a/b得到的是1，想得到正确结果1.5的话，需要转换为float再计算。在Pig中其实和这种情况一样，下面就拿几行数据来做个实验：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat a.txt 
3 2
4 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Pig中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; A = LOAD &#39;a.txt&#39; AS (col1:int, col2:int);                  
grunt&amp;gt; B = FOREACH A GENERATE col1/col2;
grunt&amp;gt; DUMP B;
(1)
(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，不加类型转换的计算结果是取整之后的值。
那么，转换一下试试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; A = LOAD &#39;a.txt&#39; AS (col1:int, col2:int);
grunt&amp;gt; B = FOREACH A GENERATE (float)(col1/col2);
grunt&amp;gt; DUMP B;
(1.0)
(0.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样转换还是不行的，这与大多数编程语言的结果一致——它只是把取整之后的数再转换为浮点数，因此当然是不行的。&lt;/p&gt;

&lt;p&gt;正确的做法应该是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; A = LOAD &#39;a.txt&#39; AS (col1:int, col2:int); 
grunt&amp;gt; B = FOREACH A GENERATE (float)col1/col2;  
grunt&amp;gt; DUMP B;
(1.5)
(0.8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者这样也行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; A = LOAD &#39;a.txt&#39; AS (col1:int, col2:int);
grunt&amp;gt; B = FOREACH A GENERATE col1/(float)col2;       
grunt&amp;gt; DUMP B;
(1.5)
(0.8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这与我们的通常做法是一致的，因此，你要做除法运算的时候，需要注意这一点。&lt;/p&gt;

&lt;p&gt;（25）UNION的一个例子
假设有两个数据文件为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat 1.txt 
0 3
1 5
0 8
 
[root@localhost ~]# cat 2.txt 
1 6
0 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在要求出：在第一列相同的情况下，第二列的和分别为多少？
例如，第一列为 1 的时候，第二列有5和6两个值，和为11。同理，第一列为0的时候，第二列的和为 3+8+9=20。
计算此问题的Pig代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;1.txt&#39; AS (a: int, b: int); 
B = LOAD &#39;2.txt&#39; AS (c: int, d: int); 
C = UNION A, B;
D = GROUP C BY $0; 
E = FOREACH D GENERATE FLATTEN(group), SUM(C.$1);
DUMP E;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(0,20)
(1,11)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来看看每一步分别做了什么：
①第1行、第2行代码分别加载数据到关系A、B中，没什么好说的。
②第3行代码，将关系A、B合并起来了。合并后的数据结构为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; DESCRIBE C;
C: {a: int,b: int}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其数据为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; DUMP C;
(0,3)
(1,5)
(0,8)
(1,6)
(0,9)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③第4行代码按第1列（即$0）进行分组，分组后的数据结构为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; DESCRIBE D;
D: {group: int,C: {a: int,b: int}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其数据为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; DUMP D;
(0,{(0,9),(0,3),(0,8)})
(1,{(1,5),(1,6)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;④最后一行代码，遍历D，将D中每一行里的所有bag(即C)的第2列(即$1)进行累加，就得到了我们要的结果。&lt;/p&gt;

&lt;p&gt;（26）错误“ERROR org.apache.pig.tools.grunt.Grunt - ERROR 2042: Error in new logical plan. Try -Dpig.usenewlogicalplan=false.”的可能原因
①Pig的bug，详见此链接；
②其他原因。我遇到并解决了一例。具体的代码不便在此陈列，但是基本可以说是由于自己写的Pig代码对复杂数据结构的处理不当导致的，后来我尝试更改了一种实现方式，就绕过了这个问题。关于这点，确实还是要具体问题具体分析的，在这里没有实例的话，无法给大家一个明确的解决问题的指南。&lt;/p&gt;

&lt;p&gt;（27）如何在Pig中使用正则表达式对字符串进行匹配
假设你有如下数据文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat a.txt 
1 http://ui.qq.com/abcd.html
5 http://tr.qq.com/743.html
8 http://vid.163.com/trees.php
9 http:auto.qq.com/us.php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在要找出该文件中，第二列符合“&lt;em&gt;//&lt;/em&gt;.qq.com/*”模式的所有行（此处只有前两行符合条件），怎么做？
Pig代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;a.txt&#39; AS (col1: int, col2: chararray);
B = FILTER A BY col2 matches &#39;.*//.*\\.qq\\.com/.*&#39;;  
DUMP B;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到，matches关键字对 col2 进行了正则匹配，它使用的是Java格式的正则表达式匹配规则。
. 表示任意字符，* 表示字符出现任意次数；. 对 . 进行了转义，表示匹配 . 这个字符；/ 就是表示匹配 / 这个字符。
这里需要注意的是，在引号中，用于转义的字符 \ 需要打两个才能表示一个，所以上面的 \. 就是与正则中的 . 是一样的，即匹配 . 这个字符。所以，如果你要匹配数字的话，应该用这种写法（\d表示匹配数字，在引号中必须用\d）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;B = FILTER A BY (col matches &#39;\\d.*&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后输出结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(1,http://ui.qq.com/abcd.html)
(5,http://tr.qq.com/743.html)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见结果是正确的。&lt;/p&gt;

&lt;p&gt;（28）如何截取一个字符串中的某一段
在处理数据时，如果你想提取出一个日期字符串的年份，例如提取出“2011-10-26”中的“2011”，可以用内置函数 SUBSTRING 来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SUBSTRING
Returns a substring from a given string.
Syntax
SUBSTRING(string, startIndex, stopIndex)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面举一个例子。假设有数据文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat a.txt 
2010-05-06  abc
2008-06-18  uio
2011-10-11  tyr
2010-12-23  fgh
2011-01-05  vbn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一列是日期，现在要找出所有不重复的年份有哪些，可以这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;a.txt&#39; AS (dateStr: chararray, flag: chararray);
B = FOREACH A GENERATE SUBSTRING(dateStr, 0, 4);
C = DISTINCT B;
DUMP C;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(2008)
(2010)
(2011)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见达到了我们想要的效果。
上面的代码太简单了，不必多言，唯一需要说明一下的是 SUBSTRING 函数，它的第一个参数是要截取的字符串，第二个参数是起始索引（从0开始），第三个参数是结束索引。&lt;/p&gt;

&lt;p&gt;（29）如何拼接两个字符串
假设有以下数据文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat 1.txt 
abc 123
cde 456
fgh 789
ijk 200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在要把第一列和第二列作为字符串拼接起来，例如第一行会变成“abc123”，那么使用CONCAT这个求值函数（eval function）就可以做到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;1.txt&#39; AS (col1: chararray, col2: int);
B = FOREACH A GENERATE CONCAT(col1, (chararray)col2);
DUMP B;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(abc123)
(cde456)
(fgh789)
(ijk200)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这里故意在加载数据的时候把第二列指定为int类型，这是为了说明数据类型不一致的时候CONCAT会出错（你可以试验一下）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ERROR org.apache.pig.tools.grunt.Grunt - ERROR 1045: Could not infer the matching function for org.apache.pig.builtin.CONCAT as multiple or none of them fit. Please use an explicit cast.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以在后面CONCAT的时候，对第二列进行了类型转换。
另外，如果数据文件内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat 1.txt 
5 123
7 456
8 789
0 200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，如果对两列整数CONCAT：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;1.txt&#39; AS (col1: int, col2: int);
B = FOREACH A GENERATE CONCAT(col1, col2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样也会出错：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ERROR org.apache.pig.tools.grunt.Grunt - ERROR 1045: Could not infer the matching function for org.apache.pig.builtin.CONCAT as multiple or none of them fit. Please use an explicit cast.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要注意这一点。
有人可能会问：要拼接几个字符串的话怎么办？CONCAT 套 CONCAT 就要可以了（有点笨，但管用）： CONCAT(a, CONCAT(b, c))&lt;/p&gt;

&lt;p&gt;（30）如何求两个数据集的重合 &amp;amp; 不同的数据类型JOIN会失败
假设有以下两个数据文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat 1.txt 
123
456
789
200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以及：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat 2.txt 
200
333
789
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在要找出两个文件中，相同的数据有多少行，怎么做？这也就是所谓的求两个数据集的重合。
用关系操作符JOIN，我们可以达到这个目的。在处理海量数据时，经常会有求重合的需求。所以JOIN是Pig中一个极其重要的操作。
在本例中，两个文件中有两个相同的数据行：789以及200，因此，结果应该是2。
我们先来看看正确的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;1.txt&#39; AS (a: int);   
B = LOAD &#39;2.txt&#39; AS (b: int);
C = JOIN A BY a, B BY b;
D = GROUP C ALL;
E = FOREACH D GENERATE COUNT(C);
DUMP E;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释一下：
①第一、二行是加载数据，不必多言。
②第三行按A的第1列、B的第二列进行“结合”，JOIN之后，a、b两列不相同的数据就被剔除掉了。C的数据结构为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C: {A::a: int,B::b: int}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C的数据为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(200,200)
(789,789)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③由于我们要统计的是数据行数，所以上面的Pig代码中的第4、5行就进行了计数的运算。
④如果文件 2.txt 多一行数据“200”，结果会是什么？答案是：结果为3行。这个时候C的数据为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(200,200)
(200,200)
(789,789)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以如果你要去除重复的，还需要用DISTINCE对C处理一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;1.txt&#39; AS (a: int);
B = LOAD &#39;2.txt&#39; AS (b: int);
C = JOIN A BY a, B BY b;
uniq_C = DISTINCT C;
D = GROUP uniq_C ALL;
E = FOREACH D GENERATE COUNT(uniq_C);
DUMP E;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样得到的结果就是2了。&lt;/p&gt;

&lt;p&gt;尤其需要注意的是，如果JOIN的两列具有不同的数据类型，是会失败的。例如以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;1.txt&#39; AS (a: int);   
B = LOAD &#39;2.txt&#39; AS (b: chararray);
C = JOIN A BY a, B BY b;
D = GROUP C ALL;
E = FOREACH D GENERATE COUNT(C);
DUMP E;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在语法上是没有错误的，但是一运行就会报错：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ERROR org.apache.pig.tools.grunt.Grunt - ERROR 1107: Cannot merge join keys, incompatible types&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是因为a、b具有不同的类型：int和chararray。
（31）使用三目运算符“ ? : ”有时候必须加括号
假设有以下数据文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat a.txt 
5 8 9
6   0
4 3 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，第二行的第二列数据是有缺失的，因此，加载数据之后，它会成为null。顺便废话一句，在处理海量数据时，数据有缺失是经常遇到的现象。
现在，我们如果要把所有缺失的数据填为 -1， 可以使用三目运算符来操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;a.txt&#39; AS (col1:int, col2:int, col3:int);
B = FOREACH A GENERATE col1, ((col2 is null)? -1 : col2), col3;
DUMP B;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(5,8,9)
(6,-1,0)
(4,3,1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;((col2 is null)? -1 : col2) 的含义不用解释你也知道，就是当col2为null的时候将其置为-1，否则就保持原来的值，但是注意，它最外面是用括号括起来的，如果去掉括号，写成 (col2 is null)? -1 : col2，那么就会有语法错误：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ERROR org.apache.pig.tools.grunt.Grunt - ERROR 1000: Error during parsing. Encountered “ “is” “is “” at line 1, column 36.
Was expecting one of （后面省略）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;错误提示有点不直观。所以，有时候使用三目运算符是必须要使用括号的。
（32）如何补上缺失的数据
通过前面的文章，我们已经知道了如何按自己的需求补上缺失的数据，那么这里还有一个例子，可以让你多了解一些特殊的情况。
数据文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat 1.txt 
1 (4,9)
5 
8 (3,0)
5 (9,2)
6 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些数据的布局比较怪，我们要把它加载成什么样的schema呢？答：第一列为一个int，第二列为一个tuple，此tuple又含两个int。加载成这样的模式不是为了制造复杂度，而是为了说明后面的问题而设计的。
同时，我们也注意到，第二列数据是有缺失的。
问题：怎样求在第一列数据相同的情况下，第二列数据中的第一个整数的和分别为多少？
例如，第一列为1的数据只有一行（即第一行），因此，第二列的第一个整数的和就是4。
但是对最后一行，也就是第一列为6时，由于其第二列数据缺失，我们希望它输出的结果是0。
先来看看Pig代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;1.txt&#39; AS (a:int, b:tuple(x:int, y:int));
B = FOREACH A GENERATE a, FLATTEN(b);
C = GROUP B BY a;
D = FOREACH C GENERATE group, SUM(B.x);
DUMP D;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(1,4)
(5,9)
(6,)
(8,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们注意到，(5,9) 这一行是由数据文件 1.txt 的第 2、4行计算得到的，其中，第2行数据有缺失，但这并不影响求和计算，因为另一行数据没有缺失。你可以这样想：一个包（bag）中有多个数，当其中一个为null，而其他不为null时，把它们相加会自动忽略null。
然而，第三行 (6,) 是不是太刺眼了？没错，因为数据文件 1.txt 的最后一行缺失了第二列，所以，在 SUM(B.x) 中的 B.x 为null就会导致计算结果为null，从而什么也输出不了。
这就与我们期望的输出有点不同了。我们希望这种缺失的数据不要空着，而是输出0。该怎么做呢？&lt;/p&gt;

&lt;p&gt;想法1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D = FOREACH C GENERATE group, ((IsEmpty(B.x)) ? 0 : SUM(B.x));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(1,4)
(5,9)
(6,)
(8,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见行不通。从这个结果我们知道，IsEmpty(B.x) 为false，即B.x不是empty的，所以不能这样做。
想法2：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D = FOREACH C GENERATE group, ((B.x is null) ? 0 : SUM(B.x));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果还是与上面一样！仍然行不通。这更奇怪了：B.x既非empty，也非null，那么它是什么情况？按照我的理解，当group为6时，它应该是一个非空的包（bag），里面有一个null的东西，所以，这个包不是empty的，它也非null。我不知道这样理解是否正确，但是它看上去就像是这样的。
想法3：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D = FOREACH C GENERATE group, SUM(B.x) AS s;
E = FOREACH D GENERATE group, ((s is null) ? -1 : s);
DUMP E;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(1,4)
(5,9)
(6,-1)
(8,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见达到了我们想要的结果。这与本文前面部分的做法是一致的，即：先得到含null的结果，再把这个结果中的null替换为指定的值。
有人会问：就没有办法在生成数据集D的时候，就直接通过判断语句来实现这个效果吗？据我目前所知是不行的，如果哪位读者知道，不妨告知。&lt;/p&gt;

&lt;p&gt;（33）DISTINCT操作用于去重，正因为它要把数据集合到一起，才知道哪些数据是重复的，因此，它会产生reduce过程。同时，在map阶段，它也会利用combiner来先去除一部分重复数据以加快处理速度。&lt;/p&gt;

&lt;p&gt;（34）如何将Pig job的优先级设为HIGH
嫌Pig job运行太慢？只需在Pig脚本的开头加上一句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set job.priority HIGH;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可将Pig job的优先级设为高了。&lt;/p&gt;

&lt;p&gt;（35）“Scalars can be only used with projections”错误的原因
这个错误提示比较不直观，光看这句话是不容易发现错误所在的，但是，只要你一Google，可能就找到原因了，例如这个链接里的反馈。
在这里，我也想用一个简单的例子给大家用演示一下产生这个错误的原因之一。
假设有如下数据文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]$ cat 1.txt 
a 1
b 8
c 3
c 3
d 6
d 3
c 5
e 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在要统计：在第1列的每一种组合下，第二列为3和6的数据分别有多少条？
例如，当第1列为 c 时，第二列为3的数据有2条，为6的数据有0条；当第1列为d时，第二列为3的数据有1条，为6的数据有1条。其他的依此类推。
Pig代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;1.txt&#39; AS (col1:chararray, col2:int);
B = GROUP A BY col1;
C = FOREACH B {
  D = FILTER A BY col2 == 3;
  E = FILTER A BY col2 == 6;
  GENERATE group, COUNT(D), COUNT(E);
};
DUMP C;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(a,0,0)
(b,0,0)
(c,2,0)
(d,1,1)
(e,0,0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见结果是正确的。&lt;/p&gt;

&lt;p&gt;那么，如果我在上面的代码中，把“D = FILTER A BY col2 == 3”不小心写成了“D = FILTER B BY col2 == 3”，就肯定会得到“Scalars can be only used with projections”的错误提示。
说白了，还是要时刻注意你每一步生成的数据的结构，眼睛睁大，千万不要用错了relation。&lt;/p&gt;

&lt;p&gt;（36）什么是嵌套的FOREACH/内部的FOREACH
嵌套的（nested）FOREACH和内部的（inner）FOREACH是一个意思，正如你在本文第(35)条中所见，一个FOREACH可以对每一条记录施以多种不同的关系操作，然后再GENERATE得到想要的结果，这就是嵌套的/内部的FOREACH。&lt;/p&gt;

&lt;p&gt;（37）错误“Could not infer the matching function for org.apache.pig.builtin.CONCAT”的原因之一
如果你遇到这个错误，那么有可能是你在多级CONCAT嵌套的时候，没有写对语句，例如“CONCAT(CONCAT(CONCAT(a, b), c), d)”这样的嵌套，由于括号众多，所以写错了是一点也不奇怪的。我遇这个错误的时候，是由于CONCAT太多，自己多写了一个都没有发现。希望我的提醒能给你一点解决问题的提示。&lt;/p&gt;

&lt;p&gt;（38）用Pig加载HBase数据时遇到的错误“ERROR 2999: Unexpected internal error. could not instantiate ‘com.twitter.elephantbird.pig.load.HBaseLoader’ with arguments XXX”的原因之一
请看这个链接：《Apache Pig中文教程（进阶）》&lt;/p&gt;

&lt;p&gt;（39）错误“ERROR 1039: In alias XX, incompatible types in EqualTo Operator left hand side:XXX right hand side:XXX”的原因
其实这个错误提示太明显了，就是类型不匹配造成的。上面的XXX可以指代不同的类型。
这说明，前面可能有一个类型为long的字段，后面你却把它当chararray来用了，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;1.txt&#39; AS (col1: int, col2: long);
B = FILTER A BY col2 == &#39;123456789&#39;;
C = GROUP B ALL;
D = FOREACH C GENERATE COUNT(B);
DUMP D;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就会出错：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ERROR 1039: In alias B, incompatible types in EqualTo Operator left hand side:long right hand side:chararray&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;只要把col2强制类型转换一下（或者一开始就将其类型指定为chararray）就可以解决问题。&lt;/p&gt;

&lt;p&gt;不仅在进行数据比较中，在JOIN时也经常出现数据类型不匹配导致的错误问题。我在实际工作中发现，有的同学写了比较长的Pig代码，出现了这样的错误却不会仔细去看错误提示，而是绞尽脑汁地逐句去检查语法（语法是没有错的），结果费了很大的劲才知道是类型问题，得不偿失，还不如仔细看错误提示想想为什么。&lt;/p&gt;

&lt;p&gt;（40）在grunt交互模式下，如何在编辑Pig代码的时候跳到行首和行末/行尾
在grunt模式下，如果你写了一句超长的Pig代码，那么，你想通过HOME/END键跳到行首和行末是做不到的。
按HOME时，Pig会在你的光标处插入一个“1~”：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;1.txt&#39; AS (col: int1~);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按END时，Pig会在你的光标处插入一个“4~”：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;1.txt&#39; AS (col: int4~);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正确的做法是：按Ctrl+A 和 Ctrl+E 代替 HOME 和 END，就可以跳到行首和行末了。&lt;/p&gt;

&lt;p&gt;（41）不能对同一个关系（relation）进行JOIN
假设有如下文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat 1.txt 
1 a
2 e
3 v
4 n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我想对第一列这样JOIN：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;1.txt&#39; AS (col1: int, col2: chararray); 
B = JOIN A BY col1, A BY col1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么当你试图 DUMP B 的时候，会报如下的错：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ERROR org.apache.pig.tools.grunt.Grunt - ERROR 1108: Duplicate schema alias: A::col1 in “B”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是因为Pig会弄不清JOIN之后的字段名——两个字段均为A::col1，使得一个关系（relation）中出现了重复的名字，这是不允许的。&lt;/p&gt;

&lt;p&gt;要解决这个问题，只需将数据LOAD两次，并且给它们起不同的名字就可以了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; A = LOAD &#39;1.txt&#39; AS (col1: int, col2: chararray);
grunt&amp;gt; B = LOAD &#39;1.txt&#39; AS (col1: int, col2: chararray);
grunt&amp;gt; C = JOIN A BY col1, B BY col1;                   
grunt&amp;gt; DESCRIBE C;
C: {A::col1: int,A::col2: chararray,B::col1: int,B::col2: chararray}
grunt&amp;gt; DUMP C;
(1,a,1,a)
(2,e,2,e)
(3,v,3,v)
(4,n,4,n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的 C 的schema，你可以看出来，如果对同一个关系A的第一列进行JOIN，会导致schema中出现相同的字段名，所以当然会出错。&lt;/p&gt;

&lt;p&gt;（42）外部的JOIN(outer JOIN)
初次使用JOIN时，一般人使用的都是所谓的“内部的JOIN”(inner JOIN)，也即类似于 C = JOIN A BY col1, B BY col2 这样的JOIN。Pig也支持“外部的JOIN”(outer JOIN)，下面就举一个例子。
假设有文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat 1.txt 
1 a
2 e
3 v
4 n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以及：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat 2.txt 
9 a
2 e
3 v
0 n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在来对这两个文件的第一列作一个outer JOIN：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; A = LOAD &#39;1.txt&#39; AS (col1: int, col2: chararray);
grunt&amp;gt; B = LOAD &#39;2.txt&#39; AS (col1: int, col2: chararray);
grunt&amp;gt; C = JOIN A BY col1 LEFT OUTER, B BY col1;
grunt&amp;gt; DESCRIBE C;
C: {A::col1: int,A::col2: chararray,B::col1: int,B::col2: chararray}
grunt&amp;gt; DUMP C;
(1,a,,)
(2,e,2,e)
(3,v,3,v)
(4,n,,)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在outer JOIN中，“OUTER”关键字是可以省略的。从上面的结果，我们注意到：如果换成一个inner JOIN，则两个输入文件的第一、第四行都不会出现在结果中（因为它们的第一列不相同），而在LEFT OUTER JOIN中，文件1.txt的第一、四行却被输出了，所以这就是LEFT OUTER JOIN的特点：对左边的记录来说，即使它与右边的记录不匹配，它也会被包含在输出数据中。&lt;/p&gt;

&lt;p&gt;同理可知RIGHT OUTER JOIN的功能——把上面的 LEFT 换成 RIGHT，结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(,,0,n)
(2,e,2,e)
(3,v,3,v)
(,,9,a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，与左边的记录不匹配的右边的记录被保存了下来，而左边的记录没有保存下来（两个逗号表明其为空），这就是RIGHT OUTER JOIN的效果，与我们想像的一样。
有人会问，OUTER JOIN在实际中可以用来做什么？举一个例子：可以用来求“不在某数据集中的那些数据（即：不重合的数据）”。还是以上面的两个数据文件为例，现在我要求出 1.txt 中，第一列不在 2.txt 中的第一列的那些记录，肉眼一看就知道，1和4这两个数字在 2.txt 的第一列里没有出现，而2和3出现了，因此，我们要找的记录就是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 a
4 n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要实现这个效果，Pig代码及结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; A = LOAD &#39;1.txt&#39; AS (col1: int, col2: chararray);
grunt&amp;gt; B = LOAD &#39;2.txt&#39; AS (col1: int, col2: chararray);
grunt&amp;gt; C = JOIN A BY col1 LEFT OUTER, B BY col1;        
grunt&amp;gt; DESCRIBE C;                 
C: {A::col1: int,A::col2: chararray,B::col1: int,B::col2: chararray}
grunt&amp;gt; D = FILTER C BY (B::col1 is null); 
grunt&amp;gt; E = FOREACH D GENERATE A::col1 AS col1, A::col2 AS col2;
grunt&amp;gt; DUMP E;
(1,a)
(4,n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，我们确实找出了“不重合的记录”。在作海量数据分析时，这种功能是极为有用的。
最后来一个总结：
假设有两个数据集（在1.txt和2.txt中），分别都只有1列，则如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;1.txt&#39; AS (col1: chararray);
B = LOAD &#39;2.txt&#39; AS (col1: chararray);  
C = JOIN A BY col1 LEFT OUTER, B BY col1;
D = FILTER C BY (B::col1 is null);
E = FOREACH D GENERATE A::col1 AS col1;                 
DUMP E;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;计算结果为：在A中，但不在B中的记录。&lt;/p&gt;

&lt;p&gt;（43）JOIN的优化
请看这个链接：《Apache Pig中文教程（进阶）》&lt;/p&gt;

&lt;p&gt;（44）GROUP时按所有字段分组可以用GROUP ALL吗
假设你有如下数据文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat 3.txt 
1 9
2 2
3 3
4 0
1 9
1 9
4 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在要找出第1、2列的组合中，每一种的个数分别为多少，例如，(1,9)组合有3个，(4,0)组合有两个，依此类推。
显而易见，我们只需要用GROUP就可以轻易完成这个任务。于是写出如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;3.txt&#39; AS (col1: int, col2: int);
B = GROUP A ALL;
C = FOREACH B GENERATE group, COUNT(A);
DUMP C;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可惜，结果不是我们想要的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(all,7)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么呢？我们的本意是按所有列来GROUP，于是使用了GROUP ALL，但是这实际上变成了统计行数，下面的代码就是一段标准的统计数据行数的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;3.txt&#39; AS (col1: int, col2: int);
B = GROUP A ALL;
C = FOREACH B GENERATE COUNT(A);
DUMP C;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，上面的 C = FOREACH B GENERATE group, COUNT(A) 也无非就是多打印了一个group的名字（all）而已——group的名字被设置为“all”，这是Pig帮你做的。&lt;/p&gt;

&lt;p&gt;正确的做法很简单，只需要按所有字段GROUP，就可以了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;3.txt&#39; AS (col1: int, col2: int);
B = GROUP A BY (col1, col2);
C = FOREACH B GENERATE group, COUNT(A);
DUMP C;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;((1,9),3)
((2,2),1)
((3,3),1)
((4,0),2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这与我们前面分析的正确结果是一样的。&lt;/p&gt;

&lt;p&gt;（45）在Pig中使用中文字符串
有读者来信问我，如何在Pig中使用中文作为FILTER的条件？我做了如下测试，结论是可以使用中文。
数据文件 data.txt 内容为（每一列之间以TAB为分隔符）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 北京市 a
2 上海市 b
3 北京市 c
4 北京市 f
5 天津市 e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pig脚本文件 test.pig 内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;data.txt&#39; AS (col1: int, col2: chararray, col3: chararray);
B = FILTER A BY (col2 == &#39;北京市&#39;);
DUMP B;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，我这两个文件的编码都是UTF-8(无BOM)，在Linux命令行下，我直接以本地模式执行Pig脚本 test.pig：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pig -x local test.pig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到的输出结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(1,北京市,a)
(3,北京市,c)
(4,北京市,f)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见结果是正确的。&lt;/p&gt;

&lt;p&gt;但是，如果我在grunt交互模式下，把 test.pig 的内容粘贴进去执行，是得不到任何输出结果的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; A = LOAD &#39;data.txt&#39; AS (col1: int, col2: chararray, col3: chararray);
grunt&amp;gt; B = FILTER A BY (col2 == &#39;北京市&#39;);
grunt&amp;gt; DUMP B;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体原因我不清楚，但是至少有一点是肯定的：可以使用中文作为FILTER的条件，只要不在交互模式下执行你的Pig脚本即可。&lt;/p&gt;

&lt;p&gt;（46）如何统计 tuple 中的 field 数，bag 中的 tuple 数，map 中的 key/value 组数
一句话：用Pig内建的 SIZE 函数：&lt;/p&gt;

&lt;p&gt;Computes the number of elements based on any Pig data type.
具体可看这个链接。&lt;/p&gt;

&lt;p&gt;（47）一个字符串为null，与它为空不一定等价
在某些情况下，要获取“不为空”的字符串，仅仅用 is not null 来判断是不够的，还应该加上 SIZE(field_name) &amp;gt; 0 的条件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;B = FILTER A BY (field_name is not null AND (SIZE(field_name) &amp;gt; 0L));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，这只是在某些情况下需要这样做，在一般情况下，仅用 is not null 来过滤就可以了。我并没有总结出特殊情况是哪些情况，我只能说我我不是第一次遇到此情况了，所以才有了这一个结论。
注意上面使用的是“0L”，因为SIZE()返回的是long类型，如果不加L，在Pig0.10下会出现一个警告，例如：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[main] WARN  org.apache.pig.PigServer - Encountered Warning IMPLICIT_CAST_TO_LONG 1 time(s)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（48）Pig中的各operator（操作符），哪些会触发reduce过程
①GROUP：由于GROUP操作会将所有具有相同key的记录收集到一起，所以数据如果正在map中处理的话，就会触发shuffle→reduce的过程。
②ORDER：由于需要将所有相等的记录收集到一起（才能排序），所以ORDER会触发reduce过程。同时，除了你写的那个Pig job之外，Pig还会添加一个额外的M-R job到你的数据流程中，因为Pig需要对你的数据集做采样，以确定数据的分布情况，从而解决数据分布严重不均的情况下job效率过于低下的问题。
③DISTINCT：由于需要将记录收集到一起，才能确定它们是不是重复的，因此DISTINCT会触发reduce过程。当然，DISTINCT也会利用combiner在map阶段就把重复的记录移除。
④JOIN：JOIN用于求重合，由于求重合的时候，需要将具有相同key的记录收集到一起，因此，JOIN会触发reduce过程。
⑤LIMIT：由于需要将记录收集到一起，才能统计出它返回的条数，因此，LIMIT会触发reduce过程。
⑥COGROUP：与GROUP类似（参看本文前面的部分），因此它会触发reduce过程。
⑦CROSS：计算两个或多个关系的叉积。&lt;/p&gt;

&lt;p&gt;（49）如何统计一个字符串中包含的指定字符数
这可以不算是个Pig的问题了，你可以把它认为是一个shell的问题。从本文前面部分我们已经知道，Pig中可以用 STREAM … THROUGH 来调用shell进行辅助数据处理，所以在这我们也能这样干。
假设有文本文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]$ cat 1.txt 
123 abcdef:243789174
456 DFJKSDFJ:3646:555558888
789 yKDSF:00000%0999:2343324:11111:33333
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在要统计：每一行中，第二列里所包含的冒号（“:”）分别为多少？代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = LOAD &#39;1.txt&#39; AS (col1: chararray, col2: chararray);
B = STREAM A THROUGH `awk -F&quot;:&quot; &#39;{print NF-1}&#39;` AS (colon_count: int);
DUMP B;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(1)
(2)
(4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（50）UDF是区分大小写的
因为UDF是由Java类来实现的，所以区分大小写，就这么简单。&lt;/p&gt;

&lt;p&gt;（51）设置Pig job的job name
在Pig脚本开头加上一句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set job.name &#39;My-Job-Name&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，执行该Pig脚本之后，在Hadoop的Job Tracker中看到的“Name”就是“My-Job-Name”了。
如果不设置，显示的name是类似于“Job6245768625829738970.jar”这样的东西，job多的时候完全没有标识度，建议一定要设置一个特殊的job name。&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>Pig解析中文文档</title>
     <link href="http://ningg.github.com/pig-deal-with-chinese"/>
     <updated>2014-05-09T00:00:00+08:00</updated>
     <id>http://ningg.github.com/pig-deal-with-chinese</id>
     <content type="html">&lt;p&gt;&lt;code&gt;Pig&lt;/code&gt;处理文档时，&lt;code&gt;LOAD&lt;/code&gt;和&lt;code&gt;STORE&lt;/code&gt;默认数据是&lt;code&gt;UTF-8&lt;/code&gt;编码格式（参考来源？官方文档/源码）。因此，包含中文字符的数据文档，应以&lt;code&gt;UTF-8&lt;/code&gt;格式存储；相应的包含中文字符的pig脚本，也应以&lt;code&gt;UTF-8&lt;/code&gt;格式存储。&lt;/p&gt;

&lt;p&gt;本文简介：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;中文文档如何转码，特别是&lt;code&gt;Linux&lt;/code&gt;下利用&lt;code&gt;iconv&lt;/code&gt;命令转码时的注意事项；&lt;/li&gt;
  &lt;li&gt;使用&lt;code&gt;SecuryCRT&lt;/code&gt;/&lt;code&gt;putty&lt;/code&gt;客户端连接服务器时，中文文档显示乱码的解决办法；&lt;/li&gt;
  &lt;li&gt;Pig脚本解析中文文档的步骤；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;utf-8&quot;&gt;将文档存储为UTF-8格式&lt;/h2&gt;

&lt;p&gt;在&lt;code&gt;windows&lt;/code&gt;下，可以使用&lt;code&gt;notepad++&lt;/code&gt;来进行文档转码：
&lt;code&gt;Encoding&lt;/code&gt;–&lt;code&gt;Convert to UTF-8 without BOM&lt;/code&gt;，则当前文档转换为&lt;code&gt;UTF-8&lt;/code&gt;编码方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/pig-deal-with-chinese/convert-utf8.png&quot; alt=&quot;convert-utf8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（思考：文档编码格式转换的原理？在linux下有没有类似的转换工具/命令？）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;下使用&lt;code&gt;iconv&lt;/code&gt;可以进行编码格式转换，具体操作如下：&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;查看文档编码方式：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;file –i origin.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/pig-deal-with-chinese/file-i.png&quot; alt=&quot;file-i&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;对文档转码：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 下面命令中 origin.txt.utf8为输出文件。
iconv –f ISO-8859-1 –t UTF-8 &amp;lt; origin.txt &amp;gt; origin.txt.utf8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;特别说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;如果&lt;code&gt;iconv&lt;/code&gt;转码命令，出现&lt;code&gt;iconv: illegal input sequence at position 42&lt;/code&gt;错误信息，则可以使用如下命令进行转码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iconv –f gbk –t UTF-8 &amp;lt; origin.txt &amp;gt; origin.txt.gbk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（思考：上面的原因是否是&lt;code&gt;file&lt;/code&gt;命令查询结果不精确，查询文件的编码方式，&lt;code&gt;linux&lt;/code&gt;下还有其他的命令吗？）&lt;/p&gt;

&lt;p&gt;（思考：不同的编码格式的差异？为什么有多种编码？对应的应用场景？）&lt;/p&gt;

&lt;h3 id=&quot;iconv&quot;&gt;iconv转码出错[重要]&lt;/h3&gt;

&lt;p&gt;当对&lt;code&gt;1G&lt;/code&gt;以上的大文件，进行转码时：如果按照如下命令进行转码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 下面命令中 origin.txt.utf8为输出文件。
iconv –f gbk –t UTF-8 &amp;lt; origin.txt &amp;gt; origin.txt.utf8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能仍然会出错：&lt;code&gt;iconv: illegal input sequence at position 91401042&lt;/code&gt;，查看&lt;code&gt;origin.txt.utf8&lt;/code&gt;文件，其内中文已经正常显示，只是原始文件在某个位置出现问题，没能完成整个文档的转码。&lt;/p&gt;

&lt;p&gt;原因排查：是否是原始文件中真的有字符无法转码？还是文件过大？&lt;/p&gt;

&lt;p&gt;排查措施：使用&lt;code&gt;split&lt;/code&gt;、&lt;code&gt;head&lt;/code&gt;等命令对文件分割之后，在相应位置仍然出错；&lt;/p&gt;

&lt;p&gt;原因确定：是原始文件有非法字符，&lt;code&gt;GBK&lt;/code&gt;中不存在的编码，&lt;code&gt;GBK&lt;/code&gt;自己无法识别，因此无法转码。&lt;/p&gt;

&lt;p&gt;解决途径：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;删除有乱码的行？（使用wc –l 、 sed –i 等命令；） &lt;/li&gt;
  &lt;li&gt;跳过有乱码的几个字符？&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;iconv&lt;/code&gt;有没有强制转换，忽略/跳过错误？（尼玛，恭喜你，猜对了，有这么个机制）&lt;/li&gt;
  &lt;li&gt;使用 &lt;code&gt;man iconv&lt;/code&gt;查询不到，应该使用&lt;code&gt;iconv –help&lt;/code&gt;，查看命令的帮助。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最终命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iconv –f gbk –t utf-8//IGNORE &amp;lt; input &amp;gt; output 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搞定。&lt;/p&gt;

&lt;p&gt;参考来源：&lt;/p&gt;

&lt;p&gt;[1]	http://www.aiezu.com/system/linux/linux_iconv_code.html
[2] http://www.linuxquestions.org/questions/linux-newbie-8/usr-bin-iconv-illegal-input-sequence-at-position-905152/&lt;/p&gt;

&lt;h2 id=&quot;linux&quot;&gt;将文档传到远端linux服务器&lt;/h2&gt;

&lt;p&gt;注意：在传输过程中，应尽量保持文档的属性/编码方式保持不变。
仅仅是将&lt;code&gt;windows&lt;/code&gt;下文档传递到远端linux服务器上，方法很多：&lt;code&gt;fileZilla&lt;/code&gt;、&lt;code&gt;WinSCP&lt;/code&gt;等，下面说一种不需要安装软件的方法（亲，不要想错了，需要下载软件的，只是软件很小，不需要安装）。
下载&lt;code&gt;PSCP&lt;/code&gt;，文件300k，果真很小；现在工具有了，如何利用&lt;code&gt;PSCP&lt;/code&gt;来向远端&lt;code&gt;linux&lt;/code&gt;传送文件呢？操作如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//-p : preserve file attributes.（传送过程中，保持文件属性不变）
scp –p originalFile user@ip:/home/user/destFold
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面命令会将本地&lt;code&gt;originalFile&lt;/code&gt;文件，无失真传送到服务器&lt;code&gt;/home/user/destFold&lt;/code&gt;目录下。&lt;/p&gt;

&lt;p&gt;在远端&lt;code&gt;linux&lt;/code&gt;服务器上，如何查看文档的具体编码方式呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file –i filename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用上述命令来确认文件的编码方式。&lt;/p&gt;

&lt;p&gt;现在按照&lt;code&gt;utf-8&lt;/code&gt;编码的文件，已经在服务器上了，那原材料就齐全了，开始处理吧。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;远端服务器上，中文显示乱码&lt;/h2&gt;

&lt;p&gt;既然要操作远端&lt;code&gt;linux&lt;/code&gt;服务器，最好要建立持久的连接，常用的方式：&lt;code&gt;putty&lt;/code&gt;、&lt;code&gt;secureCRT&lt;/code&gt;。然而，查看服务器上的中文文档时，可能出现乱码。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;服务器的基本环境&lt;/h3&gt;

&lt;p&gt;针对上述情况，需要先检查一下服务器上设置的语言环境。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $LANG
// 上述输出结果为：en_US.UTF-8

更进一步，查看3个文件，看LANG具体如何配置的：
cat /etc/sysconfig/i18n
//上述输出结果为：LANG=”en_US.UTF-8”

cat ~/.bash_profile
//上述输出结果中，没有LANG的配置

cat ~//.bashrc
//上述输出结果中，没有LANG的配置
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（思考：LANG的配置有什么用？LANG不就是个环境变量吗？）&lt;/p&gt;

&lt;h3 id=&quot;putty&quot;&gt;Putty连接服务器&lt;/h3&gt;

&lt;p&gt;设置方式：
&lt;code&gt;Window&lt;/code&gt;–&lt;code&gt;Translation&lt;/code&gt;–&lt;code&gt;Character set translation&lt;/code&gt;–&lt;code&gt;Remote character set&lt;/code&gt;，选中“UTF-8”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/pig-deal-with-chinese/putty-utf8.png&quot; alt=&quot;putty-utf8.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Window&lt;/code&gt;–&lt;code&gt;Appearance&lt;/code&gt;–&lt;code&gt;Font settings&lt;/code&gt;–&lt;code&gt;Font used in terminal window&lt;/code&gt;，选中&lt;code&gt;Courier New&lt;/code&gt;（尝试其他字体也可以解决中文乱码）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/pig-deal-with-chinese/putty-appearance.png&quot; alt=&quot;putty-appearance&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;securecrt&quot;&gt;SecureCRT连接服务器&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;选项&lt;/code&gt;–&lt;code&gt;会话选项&lt;/code&gt;–&lt;code&gt;终端&lt;/code&gt;–&lt;code&gt;外观&lt;/code&gt;–&lt;code&gt;字体&lt;/code&gt;，&lt;code&gt;字符编码&lt;/code&gt;选中&lt;code&gt;UTF-8&lt;/code&gt;；
&lt;code&gt;标准字体&lt;/code&gt;选中&lt;code&gt;幼圆&lt;/code&gt;（宋体等其他也可以）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/pig-deal-with-chinese/securecrt-appearance.png&quot; alt=&quot;securecrt-appearance&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/pig-deal-with-chinese/securecrt-font.png&quot; alt=&quot;securecrt-font&quot; /&gt;&lt;/p&gt;

&lt;p&gt;OK，到现在位置，使用&lt;code&gt;putty&lt;/code&gt;/&lt;code&gt;secureCRT&lt;/code&gt;连接远程服务器，再查看&lt;code&gt;UTF-8&lt;/code&gt;编码的中文文档时，就不会出现乱码了。下面测试一下效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;less filename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/pig-deal-with-chinese/less.png&quot; alt=&quot;less.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;pig&quot;&gt;Pig脚本解析中文文档&lt;/h2&gt;

&lt;p&gt;千呼万唤始出来、犹抱琵琶半遮面，使用pig来解析中文文档是本文的重点，却姗姗来迟。好的，先来回顾一下前面的工作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将pig脚本&lt;code&gt;select_rows.pig&lt;/code&gt;使用UTF-8格式编码、待分析的文档&lt;code&gt;sfzf.log&lt;/code&gt;也使用&lt;code&gt;UTF-8&lt;/code&gt;格式编码；&lt;/li&gt;
  &lt;li&gt;将两个文件传送到linux服务器上，并且使用&lt;code&gt;file –i filename&lt;/code&gt; 命令查看，确保其都为&lt;code&gt;UTF-8&lt;/code&gt;的编码格式；&lt;/li&gt;
  &lt;li&gt;设置&lt;code&gt;secureCRT&lt;/code&gt;或者&lt;code&gt;putty&lt;/code&gt;，保证其查阅中文文档时，无乱码；&lt;/li&gt;
  &lt;li&gt;到这一步了，直接运行pig脚本&lt;code&gt;select_rows.pig&lt;/code&gt;就可以了~哈哈（对，pig解析中文文档，就这么简单）；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Pig脚本&lt;code&gt;select_rows.pig&lt;/code&gt;内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* 查找输入文档中，包含关键字“时间”的行，并输出 */
A = load &#39;$input&#39; as (col1:chararray);
B = filter A by ($col1 matches &#39;.*时间.*&#39;);

store B into &#39;$output&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pig –x local –param input=sfzf.log –param output=out4 select_rows.pig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/pig-deal-with-chinese/result.png&quot; alt=&quot;result&quot; /&gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>Pig入门1h</title>
     <link href="http://ningg.github.com/introduction-to-pig"/>
     <updated>2014-05-08T00:00:00+08:00</updated>
     <id>http://ningg.github.com/introduction-to-pig</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;开篇先推荐一个PPT：&lt;a href=&quot;/download/pig/introduction-to-pig.pptx&quot; title=&quot;Pig简介，原理，简要说明&quot;&gt;Pig简介&lt;/a&gt;，简要介绍了Pig的基本原理，重点说明了其与MapReduce的关系。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;副标题&lt;/strong&gt;: Pig入门 &lt;em&gt;_之_&lt;/em&gt; 乱拳打死老师傅&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;从副标题展开说&lt;/h2&gt;

&lt;p&gt;先说一下为什么起这么一个副标题：前几天看电视剧消遣，有个小年轻，被质疑没有经验怎么办的时候，自己吹牛打气，说“我啥也不会，乱拳打死老师傅…”；这个，倒不是说对师傅的不尊敬，而是民间俗语，大概意思是：啥也不会的情况下，受领域内固有思想、规则约束的少，敢打敢拼，敢于突破陈规，往往能够带来新气象。&lt;em&gt;（不是要煽动大家起义、造反，而是，鼓励勇于突破、敢为天下先）。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Pig知识的学习\介绍，大部分人会按照如下思路开展：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pig解决什么问题；&lt;em&gt;（pig产生背景）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Pig Latin语言的基本语法；&lt;em&gt;（配合一些基本操作）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Pig Latin语言的高级语法；&lt;em&gt;（针对一些特有的、容易出错的用法，进行详细介绍）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Pig脚本的调试；&lt;em&gt;（脚本不是一气呵成的，需要一些调试分析手段）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Pig的可扩展部分；&lt;em&gt;（Pig提供的内建函数，无法满足需求时，需要自己动手来实现Pig的对外接口）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Pig性能调优；&lt;em&gt;（上面所有的步骤，都在说如何去使用Pig来完成一件事，现在会说一下如何把事做好、做漂亮）&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要这么多吗？学个东西，有这么复杂吗？&lt;em&gt;（上面开展的思路，是为了循序渐进、由浅入深，让你从原理到操作，能有一个全面的理解和掌握，嗯，一句话：为你好，才这么安排的）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;纳尼？我想说，你能直接一点么？上面&lt;code&gt;1、2、3、4、5、6&lt;/code&gt;，看起来头都大了，唉，我只想使用Pig，不想知道他是怎么来的。&lt;/p&gt;

&lt;p&gt;妥了，是个爽快的人，也算志同道合了，不多说：直接开始一步一步用Pig，让那些乱七八糟的东西见鬼去吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/introduction-to-pig/pig-logo.jpg&quot; alt=&quot;pig-logo&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;pig&quot;&gt;Pig用起来&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;一个例子&lt;/h3&gt;

&lt;p&gt;准备数据文件&lt;code&gt;student&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cat student
Jun L. 	18	3.7
Hhui H.	18	3.8
Ning G.	20	3.6
Hlong G.	22	3.6
Chang W.	21	3.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：上述文件中，姓名、年龄、GPA之间都以TAB键分隔；&lt;/p&gt;

&lt;p&gt;目标：求20岁以下和20岁以上的学生的人数以及gpa平均值&lt;/p&gt;

&lt;p&gt;进入执行Pig 脚本的交互模式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$pig –x local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;逐行输入如下pig脚本(&lt;code&gt;student_avg_gpa.pig&lt;/code&gt;)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;studentInfos = load ’student’ as (name: chararray, age:int, gpa:float);
studentBag = group studentInfos all;
result = foreach studentBag {
  student_younger = filter studentInfos by age &amp;lt;= 20;
  student_older = filter studentInfos by age &amp;gt; 20;
  generate COUNT(studentInfos) as totalNum, AVG(studentInfos.gpa) as avgGPA, 
	COUNT(student_younger) as youngerNum, AVG(student_younger.gpa) as youngerAvgGPA, 
	COUNT(student_older) as olderNum, AVG(student_older.gpa) as olderAvgGPA;
}
dump result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到结果了吗？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(5,3.659999942779541,3,3.699999968210856,2,3.5999999046325684)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;总共6个值（&lt;code&gt;,&lt;/code&gt;逗号分割）。&lt;/p&gt;

&lt;p&gt;对于结果的说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;总共5人；平均GPA：约3.66；&lt;/li&gt;
  &lt;li&gt;20岁以下（包含20岁）3人；平均GPA：约3.70；（pig对于float数据运算有误差）&lt;/li&gt;
  &lt;li&gt;20岁以上2人；平均GPA：约3.60；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;简要说一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; studentInfos = load ‘student’ as (name: chararray, age:int, gpa:float);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;load&lt;/code&gt;为加载数据的关键字，’student’表示数据文件位置，&lt;code&gt;as&lt;/code&gt; 关键字为前面数据文件指定field别名和field类型。&lt;/p&gt;

&lt;p&gt;可以使用如下命令，来查看一个&lt;code&gt;studentInfos&lt;/code&gt;的数据结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; describe studentInfos
studentInfos: {name: chararray,age: int,gpa: float}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用如下命令，查看&lt;code&gt;studentInfos&lt;/code&gt;的具体内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; dump studentInfos;
(Jun L.,18,3.7)
(Hhui H.,18,3.8)
(Ning G.,20,3.6)
(Hlong G.,22,3.6)
(Chang W.,21,3.6)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面 &lt;code&gt;describe&lt;/code&gt;、&lt;code&gt;dump&lt;/code&gt;命令输出的内容到底是什么玩意儿？&lt;/p&gt;

&lt;p&gt;我们来解释一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;studentInfos: {name: chararray,age: int,gpa: float}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示&lt;code&gt;studentInfos&lt;/code&gt;的结构：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;studentInfos&lt;/code&gt;是一个&lt;code&gt;relation&lt;/code&gt;，因为&lt;code&gt;studentInfos:{}&lt;/code&gt;指向&lt;code&gt;{}&lt;/code&gt;花括号；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;studentInfos&lt;/code&gt;内，&lt;code&gt;tuple&lt;/code&gt;的结构为：&lt;code&gt;(name: chararray,age: int,gpa: float)&lt;/code&gt;，即，包含3个字段，依次为&lt;code&gt;name&lt;/code&gt;、&lt;code&gt;age&lt;/code&gt;、&lt;code&gt;gpa&lt;/code&gt;，名字后&lt;code&gt;:&lt;/code&gt;之后为对应的类型；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面提到的&lt;code&gt;relation&lt;/code&gt;、&lt;code&gt;tuple&lt;/code&gt;是什么？从哪冒出来的？客官莫要着急，&lt;code&gt;relation&lt;/code&gt;、&lt;code&gt;tuple&lt;/code&gt;都是&lt;code&gt;Pig&lt;/code&gt;内部的几个概念，且听我慢慢道来。&lt;/p&gt;

&lt;p&gt;Pig定义了几个基本概念，用于描述数据结构：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;field&lt;/code&gt;，字段，某一位置的数据，即，(Jun L.,18,3.7)中包含了3个字段；类似RDBMS中Table中一行数据的一个字段；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;tuple&lt;/code&gt;，元组，是field的有序组合，使用&lt;code&gt;()&lt;/code&gt;来标识，即，&lt;code&gt;(Jun L.,18,3.7)&lt;/code&gt;表示一个tuple；类似RDBMS中Table中一行数据；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;bag&lt;/code&gt;，包，是tuple的无序组合，使用”{}”来标识，即，{(Jun L.,18,3.7),(Hhui H.,18,3.8)}表示包含2个&lt;code&gt;tuple&lt;/code&gt;的一个&lt;code&gt;bag&lt;/code&gt;；类似RDBMS中的一个Table；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;relation&lt;/code&gt;，关系，&lt;code&gt;outer bag&lt;/code&gt;，在此，暂时将&lt;code&gt;relation&lt;/code&gt;与&lt;code&gt;bag&lt;/code&gt;等价看待；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;：&lt;code&gt;field&lt;/code&gt;可以为任何类型，即，&lt;code&gt;tuple&lt;/code&gt;、&lt;code&gt;bag&lt;/code&gt;都可以作为&lt;code&gt;field&lt;/code&gt;，包含在&lt;code&gt;tuple&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;现在再回过头看一下，&lt;code&gt;studentInfos&lt;/code&gt;的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; describe studentInfos
studentInfos: {name: chararray,age: int,gpa: float}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是很明朗了？&lt;em&gt;（什么？还不明朗？把上面的分析读3遍）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;有人问&lt;code&gt;studentInfos: {name: chararray,age: int,gpa: float}&lt;/code&gt;中，&lt;code&gt;studentInfos&lt;/code&gt;这个&lt;code&gt;relation&lt;/code&gt;内部不应该是&lt;code&gt;tuple&lt;/code&gt;吗？&lt;code&gt;tuple&lt;/code&gt;不是应该以&lt;code&gt;()&lt;/code&gt;标识吗？为什么不是&lt;code&gt;studentInfos: {(name: chararray,age: int,gpa: float)}&lt;/code&gt;？这是因为&lt;code&gt;studentInfos&lt;/code&gt;中的&lt;code&gt;tuple&lt;/code&gt;不在一行，是分行输出的，下面会看到如果&lt;code&gt;relation&lt;/code&gt;中&lt;code&gt;tuple&lt;/code&gt;都在一行的情景。&lt;/p&gt;

&lt;p&gt;将&lt;code&gt;studentInfos&lt;/code&gt;按照所有字段进行&lt;code&gt;group&lt;/code&gt;，即使有某2个&lt;code&gt;tuple&lt;/code&gt;内容完全一致，也会统计为2个&lt;code&gt;tuple&lt;/code&gt;，即，本质上&lt;code&gt;group..all&lt;/code&gt;是将多行数据合并为一行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; studentBag = group studentInfos all;

grunt&amp;gt; describe studentBag;
studentBag: {group: chararray,studentInfos: {(name: chararray,age: int,gpa: float)}}

grunt&amp;gt; dump studentBag;
(all,{(Jun L.,18,3.7),(Hhui H.,18,3.8),(Ning G.,20,3.5),(Hlong G.,22,3.6),(Chang W.,21,3.6)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;：&lt;code&gt;group&lt;/code&gt;操作时，会生成一个&lt;code&gt;field&lt;/code&gt;，命名为&lt;code&gt;group&lt;/code&gt;，可以尝试如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; test = group studentInfos by age;

grunt&amp;gt; describe test;
test: {group: int,studentInfos: {(name: chararray,age: int,gpa: float)}}

grunt&amp;gt; dump test;
(18,{(Jun L.,18,3.7),(Hhui H.,18,3.8)})
(20,{(Ning G.,20,3.6)})
(21,{(Chang W.,21,3.6)})
(22,{(Hlong G.,22,3.6)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的命令：&lt;code&gt;load&lt;/code&gt;、&lt;code&gt;group&lt;/code&gt;多少有些过于简单，不刺激，不激动，下面的命令会有点意思：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; result = foreach studentBag {
&amp;gt;&amp;gt;   student_younger = filter studentInfos by age &amp;lt;= 20;
&amp;gt;&amp;gt;   student_older = filter studentInfos by age &amp;gt; 20;
&amp;gt;&amp;gt;   generate COUNT(studentInfos) as totalNum, AVG(studentInfos.gpa) as avgGPA, 
		COUNT(student_younger) as youngerNum, AVG(student_younger.gpa) as youngerAvgGPA, 
		COUNT(student_older) as olderNum, AVG(student_older.gpa) as olderAvgGPA;
&amp;gt;&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有点复杂？稍等，拆解一下，再复杂的命令也会变得简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;student_younger = filter studentInfos by age &amp;lt;= 20;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;filter..by..&lt;/code&gt;是过滤语句，此处，表示按照条件&lt;code&gt;age &amp;lt;= 20&lt;/code&gt;过滤出不到20岁的学生，并且将结果指定给&lt;code&gt;student_younger&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;generate COUNT(studentInfos) as totalNum, AVG(studentInfos.gpa) as avgGPA, 
	COUNT(student_younger) as youngerNum, AVG(student_younger.gpa) as youngerAvgGPA, 
	COUNT(student_older) as olderNum, AVG(student_older.gpa) as olderAvgGPA;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个&lt;code&gt;generate ..&lt;/code&gt;是生成数据的命令，&lt;code&gt;COUNT&lt;/code&gt;、&lt;code&gt;AVG&lt;/code&gt;都是内部提供的聚合函数，如果只调用如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;generate COUNT(studentInfos) as totalNum, AVG(studentInfos.gpa) as avgGPA;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示将&lt;code&gt;studentInfos&lt;/code&gt;中包含的学生个数，以及平均&lt;code&gt;gpa&lt;/code&gt;组合成一个&lt;code&gt;tuple&lt;/code&gt;，赋值个&lt;code&gt;result&lt;/code&gt;;&lt;code&gt;as..&lt;/code&gt; 为这些&lt;code&gt;field&lt;/code&gt;指定名字。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt&amp;gt; describe result;
result: {totalNum: long,avgGPA: double,youngerNum: long,youngerAvgGPA: double,olderNum: long,olderAvgGPA: double}

grunt&amp;gt; dump result;
(5,3.6399999618530274,3,3.6666666666666665,2,3.5999999046325684)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;建议&lt;/strong&gt;：把上面的例子，再输入执行2遍，多使用&lt;code&gt;describe&lt;/code&gt;、&lt;code&gt;dump&lt;/code&gt;命令配合查看执行过程。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;练习一下&lt;/h3&gt;

&lt;p&gt;还是上面的&lt;code&gt;student&lt;/code&gt;数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cat student
Jun L. 	18	3.7
Hhui H.	18	3.8
Ning G.	20	3.6
Hlong G.	22	3.6
Chang W.	21	3.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：上述文件中，姓名、年龄、GPA之间都以TAB键分隔；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：20岁以下学生的人数以及gpa平均值，以及这些学生的名字（只要求算出这些，其他东西不要求）。&lt;/p&gt;

&lt;p&gt;这就成了上面问题的一部分，可以使用如下pig脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- 加载数据、设定field名字、设定field类型
studentInfos = load ’student’ as (name: chararray, age:int, gpa:float);

-- 找出20岁以下的学生
student_younger = filter studentInfos by age &amp;lt;= 20;

-- 要调用聚合函数COUNT\AVG必须进行group，将所有列，转换为一行
student_younger_bag = group student_younger all;

-- 输出学生人数、平均GPA，以及学生名单(下一条命令实际为一行)
result = foreach student_younger_bag generate COUNT(student_younger),
 AVG(student_younger.gpa), student_younger.name;

dump result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(3,3.699999968210856,{(Jun L.),(Hhui H.),(Ning G.)})&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;一篇博文&lt;/h2&gt;

&lt;p&gt;推荐codelast的一篇博文&lt;a href=&quot;http://www.codelast.com/?p=3621&quot;&gt;Apache Pig基础概念及用法&lt;/a&gt;, 不要着急，放松放松，CodeLast的这篇博客很轻松，嗯，很适合入门，在此向原博主致敬。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.codelast.com/?p=4550&quot;&gt;codeLast Apache Pig学习系列&lt;/a&gt;
&lt;em&gt;（个人看法：非常不错，适合直接上手写pig脚本；）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/21357721/&quot;&gt;Pig编程指南&lt;/a&gt;（Alan Gates著， 曹坤 译， 2013年2月  第1版） 
&lt;em&gt;(个人看法：有理论、有深度、有广度，每次都有新感觉；)&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://pig.apache.org/docs/r0.12.1/&quot;&gt;Pig documentation&lt;/a&gt;，
&lt;em&gt;(个人看法：特别详细，想要的东西，基本都能从这里找到，而且更新速度很快；)&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于Pig版本迭代速度比较快，所以个人建议，最好能去官网查看文档。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/introduction-to-pig/pig-on-elephant.png&quot; alt=&quot;pig-on-elephant&quot; /&gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>正则表达式（字符串匹配模式）</title>
     <link href="http://ningg.github.com/regular-expression"/>
     <updated>2014-05-04T00:00:00+08:00</updated>
     <id>http://ningg.github.com/regular-expression</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近师兄安排我用Pig解析一下日志文件，在数据装载过程中，需要抽取特定位置的字符串&lt;em&gt;（即使是数字、符号，在程序看来也是字符）。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;回想起之前的团队中，CZW对正则表达式进行过技术分享，深入浅出，反正当时我是听懂了，应该也达到了能用的水平，无奈10月左右的时间，只剩下点滴印象了，&lt;em&gt;（唉，时光已去，曾经掌握的东西，当要用时，又需要重新去学，这正是自己写技术博客的原因之一）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;不多说了，接下来，将整体上对正则表达式来一个梳理。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正则表达式，是什么？&lt;/h2&gt;

&lt;p&gt;正则表达式，英文原名: &lt;code&gt;Regular Expression&lt;/code&gt;（简称：&lt;code&gt;regex&lt;/code&gt;或&lt;code&gt;regexp&lt;/code&gt;），直接翻译：&lt;code&gt;有规律的式子&lt;/code&gt;，或者，可以翻译为&lt;code&gt;描述规律的式子&lt;/code&gt;。&lt;em&gt;(他奶奶的，不知道谁第一个翻译的，取名&lt;code&gt;正则表达式&lt;/code&gt;？忒高大上了，听上去完全不知到干什么的，还是&lt;code&gt;描述规律的式子&lt;/code&gt;容易理解)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/regular-expression/regular-expressions-comics.png&quot; alt=&quot;comics&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决什么问题？&lt;/h3&gt;

&lt;p&gt;通俗的说：查找满足一定规则的字符串。&lt;/p&gt;

&lt;p&gt;可用于文本的查找、替换。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;应用场景举例&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;场景1：仅查找出文本中单词&lt;code&gt;car&lt;/code&gt;，不想找出其他单词&lt;code&gt;scar&lt;/code&gt;、&lt;code&gt;carry&lt;/code&gt;等。&lt;/li&gt;
  &lt;li&gt;场景2：用户在注册页面填写Email时，检查Email地址格式是否正确。&lt;/li&gt;
  &lt;li&gt;场景3：查找指定目录下，文件名中包含&lt;code&gt;application&lt;/code&gt;字样的文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;正式定义&lt;/h3&gt;

&lt;p&gt;正则表达式，给个正式定义：按一定规则查找字符串，并可以进行替换操作。&lt;/p&gt;

&lt;p&gt;正则表达式，几点要注意的内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;有自己的语法规则，即，正则表达式语言；&lt;/li&gt;
  &lt;li&gt;不是正规的（完备的）程序设计语言，没有专门针对正则表达式的软件，来安装和运行；&lt;/li&gt;
  &lt;li&gt;常内置于其他软件/语言中；（即，其他语言实现了正则表达式规则的解析器）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当前，java/Python/PHP/JavaScript等，都支持正则表达式。&lt;/p&gt;

&lt;p&gt;支持正则表达式的语言\工具：&lt;a href=&quot;http://www.regular-expressions.info/tools.html&quot;&gt;Applications and Languages Related with RegEx&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;产生的启发点&lt;/h3&gt;

&lt;p&gt;1950年左右时，数学领域的一些研究工作&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://cns-classes.bu.edu/cn550/Readings/mcculloch-pitts-43.pdf&quot;&gt;A logical calculus of the ideas immanent in nervous activity&lt;/a&gt;, 1943;
Author: McCulloch, Warren S., and Walter Pitts;
简述：神经系统中神经元看作小巧而简单的自动控制单元。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.dlsi.ua.es/~mlf/nnafmc/papers/kleene56representation.pdf&quot;&gt;Representation of Events in Nerve Nets and Finite Automata&lt;/a&gt;, 1956;
Author: Kleene, Stephen C;
简述：“正则集合”的数学符号来描述此模型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;几年后，计算机领域借助上述研究成果，实现perl、grep等工具/语言，正则表达式进入实用阶段。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/regular-expression/regular-expression-introduction.png&quot; alt=&quot;illustration&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;校正&lt;/strong&gt;：上面图片&lt;code&gt;Illustration of Regular Expression&lt;/code&gt;中，&lt;code&gt;Meet c&lt;/code&gt;应该修正为&lt;code&gt;Meet b&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;怎么用？&lt;/h2&gt;

&lt;p&gt;正则表达式，俗称&lt;code&gt;描述规律的式子&lt;/code&gt;，用来查找字符串，基本逻辑是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如何匹配出1个字符；&lt;/li&gt;
  &lt;li&gt;如何匹配出n个字符；&lt;/li&gt;
  &lt;li&gt;如何匹配出特定位置的字符；（特定位置：字符串的开头、结尾）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-7&quot;&gt;匹配1个字符&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;a&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;一个字符&lt;code&gt;a&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[abc]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[..]表示集合内的任意一个字符，在此例中，[abc]表示a、b、c字符中的任意一个&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[^abc]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;除去a、b、c之外的任意一个字符，注意，&lt;code&gt;^&lt;/code&gt;只限于在&lt;code&gt;[^&lt;/code&gt;位置，才表示此含义&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[0123456789]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任意一个数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[a-z]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任意一个消息字母（在[]内&lt;code&gt;-&lt;/code&gt;为特殊字符，代表区间）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[0-9]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任意一个数字，等同于[0123456789]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;.&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任意一个字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\f&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;换页符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\t&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;制表键，tab&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\r&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;回车符，return&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\n&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;换行符，nextLine&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\v&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;垂直制表符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\w&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等价于[a-zA-Z0-9]，任何一个字母（区分大小写）、数字、下划线&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\W&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等价于[^a-zA-Z0-9]，任何一个非字母（区分大小写）、数字、下划线&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\d&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;任何一个数字字符,等价于[0-9]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\D&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等价于[^0-9]，任何一个非数字字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\s&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等价于[ \f\n\r\t\v]，任何一个空白字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\S&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等价于[^ \f\n\r\t\v]，任何一个非空白字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\x0A&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;（16进制）对应ASCII字符10，即\n&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\011&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;（8进制）对应ASCII字符9，即\t&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;校正&lt;/strong&gt;：关于&lt;code&gt;\s&lt;/code&gt;,《&lt;a href=&quot;http://book.douban.com/subject/2269648/&quot; title=&quot;《正则表达式必知必会》2007年12月，第1版&quot;&gt;正则表达式必知必会&lt;/a&gt;》 版本信息（2007年12月，第1版），在Page 31中，&lt;code&gt;\s&lt;/code&gt;表示任何一个空白字符，应该包含空格&lt;code&gt; &lt;/code&gt;在内（具体参考：&lt;a href=&quot;http://www.regular-expressions.info/shorthand.html&quot;&gt;Shorthand Character Classes Of Regex&lt;/a&gt;）&lt;/p&gt;

&lt;h3 id=&quot;n&quot;&gt;匹配n个字符&lt;/h3&gt;

&lt;p&gt;匹配&lt;code&gt;n&lt;/code&gt;个字符，就是“匹配一个字符”重复&lt;code&gt;n&lt;/code&gt;次，嗯，很简单，则有：&lt;code&gt;aa&lt;/code&gt;，表示匹配连续两个字符&lt;code&gt;a&lt;/code&gt;；&lt;code&gt;\d\d&lt;/code&gt;,表示匹配2个数字；&lt;code&gt;\n\n\n&lt;/code&gt;,表示匹配3个换行符。&lt;em&gt;(很简单有木有)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;问题来了，假设有如下文本：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I $am$ the $god$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;目标：查找出&lt;code&gt;$..$&lt;/code&gt;间的内容，正则表达式怎么写？(&lt;code&gt;$..$&lt;/code&gt;间字符的个数，不能确定，只知道1个以上)&lt;/p&gt;

&lt;p&gt;我x，不是说要“匹配一个字符”重复&lt;code&gt;n&lt;/code&gt;次就可以么？关键现在&lt;code&gt;n&lt;/code&gt;是几啊？这怎么还是一个范围（&lt;code&gt;n&amp;gt;=1&lt;/code&gt;）？这如何是好？&lt;/p&gt;

&lt;p&gt;莫急莫急，请往下看。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;?&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0次或1次&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;+&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1次以上（a+：表示一个或多个a的连续出现；[0-9]+：表示一个或多个连续出现的数字）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;*&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0次及0次以上&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{3}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3次&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{ ,3}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0次–3次（包含0次和3次）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{1, }&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1次以上&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{1,3}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1次–3次（包含1次和3次）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;到这儿，就可以看出，使用 &lt;code&gt;$.+$&lt;/code&gt;就能匹配上面的内容了。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;匹配特定位置字符&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;在字符串开头&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;$&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;在字符串结尾&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\b&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;单词的边界&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\B&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;非单词的边界&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;匹配出如下文本中的cat单词：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;cat catt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;\bcat\b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;匹配如下文本中的&lt;code&gt;-&lt;/code&gt;，要求：只找出两个字母之间的&lt;code&gt;-&lt;/code&gt;，文本内容：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A-b - ss s- f-  - a-&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;\B-\B&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;过度匹配（贪婪）&lt;/h3&gt;

&lt;p&gt;要匹配文本&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ben@cib.com.cn&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;\w+@\w[\w\.]+\.\w+&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;理论上，可以匹配出：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;ben@baidu.com&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ben@baidu.com.cn&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是，上述匹配结果是2，即&lt;code&gt;ben@cib.com.cn&lt;/code&gt;。原因：&lt;code&gt;+&lt;/code&gt;、&lt;code&gt;*&lt;/code&gt;默认都是贪婪匹配，即找出最长的匹配模式；如果希望匹配出结果1，即&lt;code&gt;ben@cib.com&lt;/code&gt;，惰性匹配，找出最短的匹配模式，需要修改正则表达式：&lt;code&gt;\w+?@\w[\w\.]+?\.\w+?&lt;/code&gt;，即&lt;code&gt;+&lt;/code&gt;替换为&lt;code&gt;+?&lt;/code&gt;，&lt;code&gt;*&lt;/code&gt;替换为&lt;code&gt;*?&lt;/code&gt;。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;贪婪匹配&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;懒惰字符&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;*&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;*?&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;+&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;+?&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{n, }&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{n, }?&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-10&quot;&gt;补充说明&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;转义字符，例如，&lt;code&gt;\.&lt;/code&gt; 表示&lt;code&gt;.&lt;/code&gt;字符本身，单独&lt;code&gt;.&lt;/code&gt;表示匹配任意一个字符；&lt;code&gt;\?&lt;/code&gt;表示&lt;code&gt;?&lt;/code&gt;字符自身&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;表示其前后两种模式的任意一个，例如&lt;code&gt;(19|20)\d{2}&lt;/code&gt;，匹配19xx和20xx，xx表示任意两位数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;子表达式，整体上看作一个独立元素&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;假设有一个文本&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hello, my name is Ben&lt;code&gt;&amp;amp;nbsp;&lt;/code&gt; … Node.js, Linux&lt;code&gt;&amp;amp;nbsp;&amp;amp;nbsp;&lt;/code&gt;, and other tech.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在要匹配出连续的两个&lt;code&gt;&amp;amp;nbsp;&lt;/code&gt;，可以使用&lt;code&gt;&amp;amp;nbsp;&amp;amp;nbsp;&lt;/code&gt;，也可以使用&lt;code&gt;(&amp;amp;nbsp;){2}&lt;/code&gt;，而不能使用&lt;code&gt;&amp;amp;nbsp;{2}&lt;/code&gt;，因为&lt;code&gt;{2}&lt;/code&gt;，表示匹配其前面字符，实际&lt;code&gt;&amp;amp;nbsp;{2}&lt;/code&gt;等价与&lt;code&gt;&amp;amp;nbsp;;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;匹配IP：10.108.210.111&lt;/p&gt;

&lt;p&gt;正则表达式：&lt;code&gt;\d{1,3}\. \d{1,3}\. \d{1,3}\. \d{1,3}\ &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以替换为： &lt;code&gt;(\d{1,3}\.){3}\d{1,3}\ &lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;高级用法&lt;/h2&gt;

&lt;h3 id=&quot;section-12&quot;&gt;子表达式&lt;/h3&gt;

&lt;p&gt;前文提到过，在这儿单独拿出来说，是因为下文要用到。&lt;em&gt;（尼玛，下文难道不会用到前文其他内容么？凭什么单说&lt;code&gt;子表达式&lt;/code&gt;啊；因为，实在是怕你忘了，其他内容你即使忘了，也容易自己查找）&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;引用回溯&lt;/h3&gt;

&lt;p&gt;本质：前后匹配一致；&lt;/p&gt;

&lt;p&gt;技术上实质：后半部分引用前半部分匹配到的子表达式。&lt;/p&gt;

&lt;p&gt;举例：&lt;/p&gt;

&lt;p&gt;匹配如下文档中重复输入的单次：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This is a block of of text, several words here are are repeated, and and they should not be.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;[ ]+(\w+)[ ]+\1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\1&lt;/code&gt;表示&lt;code&gt;(\w+)&lt;/code&gt;中匹配到的内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：回溯引用中&lt;code&gt;\1&lt;/code&gt;,&lt;code&gt;\2&lt;/code&gt;只能一用子表达式（即用&lt;code&gt;()&lt;/code&gt;括起来的部分），&lt;code&gt;\0&lt;/code&gt;代表整个正则表达式匹配的结果。&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;前后查找&lt;/h3&gt;

&lt;p&gt;本质：匹配全部，返回局部；&lt;/p&gt;

&lt;p&gt;技术上实质：将子表达式向前（后）匹配到字符串返回。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;向前查找： 正 向前查找&lt;code&gt;exp2(?=exp1)&lt;/code&gt;， 负 向前查找&lt;code&gt;(exp2(?!exp1))&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;向后查找： 正 向后查找&lt;code&gt;(?&amp;lt;=exp1)exp2&lt;/code&gt;， 负 向后查找&lt;code&gt;(?&amp;lt;!exp1)exp2&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注：上式都是匹配&lt;code&gt;exp1&lt;/code&gt;，返回&lt;code&gt;exp2&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;举例1：&lt;/p&gt;

&lt;p&gt;匹配如下文本中的传输协议&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://www.baidu.com&lt;/p&gt;

  &lt;p&gt;ftp://ftp.baidu.com&lt;/p&gt;

  &lt;p&gt;https://mails.baidu.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;.+(?=:)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;举例2：&lt;/p&gt;

&lt;p&gt;匹配如下文本中的金额&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;abc: $23.01&lt;/p&gt;

  &lt;p&gt;hdc: $899.00&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正则表达式：&lt;code&gt;(?&amp;lt;=\$)\d[\d.]*\d&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;嵌入条件&lt;/h3&gt;

&lt;p&gt;可以添加逻辑条件，类似if。&lt;/p&gt;

&lt;p&gt;说几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;功能很强大；&lt;/li&gt;
  &lt;li&gt;使用的不是很多；&lt;/li&gt;
  &lt;li&gt;真要了解一下，参考《&lt;a href=&quot;http://book.douban.com/subject/2269648/&quot; title=&quot;《正则表达式必知必会》2007年12月，第1版&quot;&gt;正则表达式必知必会&lt;/a&gt;》&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-16&quot;&gt;元字符？&lt;/h3&gt;

&lt;p&gt;啥？元字符？什么东东？小伙儿，不要激动。正则表达式为了描述匹配哪些位置的字符串，使用了&lt;code&gt;.&lt;/code&gt;,&lt;code&gt;\d&lt;/code&gt;,&lt;code&gt;\s&lt;/code&gt;,&lt;code&gt;\w&lt;/code&gt;,&lt;code&gt;\W&lt;/code&gt;,&lt;code&gt;^&lt;/code&gt;,&lt;code&gt;[]&lt;/code&gt;,&lt;code&gt;()&lt;/code&gt;,&lt;code&gt;|&lt;/code&gt;,&lt;code&gt;$&lt;/code&gt;，来描述正则表达式语言的语法，即，这些字符是表述&lt;code&gt;正则表达式语言&lt;/code&gt;语法规则的字符，成为这个语言的元字符。&lt;/p&gt;

&lt;h2 id=&quot;section-17&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/2269648/&quot; title=&quot;《正则表达式必知必会》2007年12月，第1版&quot;&gt;正则表达式必知必会&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.regular-expressions.info/tutorial.html&quot;&gt;Regex Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-18&quot;&gt;休息一下&lt;/h2&gt;

&lt;p&gt;你能读懂下面这张图片吗？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/regular-expression/regex-example.png&quot; alt=&quot;regex-example&quot; /&gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>GitHub上搭建个人网站</title>
     <link href="http://ningg.github.com/build-blog-with-github"/>
     <updated>2014-05-02T00:00:00+08:00</updated>
     <id>http://ningg.github.com/build-blog-with-github</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;0.背景&lt;/h2&gt;

&lt;p&gt;准备重新捡起博客，记录自己的生活，特别是技术生活&lt;em&gt;（过于私密的东西，也不敢往博客上放不是）。&lt;/em&gt;个人博客有两个途径：a.使用已有的博客网站; b.搭建自己的私人网站。调研了一下国内博客网站，（&lt;a href=&quot;http://www.csdn.net/&quot; title=&quot;CSDN&quot;&gt;CSDN&lt;/a&gt;、&lt;a href=&quot;http://www.iteye.com/&quot; title=&quot;javaEye(现在更名为ITeye)&quot;&gt;javaEye&lt;/a&gt;、&lt;a href=&quot;http://www.oschina.net/&quot; title=&quot;OSCHINA&quot;&gt;OSCHINA&lt;/a&gt;等）普遍文字格式、代码编排样式不是很喜欢&lt;em&gt;（太挑剔了？对，我就是一个挑剔的人），&lt;/em&gt;这让自己转向私人博客。可以预想到，自己搭建要稍微复杂一点，话又说回来了，作为&lt;code&gt;software engineer&lt;/code&gt;折腾网站也算看家本领了&lt;em&gt;（我会告诉你我的目标是&lt;code&gt;scientist&lt;/code&gt;么）。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;既然要搭自己的私人博客，那选定什么框架/方案呢？之前使用&lt;a href=&quot;https://wordpress.org/&quot; title=&quot;WordPress&quot;&gt;WordPress&lt;/a&gt;搭过，但需要购买域名和空间；现在流行在&lt;a href=&quot;https://github.com/about&quot; title=&quot;GitHub&quot;&gt;GitHub&lt;/a&gt;上搭，并且不需要考虑域名和空间的问题，那就他了，上&lt;a href=&quot;https://github.com/about&quot; title=&quot;GitHub&quot;&gt;GitHub&lt;/a&gt;，走起&lt;em&gt;（其实，国内也有一个类似的地方&lt;a href=&quot;https://gitcafe.com/&quot; title=&quot;GitCafe&quot;&gt;GitCafe&lt;/a&gt;，不过，出于装B需要，最终选定了&lt;a href=&quot;https://github.com/about&quot; title=&quot;GitHub&quot;&gt;GitHub&lt;/a&gt;）。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;1.做什么？&lt;/h2&gt;

&lt;p&gt;目标：私人博客、自己搭建。&lt;/p&gt;

&lt;p&gt;方式：&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/build-blog-with-github/blog-or-not.jpg&quot; alt=&quot;blog or not&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;2.怎么做？&lt;/h2&gt;

&lt;p&gt;初步分析，在&lt;a href=&quot;https://github.com/about&quot; title=&quot;GitHub&quot;&gt;GitHub&lt;/a&gt;上搭建博客，实质是：将自己的博客内容上传到GitHub上&lt;em&gt;（因为GitHub提供了空间）；&lt;/em&gt;如果需要修改博客内容，则需要从GitHub上将download/pull下来；接下来就是让外面可以访问GitHub上的博客。总结一下，对应3个必要步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;GitHub上创建工程、并且能够将GitHub上的文件/代码，下载到本地；&lt;/li&gt;
  &lt;li&gt;将本地的文件/代码，上传到GitHub上；&lt;/li&gt;
  &lt;li&gt;配置GitHub，使其对外提供私人博客的访问页面；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;好了，上面是凭空想出来的&lt;em&gt;（任何地方搭建博客，都是上面的逻辑步骤，而不仅限于GitHub）；&lt;/em&gt;那实际如何操作呢？具体分为4个阶段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;熟悉&lt;a href=&quot;https://github.com/about&quot; title=&quot;GitHub&quot;&gt;GitHub&lt;/a&gt;的基本操作（创建工程、上传代码、下载代码）；&lt;/li&gt;
  &lt;li&gt;利用&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;功能，搭建简易网站；&lt;/li&gt;
  &lt;li&gt;利用&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;jekyll&lt;/a&gt;，增强网站功能（除了jekyll，还有其他的方式）；&lt;/li&gt;
  &lt;li&gt;在&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;jekyll&lt;/a&gt;框架下，依照个人偏好，进行定制；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;3.实际操作&lt;/h2&gt;

&lt;h3 id=&quot;github&quot;&gt;3.1GitHub的基本操作&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/set-up-git&quot;&gt;安装使用Git（GitHub上传、下载文件的工具）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/create-a-repo&quot;&gt;GitHub上创建项目（其中包含了，GitHub上传文件的Git命令）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/fork-a-repo&quot;&gt;GitHub上Fork项目（其中包含了，GitHub下载文件的Git命令）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;补充：&lt;a href=&quot;https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line&quot;&gt;上传文件至GitHub&lt;/a&gt;；另外，向GitHub提交代码时，按照上面的操作方式，需要每次都输入GitHub的用户名和密码，可以采用&lt;code&gt;SSH Keys&lt;/code&gt;的方式来解决此问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/build-blog-with-github/git-github.png&quot; alt=&quot;git-github&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;3.2如何搭建博客？&lt;/h3&gt;

&lt;p&gt;GitHub上对于个人博客的支持，实质是利用GitHub Pages功能来实现的，具体操作：&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;,认真读一遍，5mins，一步一步操作下来，简易博客就搭建成功了（一个简单的欢迎页面&lt;code&gt;index.html&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;补充：扩展阅读&lt;a href=&quot;https://help.github.com/categories/20/articles&quot;&gt;GitHub Pages FAQ&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/build-blog-with-github/github-pages.jpg&quot; alt=&quot;github-pages&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;jekyll&quot;&gt;3.3Jekyll增强博客网站功能&lt;/h3&gt;

&lt;p&gt;详细阅读”&lt;strong&gt;3.2如何搭建博客&lt;/strong&gt;“中提到的&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;的童鞋，在&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;页面最下端一定注意到了&lt;a href=&quot;http://jekyllrb.com/docs/quickstart/&quot;&gt;Blogging with Jekyll&lt;/a&gt;，对，就是他，读一遍，操作一下，搞定。&lt;/p&gt;

&lt;p&gt;补充：jekyll用起来倒是用起来了，怎么发表一遍博文呢？这个…额…等到学会 “&lt;strong&gt;3.4 基于jekyll框架，定制博客&lt;/strong&gt;” 再去写博客吧，现在建议把上面的操作反复看两遍，捋一捋逻辑流程。&lt;/p&gt;

&lt;h3 id=&quot;jekyll-1&quot;&gt;3.4基于jekyll框架，定制博客&lt;/h3&gt;

&lt;p&gt;先看一下两个使用jekyll框架的博客：&lt;a href=&quot;http://beiyuu.com/&quot;&gt;BeiYuu&lt;/a&gt; &amp;amp; &lt;a href=&quot;http://havee.me/&quot;&gt;Havee&lt;/a&gt;，他们对应的模版在GitHub上都可以找到：&lt;a href=&quot;https://github.com/beiyuu/beiyuu.github.com&quot;&gt;BeiYuu.com Template of GitHub&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://github.com/Ihavee/ihavee.github.io&quot;&gt;Havee.me Template of GitHub&lt;/a&gt;。 &lt;/p&gt;

&lt;p&gt;先膜拜一下上面两个博客模板，&lt;em&gt;光彩夺目，亮瞎一双狗眼，&lt;/em&gt;好了，我能不能也搭建一个类似的博客？途径有一个：深入学习一下&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll的官方文档&lt;/a&gt;，补充：&lt;a href=&quot;http://jekyllcn.com/&quot;&gt;中文版本&lt;/a&gt;。&lt;em&gt;（基于jekyll，如何定制博客，我将写一篇详细的介绍，敬请期待）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;faq&quot;&gt;4.FAQ&lt;/h2&gt;

&lt;h3 id=&quot;google-analytics&quot;&gt;4.1使用google analytics来统计网站访问情况&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;注册&lt;a href=&quot;http://www.google.com/analytics/&quot;&gt;Google Analytics&lt;/a&gt;账户；&lt;/li&gt;
  &lt;li&gt;在账户下，添加要监控的网站信息，&lt;a href=&quot;http://www.google.com/analytics/&quot;&gt;Google Analytics&lt;/a&gt;会生成跟踪信息的JS片段；&lt;/li&gt;
  &lt;li&gt;将上述JS片段插入到自己想要统计的页面上；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体设置细节：请查看&lt;a href=&quot;http://www.google.com/intl/zh-CN_ALL/analytics/learn/index.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;discus&quot;&gt;4.2如何DISCUS作为评论插件？&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;注册&lt;a href=&quot;http://disqus.com/&quot;&gt;DISQUS&lt;/a&gt;账户；&lt;/li&gt;
  &lt;li&gt;登录后，点击&lt;code&gt;Add Disqus to your site&lt;/code&gt;按钮，操作下去，最终将获得相应的JS片段；&lt;/li&gt;
  &lt;li&gt;将上述JS片段插入到自己想要包含评论的页面即可；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;latex&quot;&gt;4.3配置网站，支持LaTeX语法&lt;/h3&gt;

&lt;p&gt;配置博客，支持&lt;a href=&quot;http://www.latex-project.org/&quot;&gt;LaTeX&lt;/a&gt;公式，此次设置&lt;a href=&quot;http://kramdown.gettalong.org&quot;&gt;kramdown&lt;/a&gt;来解析&lt;a href=&quot;http://daringfireball.net/projects/markdown/syntax&quot;&gt;Markdown&lt;/a&gt;文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
If you have sufficient control over the publishing process
(e.g. you are running Jekyll yourself), an easy solution is
to switch the markdown parser to one that supports TeX.
*/

//For example, using kramdown:
gem install kramdown

//Change the markdown line in _config.yml to
markdown: kramdown

//and add something like
&amp;lt;script type=&quot;text/javascript&quot; 
src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&amp;gt;
&amp;lt;/script&amp;gt;
//to _layouts/default.html. 

//Now you can simply mark any mathematics in your posts with $$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;http://stackoverflow.com/questions/10987992/using-mathjax-with-jekyll&quot;&gt;Using MathJax with Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;4.3遇到的问题&amp;amp;解决办法？&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/dengjianqiang2011/article/details/9260435&quot;&gt;执行Git命令时，出错提示：（fatal: remote origin already exists.）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/migrating-your-pages-site-from-maruku&quot;&gt;GitHub上markdown的解析引擎不同，会造成最终页面效果的差异&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;jekyll serve启动出错提示：（Liquid Exception: invalid byte sequence in GBK）&lt;strong&gt;见下文&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;修改&lt;code&gt;\Ruby200\lib\ruby\gems\2.0.0\gems\jekyll-1.0.3\lib\jekyll&lt;/code&gt;目录下的&lt;code&gt;convertible.rb&lt;/code&gt;文件，将其中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.content = File.read(File.join(base, name))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.content = File.read(File.join(base, name),:encoding=&amp;gt;&quot;utf-8&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果上述修改之后，仍然提示出错，则：&lt;code&gt;...\lib\jekyll\tags&lt;/code&gt;目录下&lt;code&gt;include.rb&lt;/code&gt;文件，类似对于&lt;code&gt;convertible.rb&lt;/code&gt;文件的操作；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/build-blog-with-github/github-social-coding.png&quot; alt=&quot;github-social-coding&quot; /&gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>java 重载 & 重写</title>
     <link href="http://ningg.github.com/override-overload-of-java"/>
     <updated>2014-01-14T00:00:00+08:00</updated>
     <id>http://ningg.github.com/override-overload-of-java</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;问题背景&lt;/h2&gt;

&lt;p&gt;阅读程序时，看到在子类中的各种@Override的注解，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class A{
	public void speak(int i){
		  ...
	}
	...
}
 
public class B extends A{
	@Override
	public void speak(int i){
		  ...
	}
	...
	public static void main(String[] args){
		B b = new B();
		A a1;
		a1 = (A)b;
 
		a1.speak(1);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类&lt;code&gt;B&lt;/code&gt;继承了&lt;code&gt;A&lt;/code&gt;，并且在&lt;code&gt;B&lt;/code&gt;中&lt;code&gt;Override&lt;/code&gt;了方法&lt;code&gt;speak()&lt;/code&gt;;现在问&lt;code&gt;a1.speak(1)&lt;/code&gt;调用的是&lt;code&gt;class A&lt;/code&gt;？&lt;code&gt;class B&lt;/code&gt;？中的&lt;code&gt;speak()&lt;/code&gt;方法？&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分析&lt;/h2&gt;

&lt;p&gt;上面的例子是一个典型的&lt;code&gt;重写&lt;/code&gt;，因为：&lt;code&gt;subclass&lt;/code&gt;中方法的名称、输入参数、返回参数都与&lt;code&gt;supclass&lt;/code&gt;中完全相同。&lt;/p&gt;

&lt;p&gt;现在有一个问题：重写的方法前没有&lt;code&gt;@Override&lt;/code&gt;行不行？&lt;em&gt;(这个问题很好，说明you’re thinking。)&lt;/em&gt;没有&lt;code&gt;@Override&lt;/code&gt;的注解完全可以，只需要满足：&lt;code&gt;subclass&lt;/code&gt;中方法的名称、输入参数、返回参数与&lt;code&gt;supclass&lt;/code&gt;中完全相同即可实现方法的重写。&lt;/p&gt;

&lt;p&gt;现在问题又来了：既然没有&lt;code&gt;@Override&lt;/code&gt;也能实现方法的重写，为什么很多地方都加了&lt;code&gt;@Override&lt;/code&gt;？原因很简单，添加了&lt;code&gt;@Override&lt;/code&gt;，编译器会依照&lt;code&gt;supclass&lt;/code&gt;中方法来进行检查，保证此方法真的实现重写。（避免了因为粗心等造成的&lt;code&gt;bug&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重写（&lt;code&gt;override&lt;/code&gt;）&lt;/strong&gt;：就是覆盖；基于继承的，重写父类的方法，方法名什么都一样，方法体不同。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;相同的名称；&lt;/li&gt;
  &lt;li&gt;相同的返回类型；&lt;/li&gt;
  &lt;li&gt;子类中，重写的方法访问修饰符权限保持一致，或者增大（&lt;code&gt;public&lt;/code&gt;&amp;gt;&lt;code&gt;protected&lt;/code&gt;&amp;gt;&lt;code&gt;default&lt;/code&gt;&amp;gt;&lt;code&gt;private&lt;/code&gt;）；&lt;/li&gt;
  &lt;li&gt;子类中，重写的方法抛出的异常不能变的更宽泛；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;重载（&lt;code&gt;overload&lt;/code&gt;）&lt;/strong&gt;：基于同一个类的，不同的重载方法，主要是参数列表不同&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;相同的名称；&lt;/li&gt;
  &lt;li&gt;必须有不同的参数列表；&lt;/li&gt;
  &lt;li&gt;可以有不同的返回类型，可以有不同的访问修饰符，可以抛出不同的异常；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;重写 &amp;amp; 重载&lt;/strong&gt;：都是多态性的体现，重写是子类与父类间的多态性，重载是同一类中多态性的体现。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参考来源&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/smyhmz/article/details/2716638&quot;&gt;http://blog.csdn.net/smyhmz/article/details/2716638&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/leonardwang/article/details/7046180&quot;&gt;http://blog.csdn.net/leonardwang/article/details/7046180&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>1个月学习小结——代价敏感的数据流分类算法</title>
     <link href="http://ningg.github.com/summary-of-20130103"/>
     <updated>2014-01-03T00:00:00+08:00</updated>
     <id>http://ningg.github.com/summary-of-20130103</id>
     <content type="html">&lt;p&gt;最近几个月阅读论文都是“抄家底”的方式进行，即，认准一个作者，把他最近几年的论文看个遍，然后再看看自己有没有新的想法。&lt;/p&gt;

&lt;p&gt;其中，第一个作者是西北农林科技的张阳教授，再一个就是针对&lt;code&gt;cost-sensitive decision tree&lt;/code&gt;方向看了一些论文，值得说明的是找到一篇比较全面的综述，还是2011年左右的，不过这篇文章还没有详细去看。&lt;/p&gt;

&lt;p&gt;这一个多月内（从&lt;code&gt;2012.10.12&lt;/code&gt;开题那一天算起），确定了这个月将围绕一个主题进行学习&lt;code&gt;数据流、代价敏感、分类&lt;/code&gt;；基于这个主题，可以预想到的工作有：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;研究现有的数据流data-stream中的classification；研究现有的cost-sensitive classification；&lt;/li&gt;
    &lt;li&gt;将cost-sensitive应用于data stream classification中（设计算法）；&lt;/li&gt;
    &lt;li&gt;初期处理数据，改造实验平台（weka、MOA）进行试验；&lt;/li&gt;
    &lt;li&gt;小论文（EI）、毕业论文（中期、最终）；&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在的进展：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;code&gt;data stream classification&lt;/code&gt; &amp;amp; &lt;code&gt;cost sensitive classification&lt;/code&gt;都有有了一点了解；&lt;/li&gt;
    &lt;li&gt;决定classification使用&lt;code&gt;Decision tree&lt;/code&gt;进行；（在&lt;code&gt;data stream&lt;/code&gt;和&lt;code&gt;cost sensitive&lt;/code&gt;中&lt;code&gt;Decision-tree&lt;/code&gt;都有前人进行过较深入的研究工作）&lt;/li&gt;
    &lt;li&gt;遇到第一个问题：2012年TKDE中有文章指出&lt;code&gt;VFDT&lt;/code&gt;中使用的&lt;code&gt;Hoeffding’s-bound&lt;/code&gt;不严格，而应改为使用&lt;code&gt;McDiarmid’s-bound&lt;/code&gt;，针对这个自己很纠结，因为新提出的&lt;code&gt;bound&lt;/code&gt;限定的n值更大，需要的训练&lt;code&gt;instance&lt;/code&gt;更多，这对自己有什么影响吗？&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ol&gt;
      &lt;li&gt;需要更多的instance&lt;/li&gt;
      &lt;li&gt;或者，更换选择分裂属性的指标（可以使用Gini Index）&lt;/li&gt;
      &lt;li&gt;思考能否，重新描述“VFDT”中数学问题，并提出与McDiarmid’s-Bound并列的界限值（换个角度想），或者能否改进McDiarmid’s-Bound。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;————————————–2013/01/04———————————————&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;今天的进展&lt;/strong&gt;：改进了[2]中针对Infomation-gain提出的McDiarmid’s-bound，将其值降低了18倍，但仍然不可用。如果能够再降低10倍，与“VFDT”中bound结果逼近，则可以在实际试验中使用参数info-gain。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：改进[2]中针对Infomation-gain提出的McDiarmid’s-bound&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;具体&lt;/strong&gt;：重新审视McDiarmid’s_inequality，参考[1]中Hoeffding’s_inequality是一个特列。参考[3]中（Definition 1）empirical-entropy和entropy-norm之间关系，结合[2]中原始的McDiarmid’s bound重新计算info-gain的bound。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下一步打算&lt;/strong&gt;：继续改进Infomation-gain提出的McDiarmid’s-bound，具体可以从[3][4]中获得想法（改进思路：决策树分裂属性的数学描述、信息增益的原始计算公式、熵、McDiarmid’s-inequality）。（目标：最终可用）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ashish-mcdiarmid.pdf&lt;/li&gt;
  &lt;li&gt;Decision trees for mining data streams based on the McDiarmid’s bound.pdf&lt;/li&gt;
  &lt;li&gt;A Near-Optimal Algorithm for Computing the Entropy of a Stream.pdf&lt;/li&gt;
  &lt;li&gt;Extensions to McDiarmid’s inequality when differences are bounded with high probability.pdf&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;结束语&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;问：世间此山最高？或者另有高处？&lt;/p&gt;

&lt;p&gt;答：世间自有他山高此山，Open-mind比天高。&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>Linux 后台运行命令</title>
     <link href="http://ningg.github.com/linux-cmd-run-in-background"/>
     <updated>2013-01-17T00:00:00+08:00</updated>
     <id>http://ningg.github.com/linux-cmd-run-in-background</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;问题背景&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;SecureCRT&lt;/code&gt;/&lt;code&gt;putty&lt;/code&gt;等客户端，远程连接Linux服务器，并且执行脚本时，由于网络不稳定，有可能导致连接中断，在这种情况下，我担心会影响脚本程序的正常执行（不能肯定是否一定会影响）；因此希望启动一个脚本，让其在后台一直运行，不会随着&lt;code&gt;连接中断&lt;/code&gt;而中断掉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;外加问题&lt;/strong&gt;：现在一个命令的输出信息过多，希望后台运行时，不保存输出信息。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;解决办法&lt;/h2&gt;

&lt;p&gt;先说最终的解决办法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nohup sh collectCloSpan.sh &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行上面命令即可。输出信息在当前路径的&lt;code&gt;nohup.out&lt;/code&gt;文件中。（如果当前路径不允许新建文件，则，输出信息保存在&lt;code&gt;~/nohup.out&lt;/code&gt;文件中）&lt;/p&gt;

&lt;p&gt;好了，现在怎么解决解决&lt;code&gt;nohup.out&lt;/code&gt;文件过大的问题呢？&lt;/p&gt;

&lt;p&gt;经过查询有2个解决思路：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;完全删除输出信息：一点输出信息都不想要；&lt;/li&gt;
  &lt;li&gt;删除过时的输出信息，只保留最近一段时间的输出信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完全删除输出信息：在程序后台运行之后，直接删除文件nohup.out文件即可，除非重新运行程序，否则，不会再有&lt;code&gt;nohup.out&lt;/code&gt;文件；&lt;/p&gt;

&lt;p&gt;删除过时的输出信息（在线清空文件内容）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*执行效率较高*/
cp /dev/null nohup.out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*文件很大时，执行较慢*/
cat /dev/null &amp;gt; nohup.out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于&lt;code&gt;/dev/null&lt;/code&gt;到底是什么，自己&lt;code&gt;google&lt;/code&gt;或者&lt;code&gt;baidu&lt;/code&gt;吧。&lt;/p&gt;

&lt;p&gt;感兴趣的可以具体看下面的详细说明。&lt;em&gt;（不感兴趣的可以直接跳过了）。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;细节分析&lt;/h2&gt;

&lt;p&gt;后台运行脚本，有多种解决方法，此处只说一个比较常用的，具体如下（&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/&quot;&gt;参考1&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nohup ping www.baidu.com &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后等待，出现如下结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux-cmd-run-in-background/linux-cmd-run-in-background.jpg&quot; alt=&quot;LINUX后台运行命令nohup测试&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入命令&lt;code&gt;jobs&lt;/code&gt;可以查看现有的后台程序，如上图；并且可以使用&lt;code&gt;fg 1&lt;/code&gt;命令，将第一个后台程序，调入前台。
输入后台运行命令&lt;code&gt;nohup ping www.baidu.com &amp;amp;&lt;/code&gt;后，如果没有返回到原来的&lt;code&gt;shell&lt;/code&gt;，则中间直接敲&lt;code&gt;回车(Enter)&lt;/code&gt;即可，等到返回原来&lt;code&gt;shell&lt;/code&gt;环境之后，可以使用&lt;code&gt;exit&lt;/code&gt;命令退出；如上图所示。再次使用&lt;code&gt;SecureCRT&lt;/code&gt;/&lt;code&gt;putty&lt;/code&gt;等终端登录，并输入如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ps –ef | grep “ping”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到上图中结果，原来的程序&lt;code&gt;pid&lt;/code&gt;为&lt;code&gt;13380&lt;/code&gt;还在执行，只是此进程的父进程改为&lt;code&gt;pid=1&lt;/code&gt;的特殊进程。程序运行过程中，所有输出自动输出到当前目录的&lt;code&gt;nohup.out&lt;/code&gt;文件中（具体&lt;a href=&quot;http://www.linuxidc.com/Linux/2010-09/28366.htm&quot;&gt;参考2&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;疑问1&lt;/strong&gt;：后台运行：&lt;code&gt;command &amp;amp; &lt;/code&gt;和 &lt;code&gt;nohup command &amp;amp;&lt;/code&gt;有区别吗？&lt;/p&gt;

&lt;p&gt;答：&lt;code&gt;command &amp;amp;&lt;/code&gt;：后台运行，关掉中断，命令会终止运行；&lt;code&gt;nobup command &amp;amp;&lt;/code&gt;：后台运行，关掉终端，命令会继续运行。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参考来源&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/&quot;&gt;https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.linuxidc.com/Linux/2010-09/28366.htm&quot;&gt;http://www.linuxidc.com/Linux/2010-09/28366.htm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/lwm-1988/archive/2011/08/20/2147299.html&quot;&gt;http://www.cnblogs.com/lwm-1988/archive/2011/08/20/2147299.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux-cmd-run-in-background/scene-background.jpg&quot; alt=&quot;scene&quot; /&gt;&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>MySQL--基本操作</title>
     <link href="http://ningg.github.com/mysql-basic-info"/>
     <updated>2013-01-16T00:00:00+08:00</updated>
     <id>http://ningg.github.com/mysql-basic-info</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;难得最近两天重新接触Mysql，正好整理一下基本的知识。下面是自己本篇文章的大纲：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;增删改查；&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;group by&lt;/code&gt;、&lt;code&gt;order by&lt;/code&gt;、&lt;code&gt;distinct&lt;/code&gt;；&lt;/li&gt;
    &lt;li&gt;常用函数：&lt;code&gt;count()&lt;/code&gt;、&lt;code&gt;min()&lt;/code&gt;、&lt;code&gt;max()&lt;/code&gt;、&lt;code&gt;substing_index()&lt;/code&gt;等；&lt;/li&gt;
    &lt;li&gt;查看mysql日志，主要是针对&lt;code&gt;warings&lt;/code&gt;`errors`的查询和处理；&lt;/li&gt;
    &lt;li&gt;mysql存储过程；&lt;/li&gt;
    &lt;li&gt;数据备份；&lt;/li&gt;
    &lt;li&gt;常用工具的介绍及特点；&lt;/li&gt;
    &lt;li&gt;（万佛归宗）MySQL的整体框架，备份时内部的线程机制，语句执行效率。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先对于上面的8个要点进行一个整体的说明：&lt;code&gt;1-3&lt;/code&gt;是基本的操作；&lt;code&gt;4-7&lt;/code&gt;属于较深入的学习（有点难度），但仍然是操作过程；&lt;code&gt;8&lt;/code&gt;是整个MySQL的基础，最核心的东西，从这里就可以窥见Mysql的起源了。操作部分关键是要记忆+操作；底层的理论需要一些理解（brain power）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：整篇的表述，都是以自己浅显的理解为基础的；有描述不当的地方，还请留言指正。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;具体&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.增删改查&lt;/h3&gt;

&lt;h3 id=&quot;group-byorder-bydistinct&quot;&gt;2.group by、order by、distinct&lt;/h3&gt;

&lt;h3 id=&quot;countminmaxsubstringindex&quot;&gt;3.常用函数：count、min、max、substring_index&lt;/h3&gt;

&lt;p&gt;前3项，参照下面链接，把命令反复敲2遍，重复的也要敲。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/hateislove214/archive/2010/11/05/1869889.html&quot;&gt;MySQL常用命令汇总1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://zhaofeng2007625.blog.163.com/blog/static/311815972010111512437937/&quot;&gt;MySQL常用命令汇总2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_9707fac301017kb3.html&quot;&gt;MySQL常用命令汇总3&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;:有疑问的地方多GOOGLE，实在无法解决的，就跳过。
简要说明几点（查找《MySQL必知必会》中对应部分）：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;group by &lt;/code&gt;分组，本质将表格分为逻辑组，基于逻辑组，同时进行相同处理（统计、汇总等）；可以嵌套分组，（效率很低的嵌套分组，过滤分组）常在group by之后，添加一个order by，按照某种规律进行排序。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;order by&lt;/code&gt; 排序，按多个列排序：order by column_1,column_2；DESC:降序；ASC：默认值，升序。（多列排序、指定排序方向）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;distinct&lt;/code&gt; 过滤重复内容；可以使用distinct column_1,column_2；（多列去重）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;select&lt;/code&gt;语句最后添加“\G”，会以列的格式来显示行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;alter&lt;/code&gt;：修改表结构等。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;4.日志&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;读日志是熟悉使用一个工具的最基本要求&lt;/strong&gt;。如果执行了一个sql脚本之后，提示&lt;code&gt;n warnings&lt;/code&gt;，可以使用&lt;code&gt;show warnings&lt;/code&gt;命令来查看详细信息。&lt;/p&gt;

&lt;p&gt;假设场景：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;现在mysql运行，希望知道哪些sql命令正在运行；（正在执行的命令）&lt;/li&gt;
    &lt;li&gt;现在mysql运行，希望知道曾经执行过的sql命令；（历史命令）&lt;/li&gt;
    &lt;li&gt;运行出现问题，mysql无法正常使用，现在希望查看mysql的运行日志；&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;查看mysql的运行状态，命令：status；结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; status;
--------------
mysql  Ver 14.14 Distrib 5.1.60, for redhat-linux-gnu (x86_64) using readline 5.1
 
Connection id:          21449
Current database:       chinacache
Current user:           root@localhost
SSL:                    Not in use
Current pager:          stdout
Using outfile:          &#39;&#39;
Using delimiter:        ;
Server version:         5.1.60 Source distribution
Protocol version:       10
Connection:             Localhost via UNIX socket
Server characterset:    utf8
Db     characterset:    utf8
Client characterset:    utf8
Conn.  characterset:    utf8
UNIX socket:            /home/data/mysqlData/mysql5.5.sock
Uptime:                 33 days 9 min 48 sec
 
Threads: 9  Questions: 15701727  Slow queries: 47  Opens: 1039  Flush tables: 1  Open tables: 541  Queries per second avg: 5.505
--------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意看，上面最后一行&lt;code&gt;slow queries&lt;/code&gt;这一项的值，如果多次查看的值都大于0，则说明有些查询的sql命令执行时间过长。&lt;/p&gt;

&lt;p&gt;查看当前正在运行的SQL，使用命令&lt;code&gt;show processlist；&lt;/code&gt;，从中找出运行较慢的语句，再使用&lt;code&gt;explain&lt;/code&gt;命令查看这些语句的执行计划。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show processlist;
+-------+------+----------------------+------------+---------+------+----------------+-
| Id    | User | Host                 | db         | Command | Time | State          |
+-------+------+----------------------+------------+---------+------+----------------+-
| 21185 | root | localhost            | chinacache | Sleep   | 3744 |                | 
| 21449 | root | localhost            | chinacache | Sleep   |  501 |                | 
| 21626 | root | localhost            | chinacache | Query   |    0 | NULL           | 
| 21630 | root | localhost            | chinacache | Query   |    0 | Sorting result | 
| 21695 | root | localhost            | chinacache | Sleep   |  685 |                | 
| 21732 | zuo  | 10.108.210.111:50198 | chinacache | Sleep   |   19 |                | 
| 21733 | zuo  | 10.108.210.111:50201 | chinacache | Sleep   |  258 |                | 
| 21742 | zuo  | 10.108.210.111:50229 | chinacache | Sleep   |   19 |                | 
| 21744 | root | localhost            | wordpress  | Sleep   |    6 |                | 
+-------+------+----------------------+------------+---------+------+----------------+-
9 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于MySQL的历史命令：需要在&lt;code&gt;my.cnf&lt;/code&gt;文件中添加:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[mysqld]
log=command.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新启动&lt;code&gt;mysqld&lt;/code&gt;，之后所有的命令都可以到上述文件中查询得到。&lt;/p&gt;

&lt;p&gt;查看当前启用的日志[7]，以及日志的存储路径：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;show variables like ‘log_%’;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;mysqlprocedure&quot;&gt;5.mysql存储过程（procedure）&lt;/h3&gt;

&lt;p&gt;什么是&lt;code&gt;mysql的存储过程&lt;/code&gt;[1][2][3]？简单的说，为方便使用而保存的一条或者多条MySQL语句的集合，就是一个sql脚本文件，有输入\出参数，根据参数来动态执行其内部SQL语句（存储过程，实际是一种函数）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DELIMITER //
-- Name:ordertotal
-- Parameters:onumber = order number
--            taxable = 0 if not taxable, 1 if taxable
--            ototal = order total variable
CREATE PROCEDURE ordertotal(
		  IN onumber INT,
		  IN taxable BOOLEAN,
		  OUT ototal DECIMAL(8,2)
)COMMENT &#39;Obtain order total, optionally adding tax&#39;
BEGIN
 
-- Declare variable for total
DECLARE total DECIMAL(8,2);
-- Declare tax percentage
DECLARE taxrate INT DEFAULT 6;
 
-- Get the order total
SELECT SUM(item_price*quantity)
		FROM ordertimes WHERE order_num = onumber INTO total;
 
-- Is this taxable?
IF taxable THEN 
		-- YES, so add taxrate to the total
		SELECT total+(total/100*taxrate) INTO total;
END IF;
 
-- And finally, save to our variable
SELECT total INTO ototal;
 
END //
 
DELIMITER ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看上面简单的&lt;code&gt;存储过程&lt;/code&gt;[1]，以此为例进行说明：首先，从意识上将上面的存储过程，看做一个函数。&lt;/p&gt;

&lt;p&gt;具体细节：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;code&gt;DELIMITER //&lt;/code&gt;表示暂时更改分隔符（mysql内判断为开始执行的分隔符）；&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;–- &lt;/code&gt;（最后有一个空格）表示单行注释；&lt;/li&gt;
    &lt;li&gt;上面的&lt;code&gt;procedure&lt;/code&gt;包含了2个输入参数（IN）和一个返回参数（OUT）；&lt;/li&gt;
    &lt;li&gt;过程body中，使用&lt;code&gt;declare&lt;/code&gt;定义了2个局部变量，&lt;code&gt;declare&lt;/code&gt;要求使用变量名和类型；&lt;code&gt;select… into…&lt;/code&gt; 语句将查询结果保存到&lt;code&gt;into&lt;/code&gt;后面的变量中；&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;if…then…end&lt;/code&gt; if语句表示了是否一个条件判断执行过程。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;：&lt;code&gt;procedure&lt;/code&gt;的参数后面有&lt;code&gt;COMMENT&lt;/code&gt;类似于备注，当使用&lt;code&gt;SHOW PROCEDURE STATUS;&lt;/code&gt;时可以看到此字段。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;:注意存储过程中的&lt;strong&gt;输入参数&lt;/strong&gt; 不能作为表名（&lt;code&gt;table name&lt;/code&gt;）,如果必须将表名当做输入参数，可以使用预处理机制：&lt;code&gt;PREPARE&lt;/code&gt;、&lt;code&gt;EXECUTE&lt;/code&gt;、&lt;code&gt;DEALLOCATE PREPARE&lt;/code&gt;。具体借鉴另一篇blog&lt;a href=&quot;/mysql-data-cleaning/&quot;&gt;MYsql——数据去重&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;:上面使用&lt;code&gt;DECLARE&lt;/code&gt;进行变量的声明，在很多情况下会看到&lt;code&gt;set @var&lt;/code&gt;类型的变量，关于变量详细信息参考[5]（猜测只是变量的作用范围不同，其他的本质都是变量，没有什么不同？）。&lt;/p&gt;

&lt;p&gt;常用的操作：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;执行存储过程：&lt;code&gt;CALL procedure_name(params);&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;删除存储过程：&lt;code&gt;DROP PROCEDURE procedure_name;&lt;/code&gt;（&lt;code&gt;DROP PROCEDURE IF EXISTS procedure_name;&lt;/code&gt;）&lt;/li&gt;
    &lt;li&gt;显示所有正在运行的存储过程：&lt;code&gt;SHOW PROCEDURE STATUS&lt;/code&gt;;其中包含了&lt;code&gt;procedure&lt;/code&gt;的名称、创建时间、修改时间等;&lt;/li&gt;
    &lt;li&gt;显示存储过程的创建语句：&lt;code&gt;SHOW CREATE PROCEDURE procedure_name&lt;/code&gt;;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;6.数据备份（操作）&lt;/h3&gt;

&lt;p&gt;(doing…)&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;7.常用工具&lt;/h3&gt;

&lt;p&gt;(doing…)&lt;/p&gt;

&lt;h3 id=&quot;mysql&quot;&gt;8.(万佛归宗)Mysql整体框架，内部线程机制，语句执行效率&lt;/h3&gt;

&lt;p&gt;(doing…)&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;参考来源&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;《MySQL必知必会》Page171&lt;/li&gt;
  &lt;li&gt;http://blog.sina.com.cn/s/blog_71f4cdbe0100yut4.html&lt;/li&gt;
  &lt;li&gt;http://www.ccvita.com/100.html&lt;/li&gt;
  &lt;li&gt;http://www.ccvita.com/category/mysql/&lt;/li&gt;
  &lt;li&gt;http://blog.csdn.net/lxgwm2008/article/details/7738306&lt;/li&gt;
  &lt;li&gt;http://joewalker.iteye.com/blog/277626&lt;/li&gt;
  &lt;li&gt;http://blog.sina.com.cn/s/blog_406127500100pvar.html&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>MySQL--字段内信息抽取</title>
     <link href="http://ningg.github.com/mysql-data-extract"/>
     <updated>2013-01-15T00:00:00+08:00</updated>
     <id>http://ningg.github.com/mysql-data-extract</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;问题背景&lt;/h2&gt;

&lt;p&gt;现在有一张表，结构如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字段&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;类型&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;IP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;varchar(30)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;timeStart&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;double(13,3)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;durationTime&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;double(13,3)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;httpURL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;varchar(1000)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;terminalType&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;varchar(1000)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;现在要从字段&lt;code&gt;httpURL&lt;/code&gt;中提取一些字符串，并作为新的属性，添加到表中。&lt;/p&gt;

&lt;p&gt;一个典型的httpURL格式如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://appldnld.apple.com/iOS6/041cfbLY/com_Update/6b2a5.zip&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在要提取&lt;code&gt;iOS6&lt;/code&gt;和&lt;code&gt;com_Update&lt;/code&gt;字段，并且组合为：&lt;code&gt;iOS6_com_Update&lt;/code&gt;，将此作为新字段添加到表中。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;解决办法&lt;/h2&gt;

&lt;p&gt;初步思考，解决步骤如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;取出一条记录；&lt;/li&gt;
    &lt;li&gt;将字段“httpURL”中信息提取出来，组合；&lt;/li&gt;
    &lt;li&gt;将获得的最终组合信息，添加到最新字段中。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;关键&lt;/strong&gt;，使用&lt;code&gt;substring_index&lt;/code&gt;函数。&lt;/p&gt;

&lt;p&gt;直接贴上脚本吧（利用MySQL存储过程）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 *
 *usage：
 *      1) login the &#39;mysql&#39; ;
 *      2) source ~/enurl.sql;
 *      3) CALL enurl(&#39;oldTable&#39;,&#39;newTable&#39;);
 *
 *function: get the information from column &quot;httpURL&quot;, then store it in an new-bulit column &quot;info_1&quot;; we create a new table &#39;newTable&#39; to store the results;
 *
 *parameters:
 *      oldTable: the original table, that we need to get some information from the column &quot;httpURL&quot;;
 *      newTable: the new build table, where we store the results.
 *
 *author：Ning Guo
 *
 *time: 1/16/2013
 *
 *程序运行效果：
 *  260万数据，执行时间为：1min 2s
 *
 *
 */
DROP PROCEDURE IF EXISTS enurl;
DELIMITER //
CREATE PROCEDURE enurl(
		$oldTable VARCHAR(60),
		$newTable VARCHAR(60)
)
BEGIN
		SET @SQL= concat(&#39;DROP TABLE IF EXISTS &#39;,$newTable);
		PREPARE stmt1 FROM @SQL;
		EXECUTE stmt1;
		DEALLOCATE PREPARE stmt1;
 
		SET @SQL= concat(&#39;CREATE TABLE &#39;,$newTable,&#39; SELECT * FROM &#39;,$oldTable);
		PREPARE stmt1 FROM @SQL;
		EXECUTE stmt1;
		DEALLOCATE PREPARE stmt1;
 
		SET @SQL= concat(&#39;ALTER TABLE &#39;,$newTable,&#39; ADD info_1 varchar(60)&#39;);
		PREPARE stmt1 FROM @SQL;
		EXECUTE stmt1;
		DEALLOCATE PREPARE stmt1;
 
		SET @SQL= concat(&#39;UPDATE &#39;,$newTable,&#39; SET info_1=(select concat(substring_index(substring_index(httpURL,\&#39;/\&#39;,4),\&#39;/\&#39;,-1),concat(\&#39;_\&#39;,substring_index(substring_index(
httpURL,\&#39;/\&#39;,6),\&#39;/\&#39;,-1))))&#39;);
		PREPARE stmt1 FROM @SQL;
		EXECUTE stmt1;
		DEALLOCATE PREPARE stmt1;
 
END //
DELIMITER ;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参考来源&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;http://www.chinesejy.com/jishu/508/518/20101017465148.html&lt;/li&gt;
  &lt;li&gt;http://www.jb51.net/article/27458.htm&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
 
</feed>
