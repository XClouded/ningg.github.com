<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>NingG.github.com</title>
   <link href="http://ningg.github.com/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://ningg.github.com" rel="alternate" type="text/html" />
   <updated>2014-09-30T01:38:48+08:00</updated>
   <id>http://ningg.github.com</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>线框图工具：mockups</title>
     <link href="http://ningg.github.com/mockups-intro"/>
     <updated>2014-09-29T00:00:00+08:00</updated>
     <id>http://ningg.github.com/mockups-intro</id>
     <content type="html">&lt;h2 id=&quot;mockups&quot;&gt;mockups的特点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;快：提供常用的元素，通过简单托、拉、拽等动作，即可完成线框图绘制；&lt;/li&gt;
  &lt;li&gt;手绘风格：展示效果，朴素、简洁，能够突出内容、层次结构、业务流程；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;基础用法&lt;/h2&gt;

&lt;p&gt;简单的托、拉、拽内置的组件，就能够达到如下的效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/mockups-intro/simple-operate.jpg&quot; alt=&quot;简单的鼠标操作&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;高效用法&lt;/h2&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;操作&lt;/td&gt;
      &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;/&lt;/code&gt;/&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;快速定位到&lt;code&gt;Quick Add&lt;/code&gt;输入框，在其中输入控件名字，即可自动添加一个元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;Enter&lt;/code&gt;/&lt;code&gt;F2&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;编辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;Ctrl+2&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;锁定&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;Ctrl+Up&lt;/code&gt;/&lt;code&gt;Ctrl+Down&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;上移、下移一层&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;Ctrl+D&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;复制并粘贴，相当于&lt;code&gt;Ctrl+C&lt;/code&gt; + &lt;code&gt;Ctrl+D&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;几点补充：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;官方提供一些现有的UI模版：&lt;a href=&quot;http://support.balsamiq.com/customer/portal/articles/1311316-how-to-download-from-mockups-to-go&quot;&gt;Mockups To Go&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;通过点击，可实现mockups一个页面跳转到同一目录下的另一个页面；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（官方网站内容还没有看完，doing…）&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://support.balsamiq.com/#support-documentation&quot;&gt;Mockups官网文档&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://support.balsamiq.com/customer/portal/topics/49503-tutorials&quot;&gt;Mockups官网Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;扯一点小事：写这篇文章关于mockups操作的文章，起初是无意间受到&lt;code&gt;1-2-3&lt;/code&gt;的博客《&lt;a href=&quot;http://www.cnblogs.com/1-2-3/archive/2009/08/17/Balsamiq-Mockups-Introduction.html&quot;&gt;我喜欢Balsamiq Mockups的三大理由&lt;/a&gt;》和《&lt;a href=&quot;http://www.cnblogs.com/1-2-3/archive/2009/06/30/Balsamiq-Mockups-tips.html&quot;&gt;Balsamiq Mockups 小技巧&lt;/a&gt;》 启发，不过自己当时冷静了一下，脑海里闪烁一个疑问：&lt;code&gt;1-2-3&lt;/code&gt;关于mockups的知识是从哪获取的？哦，官网，最初的知识传播，肯定是某人比较认真，读了官网，然后知识就散播开了，OK，为避免知识在传播过程中有损伤、误解，我直接找根源好了，这样的做法在普通人看来笨拙，却是真正捷径，最简洁、省时、省力的方法。&lt;/p&gt;
&lt;/blockquote&gt;

</content>
   </entry>
   
   <entry>
     <title>CTO这点事</title>
     <link href="http://ningg.github.com/talk-about-cto"/>
     <updated>2014-09-28T00:00:00+08:00</updated>
     <id>http://ningg.github.com/talk-about-cto</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;题记：本文转载自caoz，原文地址：&lt;a href=&quot;http://zhuanlan.zhihu.com/iamcaoz/19856992&quot;&gt;CTO这点事&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;几乎整个互联网行业都缺CTO，特别是一些草根背景的创业者，这个问题更加显著。从我自己的感受，身边各种朋友委托我找CTO的需求，嗯，算下来超过两位数了，光最近一个月就有3个，而且这三家都是刚拿了A轮的。其他那些公司CTO大部分空缺了一两年，或者其他高管临时暂代过渡。实话说，我觉得每个公司都不错的，但通常也只能遗憾的说，真没有能推荐的。
其实，根据个人的观察，每个互联网团队都喊需要CTO，但是具体诉求却各不相同，如果说共性，就只有一点，那就是，公司老板对技术的期望值与目前技术团队的能力表现，有较大的差异，而这个差异，对于老板来说，就是一个想法，找个合格的CTO，一切就都解决了。其实，真不是这回事。&lt;/p&gt;

&lt;p&gt;今天要说的第一点，就是期望值的控制；很多互联网公司都希望自己走技术驱动的路线，期望小而美，复制美国技术新贵的市场表现；这不能说是一个错误的期望，但是，现实能有多少符合这种需求的人才呢？这样的人才需要技术有前瞻性，对产业格局有判断，对管理有心得，情商还不能低（算了一下，四项里我至少三项不符合。）。整个行业内这样的人有几个？凭什么会跟你？　事实上我身边确实有这样的案例，一个以业务为主的公司，搞定了一个超棒的CTO，很快就转型成以技术为驱动的公司，公司价值极大提升，问题是，这种现象很难具有复制性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/talk-about-cto/chinese-carrier.jpg&quot; alt=&quot;chinese-carrier&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cto&quot;&gt;大家对CTO的期望&lt;/h2&gt;

&lt;p&gt;下面我说一下一个最基本的让人纠结的问题，到底什么是CTO？其实，空谈这个名词的定义毫无意义，从我身边很多朋友公司的实例来看，他们对这个角色的定义和定位是差异非常大的。具体而言，不同创业团队，对CTO需求的真实想法，包括如下层面。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;技术选型&lt;/h3&gt;

&lt;p&gt;这其实是创业公司最纠结的问题；他们往往一上来基于已有的程序员的个人习惯和爱好，选择了一个技术方案，然后到某一天一看，我靠，全是坑（当然，也可能与执行者的能力有关）。而更糟的是，这个技术方案相对冷门，市场上去招聘都很难做。还有就是技术方案成本过高，（不只是钱的问题，特别是时间成本！）结果严重影响到后续的发展速度。　我举个简单例子，最近我给多个创业者提建议，比如做app，很多以内容运营为核心的app，不要用原生态开发，目前一堆第三方的跨平台开发架构，如果选择合适，可以极大减少开发成本，以及降低技术招聘的难度。微信开店开社区，也有一堆第三方平台，这些事情，对于一些创业者来说，就是特纠结的事情，第一，他们并不完全了解这个领域；第二，他们就算有所了解，也很难判断究竟谁家的方案更靠谱？难道要靠百度竞价排名来裁决么？　而对于技术人员，包括相当多技术高手，他们也会有一些自己的打算，比如说，我就熟悉这个，为啥要用我不熟悉的？（没有考虑从公司长远的人力成本和开发效率）。比如说，我本来服务端技术很强，现在用了一个开源服务端框架，比如skynet，我变成写脚本的了，我价值怎么体现？（不知道自己的价值来自于产品的市场表现）。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;万能适配器&lt;/h3&gt;

&lt;p&gt;公司有了一个基本的起步，比如在某个平台上有了一点成绩，然后希望扩展到不同领域，不同平台，然后老板突然发现，哦，原来程序员不是什么都会的。服务端，前端，运维，安全，数据库，甚至SEO优化（你敢说这不是技术？）最好有个牛人都能带起来，这个牛人，就是他们定义的CTO，咳咳。创业公司，人少而事杂，其实，真的可以理解。我认识不少创业者，最终万般无奈下，硬是把自己逼成了万能哥。话说当年我也是创业的时候，万般无奈才自学怎么做运维的，虽然很多都没学会，但是偶尔也能出去忽悠一下。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;性能调优及架构扩展&lt;/h3&gt;

&lt;p&gt;很多小公司到了一定的用户规模和并发规模的时候，一下子就扛不住了，甚至严重影响业务的拓展，某著名淘品牌自己做了一个独立网店，结果一搞秒杀活动就崩溃，（吐个槽，他们运营人员也死心眼，就知道搞秒杀，知道技术架构不行，不会搞点别的形式么）。结果独立网店一直就没搞起来。其实很多这些偏传统的互联网公司，他们所遇到的问题，在高手眼里不值一提，但是这个坎过不去，他们真就发展不起来。说个题外话八卦一下，当年腾讯叫oicq的时候，一堆*icq，只有腾讯牛了，其他的为啥不行？真的是产品原因么？其实都是这个问题，到了１００万用户的时候，就只有腾讯还能发展新用户，其他的技术全都撑不住了。大家看到的都是剩者为王，我看到的是，数不清非常不错的产品，死在这个环节上了。严格的说，这其实不是CTO的工作，按照分工来说，通常涉及系统分析师，系统架构师，以及DBA来做这方面的工作，但是对于创业公司，根本就没这种角色设定，他们遇到这个问题，通常想到的是，有个好的CTO就好了。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;团队管理和效率提升&lt;/h3&gt;

&lt;p&gt;这还真是CTO的本职工作了，我遇到技术出身的创业者，他纠结的问题是，当时自己一个人做开发，连带着做运营，七七八八一堆事，也把东西做起来了，现在公司产品知名度有了，拿到投资了，开发团队也搭起来了，怎么开发效率反而下去了？所以，他的理解是，需要一个CTO。　从技术人才招聘，团队培养，技术培训，到开发模式培训（比如现在流行的敏捷开发），产品质量测评体系，信息安全防护等等，这些林林总总的事情，对于创业者来说，就全部归纳为“需要一个CTO”，嗯。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;数据决策体系&lt;/h3&gt;

&lt;p&gt;自从“大数据”概念火了以后，基本上所有创业者都在谈，我的业务模式，发展了海量用户后，一定是基于数据驱动，可是数据咋驱动？没几个人真想清楚了，但是没关系，只要有CTO，这个问题就解决了。　我知道真有能搞定此事的CTO，真的有，不过，真的属于稀缺品种，目测比大熊猫还少。因为，要理解数据驱动，首先要理解业务，而理解业务，往往不是技术人员的特长。又要自吹一句，我在百度的时候，最牛逼的事情就是在产品部门里搭出一个技术团队，来做数据，为什么要坚持在产品部门编制？（实话说，当年技术部门的薪酬更高一些），我坚持认为重心在于数据目标和解读，而不是技术实现。　所以，这里我多说一句，数据决策体系，先想清楚具体目标和具体展现，再寻求技术支持，而不是一句话推给技术团队去弄，除非你公司里真有这么一只极品稀缺大熊猫。　实际上，再吐个槽，最基本的数据处理的结果，经过正确严谨的解读，就已经有极大的价值了，而很多人往往无视这些，去追求更高深的技术实现，搞一些莫名其妙的算法和逻辑，来彰显技术价值，其实是舍近求远的表现。　&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;重构商业模式&lt;/h3&gt;

&lt;p&gt;这个，咳咳，怎么说呢，公司觉得自己商业模式不够酷，不够吸引资本关注，希望从业务驱动转为技术驱动，嗯，来个牛逼的CTO，这事真可行，嗯，话说，这事真可行，点到为止，不展开了。　&lt;/p&gt;

&lt;p&gt;以上是我观测到的，身边以及业内一些典型的CTO需求，当然，不同公司诉求真的不一样。有的侧重管理，有的侧重解决瓶颈问题，但是对老板而言，只要他们认为目前技术团队不够好，不够给力，不够预期，那么，这就是他们认为缺乏的，CTO。不仅仅是创业公司，上市公司乃至巨头，这个问题也一样存在，比如说，百度的CTO，貌似空缺了好几年呢。是他们的人才不够优秀么？还不是达不到李厂长期望值。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;个人观点&lt;/h2&gt;

&lt;p&gt;下面说我的一些观点&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一&lt;/strong&gt;，相当比例大公司背景的技术牛人，并不适合去创业公司做CTO，原因1：技术再牛，不够全面，这没辙，大公司求深，创业公司求全；原因2：技术再牛，要懂业务。创业公司没有完备严谨的产品经理，没有明确的目标规划，很多工作是一个初步的目标，然后做起来看。如果技术人员不懂业务，很可能就会走弯路，做出很多不伦不类的东西，所以创业公司遇到这样的大牛，要先沟通到位再决定，不要迷信简历，当然，不乏这里有非常出色的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二&lt;/strong&gt;，创始公司老板要想清楚自己当前真正需要的是什么，控制一下目标和欲望，有些事不能强求的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三&lt;/strong&gt;，要给人才成长的空间，CTO也不是天生的，不要认为外面的和尚一定好念经。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第四&lt;/strong&gt;，遇到真的特别合适的人才，要舍得本钱，理想可以谈，但是让人家舍弃各种丰厚回报的机会来跟你打拼，总要出示一些诚意。要知道这样的人才是稀缺品。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;几点解释&lt;/h2&gt;

&lt;p&gt;最后解释一下 CTO所需要的四个领域的能力&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;技术前瞻性&lt;/strong&gt;，就好比2010年谷歌手机发布了，您还在那里吭哧吭哧跟老板说咱们好好弄塞班。（好多技术牛人，大公司的技术总监都是这样的！！！）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对产业格局有判断&lt;/strong&gt;，举例来说，移动互联网起来了，能知道工具型，娱乐性，生活性的应用大概的爆发周期和爆发规模。 能对移动游戏，电商的发展速度和市场顶点在哪里，这样才能给老板正确的技术投入建议和规划目标建议，别市场喷发的时候不去考虑准备架构扩容，还在角落里扣扣索索的算怎么比同行省点运维成本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;管理心得&lt;/strong&gt;，技术团队的培养和带动，别光顾着自己牛逼，要让团队牛逼。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;情商&lt;/strong&gt;，各种沟通，协调，不解释。&lt;/p&gt;

&lt;p&gt;就这样，有点凌乱，凑活看吧&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>优秀的软件工程师</title>
     <link href="http://ningg.github.com/software-engineer-self-test"/>
     <updated>2014-09-28T00:00:00+08:00</updated>
     <id>http://ningg.github.com/software-engineer-self-test</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;题记：本文转载自邹欣的书籍《&lt;a href=&quot;http://book.douban.com/subject/25965995//&quot;&gt;构建之法&lt;/a&gt;》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;保持高标准，不要受制于破窗理论(broken windows theory)。
当你看到不靠谱的设计、糟糕的代码、过时的文档和测试用例的时候，不要想“既然别人的代码已经这样了，我的代码也可以随便一点啦。”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主动解决问题。当看到不靠谱的设计，糟糕的代码的时候，不要想“可能别人会来管这个事情” ，或者“我下个月发一个邮件让大家讨论一下”。要主动地把问题给解决了[ii]。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;经常给自己充电，身体训练是运动员生活的一部分，学习是软件工程师职业的伴侣。每半年就要了解和学习一些新的相关技术。通过定期分享（面对面的分享，写技术博客等）来确保自己真正掌握了新技术。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DRY （Don’t Repeat Yourself）——别重复。在一个系统中，每一个知识点都应该有一个无异议的、正规的表现形式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;消除不相关模块之间的影响，在设计模块的时候，要让它们目标明确并单一，能独立存在，没有不明确的外部依赖。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过快速原型来学习，快速原型的目的是学习，它的价值不在于代码，而在于你通过快速原型学到了什么。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设计要接近问题领域，在设计的时候，要接近你目标用户的语言和环境。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;估计任务所花费的时间，避免意外。在开始工作的时候，要做出时间和潜在影响的估计，并通告相关人士，避免最后关头意外发生。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图形界面的工具有它的长处，但是不要忘了命令行工具也可以发挥很高的效率，特别是可以用脚本构建各种组合命令的时候。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有很多代码编辑器，请把其中一个用得非常熟练。让编辑器可以实现自己的定制，可以用脚本驱动，用起来得心应手。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;理解常用的设计模式，并知道择机而用。设计模式不错，更重要的是知道它的目的是什么，什么时候用，什么时候不用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;代码版本管理工具是你代码的保障，重要的代码一定要有代码版本管理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在debug的时候，不要惊慌，想想导致问题的原因可能在哪里。一步一步地找到原因。要在实践中运用工具，善于分析日志（log），从中找到bug。同时，在自己的代码里面加 log.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重要的接口要用形式化的“合同”来规定。用文档和断言、自动化测试等工具来保证代码的确按照合同来做事，不多也不少。使用断言 (assertion) 或者其他技术来验证代码中的假设，你认为不可能发生的事情在现实世界中往往会发生。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;只在异常的情况下才使用异常 (Exception),  不加判断地过多使用异常，会降低代码的效率和可维护性。记住不要用异常来传递正常的信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;善始善终。如果某个函数申请了空间或其他资源，这个函数负责释放这些资源。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当你的软件有多种技术结合在一起的时候，要采用松耦合的配置模式，而不是要把所有代码都集成到一起。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把常用模块的功能打造成独立的服务，通过良好的界面 (API) 来调用不同的服务。[YEKA1] &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在设计中考虑对并行的支持，这样你的API 设计会比较容易扩展。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在设计中把展现模块 (View) 和实体模块 (Model) 分开，这样你的设计会更有灵活性。 &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重视算法的效率，在开始写之前就要估计好算法的效率是哪一个数量级上的（big-O）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在实际的运行场景中测试你的算法，不要停留在数学分析层面。有时候一个小小的实际因素 (是否支持大小写敏感的排序，数据是否支持多语言)会导致算法效率的巨大变化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;经常重构代码，同时注意要解决问题的根源。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在开始设计的时候就要考虑如何测试 ，如果代码出了问题，有log 来辅助debug 么? 尽早测试，经常测试，争取实现自动化测试，争取每一个构建的版本都能有某些自动测试。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;代码生成工具可以生成一堆一堆的代码，在正式使用它们之前，要确保你能理解它们，并且必要的时候能debug 这些代码。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;和一个实际的用户一起使用软件，获得第一手反馈。 &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在自动测试的时候，要有意引地入bug，来保证自动测试的确能捕获这些错误。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果测试没有做完，那么开发也没有做完。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;适当地追求代码覆盖率：每一行的代码都覆盖了，但是程序未必正确。要确保程序覆盖了不同的程序状态和各种组合条件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果团队成员碰到了一个有普遍意义的bug,  应该建立一个测试用例抓住以后将会出现的类似的bug。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试：多走一步，多考虑一层。如果程序运行了一星期不退出，如果用户的屏幕分辨率再提高一个档次，这个程序会出什么可能的错误?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（带领团队）了解用户的期望值，稍稍超出用户的期望值，让用户有惊喜。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(带领团队) 不要停留在被动地收集需求，要挖掘需求。真正的需求可能被过时的假设、对用户的误解或其他因素所遮挡。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（带领团队）把所有的术语和项目相关的名词、缩写等都放在一个地方。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（带领团队）不要依赖于某个人的手动操作，而是要把这些操作都做成有相关权限的人士都能运行的脚本。这样就不会出现因为某人休假而项目被卡住的情况。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（带领团队）要让重用变得更容易。一个软件团队要创造一种环境，让软件的重用变得更容易。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（带领团队）在每一次迭代之后，都要总结经验，让下一次迭代的日程安排更可靠。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;备注：&lt;/p&gt;

&lt;p&gt;其他上面的内容，其他地方也有转载和评论：&lt;a href=&quot;http://www.cnblogs.com/xinz/p/3852177.html&quot;&gt;邹欣的教学博客&lt;/a&gt;和&lt;a href=&quot;http://www.zhihu.com/question/19560521/answer/31141681&quot;&gt;知乎出版人周筠&lt;/a&gt;。&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>Android入门几个基本知识</title>
     <link href="http://ningg.github.com/android-lesson-one"/>
     <updated>2014-09-23T00:00:00+08:00</updated>
     <id>http://ningg.github.com/android-lesson-one</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近参加某活动，也算掌握了点滴的内容，整理一下，算是阶段的笔记。&lt;/p&gt;

&lt;h2 id=&quot;android4&quot;&gt;Android的4个模块&lt;/h2&gt;

&lt;p&gt;Android开发中涉及4个模块/对象：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Activity；&lt;/li&gt;
  &lt;li&gt;Service；&lt;/li&gt;
  &lt;li&gt;Broadcast Receiver；&lt;/li&gt;
  &lt;li&gt;Content Provider；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;activity&quot;&gt;Activity&lt;/h3&gt;

&lt;p&gt;通常是用户界面，粒度也可能更细些，例如：菜单列表、图片、图片标题，都可能是一个单独的Activity；&lt;/p&gt;

&lt;h3 id=&quot;service&quot;&gt;Service&lt;/h3&gt;

&lt;p&gt;没有用户界面，但会一直在后台运行，例如：进行其他操作时，播放背景音乐、后台下载数据；&lt;/p&gt;

&lt;h3 id=&quot;broadcast-receiver&quot;&gt;Broadcast Receiver&lt;/h3&gt;

&lt;p&gt;应用程序利用Broadcast Receiver机制，来接收、发送广播消息，举例：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;接收/拨打电话；&lt;/li&gt;
  &lt;li&gt;接收/发送短信；&lt;/li&gt;
  &lt;li&gt;手机所处时区改变时，应用程序会接收到通知；&lt;/li&gt;
  &lt;li&gt;电池电量不足；&lt;/li&gt;
  &lt;li&gt;用户选择一张图片；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;content-provider&quot;&gt;Content Provider&lt;/h3&gt;

&lt;p&gt;应用程序利用Content Provider机制，来进行数据共享，例如：读取系统电话簿中联系人；&lt;/p&gt;

&lt;h2 id=&quot;activity-1&quot;&gt;Activity的生命周期&lt;/h2&gt;

&lt;p&gt;生命周期？对，这个术语在计算机相关的开发中，总能听到，到底什么意思？干什么的？生命周期，&lt;code&gt;lifecycle&lt;/code&gt;，其基本目标是：描述清楚一个对象从产生到消亡的过程，为开发者干预这一过程提供方法。&lt;em&gt;（用个通俗的术语来重新表述一下Object lifecycle：物体的状态变化路径）&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;back-stack&quot;&gt;返回站（Back Stack）&lt;/h3&gt;

&lt;p&gt;说Activity的生命周期之前，补充一个概念：返回栈；为了方便管理Activity，将多个相互关联的Activity合并称作一个Task，一个Task对应一个Back Stack。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-lesson-one/diagram_backstack.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于返回栈，简要说明几点（官方文档）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A &lt;code&gt;task&lt;/code&gt; is a collection of activities that users interact with when performing a certain job.&lt;/li&gt;
  &lt;li&gt;the back stack operates as a &lt;code&gt;last in, first out&lt;/code&gt; object structure.&lt;/li&gt;
  &lt;li&gt;pushed onto the stack when started by the current activity and popped off when the user leaves it using the Back button.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;activity-2&quot;&gt;Activity状态&lt;/h3&gt;

&lt;p&gt;Activity从产生到消亡，会有几个典型的状态，简要说一下（来自官方文档）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;运行状态：栈顶，显示Activity；&lt;/li&gt;
  &lt;li&gt;暂停状态：不处于栈顶，但部分可见；&lt;/li&gt;
  &lt;li&gt;停止状态：不处于栈顶，也全部不可见；&lt;/li&gt;
  &lt;li&gt;销毁状态：返回栈中，已经移除；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;acitivity-lifecycle&quot;&gt;Acitivity lifecycle&lt;/h3&gt;

&lt;p&gt;Activity生命周期如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-lesson-one/activity_lifecycle.png&quot; alt=&quot;activity_lifecycle.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;备注：可利用上面7个回调方法，来调整Activity。&lt;/p&gt;

&lt;h2 id=&quot;intent&quot;&gt;Intent简介&lt;/h2&gt;

&lt;p&gt;Intent是不同组件之间进行交互的重要方式，基本点两个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;指明当前组件要执行的动作；&lt;/li&gt;
  &lt;li&gt;不同组件之间传递的数据；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Intent能够携带数据，具体用途有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;启动Activity；&lt;/li&gt;
  &lt;li&gt;启动Service；&lt;/li&gt;
  &lt;li&gt;发送广播；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Intent分为2类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;显式Intent：举例，Intent直接指定下一步启动的Activity；&lt;/li&gt;
  &lt;li&gt;隐式Intent；举例，通过Activity的&lt;code&gt;&amp;lt;activity&amp;gt;&amp;lt;intent-filter&amp;gt;&lt;/code&gt;来隐式指定，某个Activity来捕获哪一类的Intent；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;android&quot;&gt;Android测试相关&lt;/h2&gt;

&lt;p&gt;之前，我对测试不感兴趣的，但最近感觉，开发中前期，对系统弄一个测试框架，能够提升开发、调试的效率，同时，也能在产品最终上线前进行较为全面的验证。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;测试点&lt;/h3&gt;

&lt;p&gt;测试，到底要测哪些方面？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;功能测试
    &lt;ul&gt;
      &lt;li&gt;安装/卸载&lt;/li&gt;
      &lt;li&gt;具体功能点&lt;/li&gt;
      &lt;li&gt;联网（默认的联网方式：wifi or sim卡？网络切换是否有相应提示？飞行模式）&lt;/li&gt;
      &lt;li&gt;程序进入输入功能时，是否正常弹出键盘？键盘是否遮挡应用需要输入内容的对话框？&lt;/li&gt;
      &lt;li&gt;home键与应用之间，多次切换&lt;/li&gt;
      &lt;li&gt;返回上一级操作，退出程序后的提示&lt;/li&gt;
      &lt;li&gt;当离开应用一段事件后，再次回到应用程序时，不能丢失用户数据；&lt;/li&gt;
      &lt;li&gt;横屏、竖屏切换时，不能丢失用户数据；&lt;/li&gt;
      &lt;li&gt;长按某一按钮，是否会触发其他事件；&lt;/li&gt;
      &lt;li&gt;PC端与APP端的数据同步（例如，bloger在PC端设置禁止他人评论，则，APP上也应禁止评论）&lt;/li&gt;
      &lt;li&gt;APP中内嵌的链接，程序如何处理？如果调用设备的浏览器，能否正常切回到APP？&lt;/li&gt;
      &lt;li&gt;各个页面间，多次切换&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;性能测试
    &lt;ul&gt;
      &lt;li&gt;APP的整体响应速度；&lt;/li&gt;
      &lt;li&gt;连续点击相同按钮（游戏类APP）&lt;/li&gt;
      &lt;li&gt;快速划屏（游戏类APP）&lt;/li&gt;
      &lt;li&gt;长时间使用应用&lt;/li&gt;
      &lt;li&gt;当应用不处于活动状态时，不能大量消耗系统资源&lt;/li&gt;
      &lt;li&gt;耗电情况&lt;/li&gt;
      &lt;li&gt;运行过程中，需要产看内存和CPU的使用情况：&lt;code&gt;adb shell top&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;异常测试
    &lt;ul&gt;
      &lt;li&gt;低电量情况下使用应用&lt;/li&gt;
      &lt;li&gt;（处理以下情况时，应用不能崩溃，并且返回应用后，数据不能丢失）&lt;/li&gt;
      &lt;li&gt;使用应用时，对来电的处理&lt;/li&gt;
      &lt;li&gt;使用应用时，对短信的处理&lt;/li&gt;
      &lt;li&gt;使用应用时，闹铃响起&lt;/li&gt;
      &lt;li&gt;使用应用时，锁屏、解锁&lt;/li&gt;
      &lt;li&gt;网络异常：使用应用时，断网；断网情况下，启动应用 &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;UI测试&lt;/li&gt;
  &lt;li&gt;不同系统语言的支持&lt;/li&gt;
  &lt;li&gt;适配测试
    &lt;ul&gt;
      &lt;li&gt;目标：测试不同厂家、型号的手机上，APP的运行效果；&lt;/li&gt;
      &lt;li&gt;背景：由于手机型号、总类繁多，通常只关注当前用户数较多的手机&lt;/li&gt;
      &lt;li&gt;问题1：如何找出用户较多的具体手机型号？&lt;/li&gt;
      &lt;li&gt;RE问题1：选几个纬度，屏幕尺寸、分辨率、Android系统版本，正交定位一下&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;android-testing-framework&quot;&gt;Android Testing Framework&lt;/h3&gt;

&lt;p&gt;下面会列出一张图（官网拿的），简要说几点：&lt;em&gt;（可能理解有错，会陆续更正）&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Mock Objects&lt;/code&gt;：模拟系统的一切行为；另，支持依赖注入；&lt;/li&gt;
  &lt;li&gt;JUnit：写单元测试；（白盒测试）&lt;/li&gt;
  &lt;li&gt;Instrumentation：可以模拟系统行为，捕获Activity的任何一个回调方法；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/android-lesson-one/test_framework.png&quot; alt=&quot;test_framework.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基于这一测试框架，能够进行如下几个测试：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单元测试；&lt;/li&gt;
  &lt;li&gt;框架测试；（什么意思？）&lt;/li&gt;
  &lt;li&gt;UI测试；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;备注：在官网文档中，&lt;code&gt;Develop&lt;/code&gt;–&lt;code&gt;Tools&lt;/code&gt;部分，针对&lt;code&gt;Tests&lt;/code&gt;有详细介绍。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;测试工具&lt;/h3&gt;

&lt;p&gt;列几个常用测试工具，以及简要的说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;monkey：产生伪随机事件流，用途：压力测试、随机点击；&lt;/li&gt;
  &lt;li&gt;monkey runner：利用python脚本，进行自动化测试，可以测试安装/卸载、截图、业务使用流程；&lt;/li&gt;
  &lt;li&gt;Hierarchy Viewer：可视化方式，显示UI树，用途：调试、优化，用户界面；另，可以放大界面；&lt;/li&gt;
  &lt;li&gt;DDMS（Dalvik Debug Monitor Service）：Eclipse下的一个视图，用途：模拟设备的地理位置变动；&lt;/li&gt;
  &lt;li&gt;traceview：跟踪程序性能，并且具体到method；&lt;em&gt;（&lt;code&gt;Debug.startMethodtrace(FILE)&lt;/code&gt;启动跟踪）&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;附录&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;几个名词&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;回归测试：修改代码之后，重新测试。&lt;/li&gt;
  &lt;li&gt;AVD：Android Virtual Devices，模拟器&lt;/li&gt;
  &lt;li&gt;SDK：Software Development Kit，软件开发平台&lt;/li&gt;
  &lt;li&gt;ADT；Android Development Tools，Eclipse下Android开发时用到的插件&lt;/li&gt;
  &lt;li&gt;ADB：Android Debug Bridge，调试桥&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;产品设计几点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;允许用户登录情况下，使用app的大部分通用功能；&lt;/li&gt;
  &lt;li&gt;当且仅当用户要使用一些核心功能时，强制用户注册、登录；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://developer.android.com/index.html&quot;&gt;Android官方开发者网站&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://developer.android.com/develop/index.html&quot;&gt;Android官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>搭建Android开发环境</title>
     <link href="http://ningg.github.com/install-android-dev-env"/>
     <updated>2014-09-22T00:00:00+08:00</updated>
     <id>http://ningg.github.com/install-android-dev-env</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;哈哈，这个背景说不说呢？说，坦坦荡荡的：想做一个对Android手机的截屏图片，直接打马赛克的小APP，当前满足这一需求的APP有不少，例如：美图秀秀等，但是不好意思，我想要一个轻量级的，而且最简单的打码操作。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;搭建开发环境&lt;/h2&gt;

&lt;p&gt;打码APP，目标确定了，就开发搞起。&lt;em&gt;（具体功能是什么？技术方案定了吗？别急，这些我现在都不会、都不确定，个人估计折腾折腾就清晰的，我对这个还是有信心的）&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;特别提醒&lt;/strong&gt;：下面是我看官网的操作记录，请那些还有丁点技术追求的coder，也去看官网，我写blog不是为了布道，而且blog的精准、严谨程度，与官网差得太远。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;下载软件&lt;/h3&gt;

&lt;p&gt;图省事，我从官网直接下载了”Eclipse ADT bundle”，详细版本信息：”adt-bundle-windows-x86_64-20140702.zip”，其下载地址如下：&lt;a href=&quot;https://dl.google.com/android/adt/adt-bundle-windows-x86_64-20140702.zip&quot;&gt;https://dl.google.com/android/adt/adt-bundle-windows-x86_64-20140702.zip&lt;/a&gt; 。由于GFW的存在，很多地方无法直接下载上面链接文件，怎么办？用迅雷，复制上面的链接，新建一个迅雷下载任务，妥了，下载完毕。&lt;/p&gt;

&lt;p&gt;Eclipse ADT Bundle包含3个部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Android SDK&lt;/li&gt;
  &lt;li&gt;Eclipse IDE&lt;/li&gt;
  &lt;li&gt;ADT(Android Developer Tools)：Eclipse下进行Android开发的插件；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;客官，留意一下：上面Eclipse ADT Bundle对应的解压包中，自带了Android开发的文档，具体路径：&lt;code&gt;%ECLIPSE_ADT_BUNDLE%/sdk/docs/&lt;/code&gt;，这个极其有用，我有问题，都会偷偷看这个。&lt;/p&gt;

&lt;h3 id=&quot;package&quot;&gt;安装package&lt;/h3&gt;

&lt;p&gt;上面Eclipse ADT Bundle对应的解压包中eclipse直接可以使用了，不过很多时候，需要安装写package，来支持Android的开发。通常，通过Android SDK Manager来安装package，截个图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/install-android-dev-env/sdk-manager.jpg&quot; alt=&quot;Android SDK Manager&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装package，本来挺简单个事，由于GFW的存在，唉，上面的package基本无法下载，或者极其慢，解决办法：修改hosts文件，在其中添加片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Google主页
203.208.46.146 www.google.com
#这行是为了方便打开Android开发官网 现在好像不VPN也可以打开
#74.125.113.121 developer.android.com
#更新的内容从以下地址下载
203.208.46.146 dl.google.com
203.208.46.146 dl-ssl.google.com
****************************************
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考来源：&lt;a href=&quot;http://www.cnblogs.com/tc310/archive/2012/12/21/2828450.html&quot;&gt;http://www.cnblogs.com/tc310/archive/2012/12/21/2828450.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;推荐书籍&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/25942191/&quot;&gt;第一行代码——Android&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;这个入门不错，对于有开发经验的人员也可以借鉴一下&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>编译flume：使用eclipse查看flume源码</title>
     <link href="http://ningg.github.com/build-flume"/>
     <updated>2014-09-19T00:00:00+08:00</updated>
     <id>http://ningg.github.com/build-flume</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近要弄日志收集系统，初始方案是将日志压缩之后，通过类似FTP方式上传，其中有一个问题：日志不能实时收集，因此，无法实时监控系统状态。Flume支持实时的日志采集，妥了，尝试用一下。&lt;/p&gt;

&lt;p&gt;说点题外话，通过类似FTP方式上传文件时，还有几个问题，自己仍在思考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;日志上传时，如何确定日志上传完成？&lt;/li&gt;
  &lt;li&gt;如果上传过程中出现意外，接收端是否会丢弃已经接收到的文件片段？&lt;/li&gt;
  &lt;li&gt;传输的文件是否压缩？&lt;/li&gt;
  &lt;li&gt;传输文件直接上传到HDFS上，还是先上传到local FS上？&lt;/li&gt;
  &lt;li&gt;日志传输到服务器上之后，如何才能立即就进行分析？&lt;/li&gt;
  &lt;li&gt;分析日志之前，怎么判断日志是否满足规范？（命名、编码等）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;编译环境&lt;/h2&gt;

&lt;p&gt;查看自己机器的环境：我用笔记本来编译的，是win 7（x64）操作系统；更详细的编译环境信息通过如下方式查看：&lt;code&gt;CMD&lt;/code&gt;–&amp;gt;&lt;code&gt;systeminfo&lt;/code&gt;，这个命令收集系统信息，需要花费40s，稍等一会儿，得到如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\Users\Administrator&amp;gt;systeminfo

OS 名称:          Microsoft Windows 7 旗舰版
OS 版本:          6.1.7601 Service Pack 1 Build 7601

系统类型:         x64-based PC
处理器:           安装了 1 个处理器。
	 [01]: Intel64 Family 6 Model 23 Stepping 6 GenuineIntel ~785 Mhz

物理内存总量:     2,968 MB
可用的物理内存:   819 MB
虚拟内存: 最大值: 5,934 MB
虚拟内存: 可用:   2,196 MB
虚拟内存: 使用中: 3,738 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;开始编译&lt;/h2&gt;

&lt;p&gt;OK，在这台Win7上，编译flume源码，走起。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;特别说明：这些内容，都是我从官网看来的，建议有点追求的coder，多看看&lt;a href=&quot;http://flume.apache.org/&quot;&gt;flume官网&lt;/a&gt;，这样才能有提高，我的博客仅仅是自己留作备份看的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;下载源码&lt;/h3&gt;

&lt;p&gt;Apache flume的下载页面：&lt;a href=&quot;http://flume.apache.org/download.html&quot;&gt;Apache Flume Download&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我下载的是当前稳定版本flume对应的源码：&lt;a href=&quot;http://www.apache.org/dyn/closer.cgi/flume/1.5.0.1/apache-flume-1.5.0.1-src.tar.gz&quot;&gt;apache-flume-1.5.0.1-src&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;开始编译&lt;/h3&gt;

&lt;p&gt;根据官方资料：&lt;a href=&quot;https://cwiki.apache.org/confluence/display/FLUME/Development+Environment&quot;&gt;flume开发&amp;amp;调试环境&lt;/a&gt;，开始编译。此次编译，我的目标很简单：在eclipse下查看flume的源代码。具体编译时，使用的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mvn install -DskipTests
mvn eclipse:eclipse -DdownloadSources
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;出现的问题&lt;/h3&gt;

&lt;p&gt;执行命令&lt;code&gt;mvn install -DskipTests&lt;/code&gt;后，程序有一段时间静止在编译flume ng core的模块上，强行终止（操作：&lt;code&gt;ctrl + c&lt;/code&gt;）后，使用  “mvn install -rf :flume-ng-core -X “ 启动debug进行问题定位找到线索:&lt;/p&gt;

&lt;p&gt;分析之后，修改flume-ng-core\scripts\目录下&lt;code&gt;saveVersion.ps1&lt;/code&gt;，将其中powershell的两个参数&lt;code&gt;args[0]&lt;/code&gt;和&lt;code&gt;args[1]&lt;/code&gt;替换为实际值即可。在此之前，需要确认windows系统已经安装了powershell，验证是否安装powershell的方法：&lt;code&gt;运行&lt;/code&gt;–&amp;gt;&lt;code&gt;powershell&lt;/code&gt;，看看是否能够进入与&lt;code&gt;cmd&lt;/code&gt;类似的命令页面（我的win7系统默认带了powershell）。
如果没有安装powershell，请参考：&lt;a href=&quot;http://support.microsoft.com/kb/968929&quot;&gt;windows管理框架&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在编译&lt;code&gt;flume-ng-morphline-solr-sink&lt;/code&gt;过程中，由于GFW等等原因，可能无法访问&lt;code&gt; repository.cloudera.com&lt;/code&gt;，导致编译失败，失败信息详情如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ERROR] Failed to execute goal on project flume-ng-morphline-solr
-sink: Could not resolve dependencies for project org.apache.flum
e.flume-ng-sinks:flume-ng-morphline-solr-sink:jar:1.5.0.1: Failed
 to collect dependencies at org.kitesdk:kite-morphlines-all:pom:0
.12.0: Failed to read artifact descriptor for org.kitesdk:kite-mo
rphlines-all:pom:0.12.0: Could not transfer artifact org.kitesdk:
kite-morphlines-all:pom:0.12.0 from/to cdh.repo (https://reposito
ry.cloudera.com/artifactory/cloudera-repos): repository.cloudera.
com: Unknown host repository.cloudera.com -&amp;gt; [Help 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览一下，失败信息的大意是：编译&lt;code&gt;flume-ng-morphline-solr-sink&lt;/code&gt;过程中，寻找依赖(dependency)失败，这是由于远端cloudera仓库对应的域名&lt;code&gt;repository.cloudera.com&lt;/code&gt;无法解析引发的。OK，既然找不到这个cloudera仓库，那直接取消对这一仓库的引用好了，具体：修改flume-ng-sinks\flume-ng-morphline-solr-sink\目录下&lt;code&gt;pom.xml&lt;/code&gt;文件，将&lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt;元素注释掉，最终效果如表：&lt;/p&gt;

&lt;repositories&gt;

	&lt;!--
	&lt;repository&gt;
	  &lt;id&gt;cdh.repo&lt;/id&gt;
	  &lt;url&gt;https://repository.cloudera.com/artifactory/cloudera-repos&lt;/url&gt;
	  &lt;name&gt;Cloudera Repositories&lt;/name&gt;
	  &lt;snapshots&gt;
		&lt;enabled&gt;false&lt;/enabled&gt;
	  &lt;/snapshots&gt;
	&lt;/repository&gt;

	&lt;repository&gt;
	  &lt;id&gt;cdh.snapshots.repo&lt;/id&gt;
	  &lt;url&gt;https://repository.cloudera.com/artifactory/libs-snapshot-local&lt;/url&gt;
	  &lt;name&gt;Cloudera Snapshots Repository&lt;/name&gt;
	  &lt;snapshots&gt;
		&lt;enabled&gt;true&lt;/enabled&gt;
	  &lt;/snapshots&gt;
	  &lt;releases&gt;
		&lt;enabled&gt;false&lt;/enabled&gt;
	  &lt;/releases&gt;
	&lt;/repository&gt;
	--&gt;

  &lt;/repositories&gt;

&lt;p&gt;ok，重新执行命令&lt;code&gt;mvn install -DskipTests&lt;/code&gt;，欧NO，又出错了，得到如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ERROR] Failed to execute goal on project flume-ng-morphline-solr
-sink: Could not resolve dependencies for project org.apache.flum
e.flume-ng-sinks:flume-ng-morphline-solr-sink:jar:1.5.0.1: The fo
-llowing artifacts could not be resolved: org.kitesdk:kite-morphli
nes-all:pom:0.12.0, org.kitesdk:kite-morphlines-solr-core:jar:tes
-ts:0.12.0: Failure to find org.kitesdk:kite-morphlines-all:pom:0.
12.0 in http://repo1.maven.org/maven2 was cached in the local repo
-sitory, resolution will not be reattempted until the update inte
rval of repo1.maven.org has elapsed or updates are forced -&amp;gt; [Help 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;平复一下心情，看看上面的提示，大意是说找不到&lt;code&gt;kite-morphlines-all&lt;/code&gt;，看来之前粗鲁的将&lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt;元素注释掉，并不能解决问题，OK，再找两个替代的repository就好了，具体再次修改flume-ng-sinks\flume-ng-morphline-solr-sink\目录下&lt;code&gt;pom.xml&lt;/code&gt;文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;repositories&amp;gt;
	&amp;lt;repository&amp;gt;
		&amp;lt;id&amp;gt;maven-restlet&amp;lt;/id&amp;gt;
		&amp;lt;name&amp;gt;Public online Restlet repository&amp;lt;/name&amp;gt;
		&amp;lt;url&amp;gt;http://maven.restlet.org&amp;lt;/url&amp;gt;
	&amp;lt;/repository&amp;gt;
  &amp;lt;/repositories&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且修改flume源代码根目录下的&lt;code&gt;pom.xml&lt;/code&gt;文件，将其中&lt;code&gt;&amp;lt;kite.version&amp;gt;0.12.0&amp;lt;/kite.version&amp;gt;&lt;/code&gt;，修改为&lt;code&gt;&amp;lt;kite.version&amp;gt;0.15.0&amp;lt;/kite.version&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;又有依赖(dependency)找不到了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ERROR] Failed to execute goal on project flume-ng-morphline-solr
-sink: Could not resolve dependencies for project org.apache.flum
e.flume-ng-sinks:flume-ng-morphline-solr-sink:jar:1.5.0.1: Failed
 to collect dependencies at org.kitesdk:kite-morphlines-all:pom:0
.12.0 -&amp;gt; org.kitesdk:kite-morphlines-useragent:jar:0.12.0 -&amp;gt; ua_p
arser:ua-parser:jar:1.3.0: Failed to read artifact descriptor for
 ua_parser:ua-parser:jar:1.3.0: Could not transfer artifact ua_pa
rser:ua-parser:pom:1.3.0 from/to maven-twttr (http://maven.twttr.
com): Connection to http://maven.twttr.com refused: Connection ti
med out: connect -&amp;gt; [Help 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次修改flume-ng-sinks\flume-ng-morphline-solr-sink\目录下&lt;code&gt;pom.xml&lt;/code&gt;文件，在&lt;code&gt;&amp;lt;repositories&amp;gt;&lt;/code&gt;下添加一个元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;repositories&amp;gt;
	
	... 
	
	&amp;lt;repository&amp;gt;
	  &amp;lt;id&amp;gt;p2.jfrog.org&amp;lt;/id&amp;gt;
	  &amp;lt;url&amp;gt;http://p2.jfrog.org/libs-releases&amp;lt;/url&amp;gt;
	&amp;lt;/repository&amp;gt;
&amp;lt;/repositories&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新编译，还不行，说是找不到&lt;code&gt;p2.jfrog.org&lt;/code&gt;，怒了，翻墙，再编译，搞定。（有的网络环境，不需要翻墙，也能编译通过）&lt;/p&gt;

&lt;h3 id=&quot;eclipse&quot;&gt;eclipse下查看源码&lt;/h3&gt;

&lt;p&gt;上面编译之后，在eclipse下，&lt;code&gt;Import&lt;/code&gt;–&amp;gt;&lt;code&gt;Existing Projects into Workspace&lt;/code&gt;，然后选择flume编译源码的路径即可，结果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/build-flume/eclipse-flume-src.jpg&quot; alt=&quot;eclipse-src&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;疑问&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用maven管理的代码，为什么不作为maven项目Import到eclipse下？而是先运行命令&lt;code&gt;mvn eclipse:eclipse&lt;/code&gt;，然后将项目作为普通的java project导入到eclipse？&lt;/li&gt;
  &lt;li&gt;使用eclipse来查看、调试flume源码，那如何对外发布源码？&lt;/li&gt;
  &lt;li&gt;总结一下，就是一个问题&lt;code&gt;mvn eclipse:eclipse&lt;/code&gt;过程中到底执行了什么？为什么要这么做？&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;后记&lt;/strong&gt;：每次编译代码，网络都让人蛋疼，GFW让人蛋疼，有一个VPN太重要了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-6&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://flume.apache.org/&quot;&gt;flume官网&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/FLUME/Development+Environment&quot;&gt;flume开发&amp;amp;调试环境&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>wordpress的开发调试环境</title>
     <link href="http://ningg.github.com/wordpress-debug-env"/>
     <updated>2014-09-05T00:00:00+08:00</updated>
     <id>http://ningg.github.com/wordpress-debug-env</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;用wordpress建站，两个功能：一个是展示团队工作，另一个是方便其他人进来讨论。&lt;/p&gt;

&lt;p&gt;初步立意：使用wordpress搭建两个网站，团队工作展示一个，讨论区一个；&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;组件与安装&lt;/h2&gt;

&lt;p&gt;环境：Win 7，已经安装了JDK 6 和 JDK 7&lt;/p&gt;

&lt;p&gt;下载软件清单如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;下载XAMPP：&lt;a href=&quot;https://www.apachefriends.org/zh_cn/index.html&quot;&gt;https://www.apachefriends.org/zh_cn/index.html&lt;/a&gt; 版本：1.8.3；对应PHP: 5.5.1&lt;/li&gt;
  &lt;li&gt;下载eclipse for php：&lt;a href=&quot;http://www.eclipse.org/downloads/&quot;&gt;http://www.eclipse.org/downloads/&lt;/a&gt;  版本：eclipse-php-luna-R-win32-x86_64&lt;/li&gt;
  &lt;li&gt;下载wordpress：&lt;a href=&quot;http://cn.wordpress.org/&quot;&gt;http://cn.wordpress.org/&lt;/a&gt; 版本：3.9&lt;/li&gt;
  &lt;li&gt;下载主题：
    &lt;ol&gt;
      &lt;li&gt;hum：&lt;a href=&quot;http://wordpress.org/extend/themes/hum/&quot;&gt;http://wordpress.org/extend/themes/hum/&lt;/a&gt; 版本：0.2.1&lt;/li&gt;
      &lt;li&gt;twenty eleven：&lt;a href=&quot;http://wordpress.org/themes/twentyeleven&quot;&gt;http://wordpress.org/themes/twentyeleven&lt;/a&gt; 版本：1.9&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;下载JDK：&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/index.html&quot;&gt;Oracle JDK(Sun)&lt;/a&gt; 版本：JDK 7u67&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;依次安装：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;XAMPP：wordpress的运行环境&lt;/li&gt;
  &lt;li&gt;wordpress，并为其配置主题：
    &lt;ul&gt;
      &lt;li&gt;twenty eleven&lt;/li&gt;
      &lt;li&gt;hum&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;eclipse：将整个wordpress文件夹，新建为PHP Project；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;配置&lt;/h2&gt;

&lt;p&gt;设计搭建其调试环境所需要的基本配置。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;基本配置&lt;/h3&gt;

&lt;p&gt;主要是Apache、MySQL、PHP相关：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设置MySQL的root密码，两种方式都可以：
    &lt;ol&gt;
      &lt;li&gt;CMD的命令行；&lt;/li&gt;
      &lt;li&gt;myphpAdmin图形界面；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;主题配置&lt;/h3&gt;

&lt;p&gt;主要是为成功安装主题，所需要进行的配置。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;wordpress
    &lt;ol&gt;
      &lt;li&gt;取消twenty eleven主题中google front（因为google被墙了）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;调试&lt;/h2&gt;

&lt;p&gt;调试是学习一个框架/语言较快的方式，这一部分将着重介绍如何进行调试。关注几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如何进行调试；&lt;/li&gt;
  &lt;li&gt;PHP web基本处理逻辑；&lt;/li&gt;
  &lt;li&gt;wordpress中使用了哪些巧妙的设计，使其流行数年；&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>PHP入门知识</title>
     <link href="http://ningg.github.com/php-intro"/>
     <updated>2014-08-31T00:00:00+08:00</updated>
     <id>http://ningg.github.com/php-intro</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近要快速搭建一个网站，用途：实现团队内容的对外展现，第一反应就是用wordpress框架实现，号称5分钟建站，够快了。问题来了：网站要实现一些特定的效果，这个就需要定制一下了，wordpress后端是PHP写的处理逻辑，OK，熟悉一下PHP。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;学习路线&lt;/h2&gt;

&lt;p&gt;自己之前接触过1个多月的PHP，当时的内容就是搭建web站点；针对一门不熟悉的语言，只需要掌握其基本知识即可开始工作，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义变量；&lt;/li&gt;
  &lt;li&gt;不同数据结构对应的变量；（链表、集合）&lt;/li&gt;
  &lt;li&gt;多个文件之间的组织结构；&lt;/li&gt;
  &lt;li&gt;调试程序；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;变量&lt;/h2&gt;

&lt;p&gt;变量，就是存储数据的容器，对变量进行操作就是处理数据；&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;定义变量&lt;/h3&gt;

&lt;p&gt;变量名，几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量名必须以&lt;code&gt;$&lt;/code&gt;开头；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;$&lt;/code&gt;之后，第一个字符必须为字母、下划线&lt;code&gt;_&lt;/code&gt;，不能为数字；&lt;/li&gt;
  &lt;li&gt;变量名剩余部分，可以包含任意字母、数字、下划线；&lt;/li&gt;
  &lt;li&gt;变量名，区分大小写；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于变量名，建议：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量名，全部小写字母；&lt;/li&gt;
  &lt;li&gt;变量名，表示其含义，举例：&lt;code&gt;$first_name&lt;/code&gt;好于&lt;code&gt;$fn&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;注释变量用途，例：$first_name = ‘Guo’; //the first name&lt;/li&gt;
  &lt;li&gt;保持一致命名模式，如果要大写，就全部大写；举例：预定义变量&lt;code&gt;$_SERVER&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;变量定义，几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PHP是脚本语言，不要求必须先定义变量或者初始化变量；但为了规范开发、减少出错，建议先定义变量后使用；&lt;/li&gt;
  &lt;li&gt;在定义时，对变量用途进行注释；&lt;/li&gt;
  &lt;li&gt;变量命名风格，有两种：驼峰式（&lt;code&gt;$FirstName&lt;/code&gt;）和下划线式（&lt;code&gt;$first_name&lt;/code&gt;），建议下划线式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;变量类型&lt;/h3&gt;

&lt;p&gt;这一部分，将介绍3种变量类型：数值型、字符串型和数组；&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数值
    &lt;ol&gt;
      &lt;li&gt;整数：1、-1；&lt;/li&gt;
      &lt;li&gt;浮点数：1.0、2.2；&lt;/li&gt;
      &lt;li&gt;注：&lt;code&gt;1/3&lt;/code&gt;包含&lt;code&gt;/&lt;/code&gt;是错误表示；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;字符串
    &lt;ol&gt;
      &lt;li&gt;单引号&lt;code&gt;&#39;&lt;/code&gt;、双引号&lt;code&gt;“&lt;/code&gt;包含起来的任意符号；&lt;/li&gt;
      &lt;li&gt;可以包含变量，例：&lt;code&gt;&#39;$field_name&#39;&lt;/code&gt;；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;数组
    &lt;ol&gt;
      &lt;li&gt;基本单元：key-value；&lt;/li&gt;
      &lt;li&gt;key不同，数组分为两类：索引数组（key为数值）、关联数组（key为字符串）；&lt;/li&gt;
      &lt;li&gt;数组的key，又称索引；&lt;/li&gt;
      &lt;li&gt;如果数组的value也是数组，则，为多维数组；&lt;/li&gt;
      &lt;li&gt;PHP中关联数组，在Perl和Ruby中称为散列；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;索引数组如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;key&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;value&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Don&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Jane&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Roger&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;关联数组如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;key&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;value&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;D&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Don&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;J&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Jane&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Roger&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-5&quot;&gt;变量赋值&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;普通变量（数值、字符串）
    &lt;ol&gt;
      &lt;li&gt;等号赋值，例： $number = 1;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;数组
    &lt;ol&gt;
      &lt;li&gt;使用array()函数，例：$list = array();&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;使用变量&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;直接输出变量
    &lt;ul&gt;
      &lt;li&gt;echo $number;&lt;/li&gt;
      &lt;li&gt;print $number;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;上下文中输出变量
    &lt;ul&gt;
      &lt;li&gt;echo “number is $number”;&lt;/li&gt;
      &lt;li&gt;注：上述不能使用单引号&lt;code&gt;‘&lt;/code&gt;，下文会提到；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数组
    &lt;ul&gt;
      &lt;li&gt;print_r “$_SERVER”;&lt;/li&gt;
      &lt;li&gt;注：print “$_SERVER”; 结果是：&lt;code&gt;Array&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;数组是非标量类型，还有其他输出方式；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;特别说明&lt;/strong&gt;：打印出变量内容，是调试脚本的重要方法。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;引号说明&lt;/h3&gt;

&lt;p&gt;这个比较重要，单拎出来说一下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;单引号&lt;code&gt;‘&lt;/code&gt;内容，原样输出；双引号&lt;code&gt;”&lt;/code&gt;内容，进行变量带入；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;针对引号，几点注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;坚持使用双引号&lt;code&gt;&quot;&lt;/code&gt;即可解决大部分问题；&lt;/li&gt;
  &lt;li&gt;当输出&lt;code&gt;\n&lt;/code&gt;、&lt;code&gt;\t&lt;/code&gt;时，需要使用双引号&lt;code&gt;&quot;&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;建议输出所有变量时，都使用双引号&lt;code&gt;&quot;&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;预定义变量&lt;/h3&gt;

&lt;p&gt;PHP中已经预先定义了一些变量，这些变量功能强大，需要熟记。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$_POST，数组，捕获POST方式表单数据；
    &lt;ol&gt;
      &lt;li&gt;使用键访问数组元素：&lt;code&gt;print $_POST[&#39;name_value&#39;]&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;严格区分大小写，并且以&lt;code&gt;$_&lt;/code&gt;开头，全部大写；&lt;/li&gt;
      &lt;li&gt;双引号内部，不能使用数组的单引号来引用key；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对上面 3. 中提到的情况，说明如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 下面输出会出错
print &quot;Thank U : $_POST[&#39;name&#39;]&quot;;

// 可选解决办法（先取出，后使用）
$input_name_value = $_POST[&#39;name&#39;];
print &quot;Thank U : $input_name_value&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;疑问：能使用双引号，即 &lt;code&gt;$_POST[&quot;name&quot;]&lt;/code&gt; 样式，来获取数组中内容吗？当然可以，单引号能做，双引号也能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$_GET，捕获GET方式表单数据，与$_POST类似；&lt;/li&gt;
  &lt;li&gt;$_REQUEST，捕获任意方式提交的数据；(不推荐)&lt;/li&gt;
  &lt;li&gt;$_COOKIE，设置和查询当前cookie中信息；&lt;/li&gt;
  &lt;li&gt;$_SERVER，服务器和执行环境信息；
    &lt;ol&gt;
      &lt;li&gt;‘PHP_SELF’：当前执行脚本的文件名，与document root有关，例如：&lt;code&gt;/test.php/foo.bar&lt;/code&gt;，具体看PHP手册；&lt;/li&gt;
      &lt;li&gt;‘REQUEST_METHOD’：访问页面的请求方法，例如：GET、POST、PUT；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-9&quot;&gt;数组&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;操作数组&lt;/strong&gt;：array()函数创建数组：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$list = array (&#39;appales&#39;, &#39;bananas&#39;, &#39;oranges&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认，数组的索引从0开始；当然有办法从1开始，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$list = array(
	1 =&amp;gt; &#39;apples&#39;,
	2 =&amp;gt; &#39;bananas&#39;,
	3 =&amp;gt; &#39;oranges&#39;
);

//key值也可以为字符串
$list = array(
	&#39;Mon&#39; =&amp;gt; &#39;apples&#39;,
	&#39;Tue&#39; =&amp;gt; &#39;bananas&#39;,
	&#39;Wed&#39; =&amp;gt; &#39;oranges&#39;
);

//range () 函数创建数组
$evens = range (0, 100, 2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于数组的常用操作，小结如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建数组
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;$list = array ()&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;evens = array ()&lt;/code&gt;;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;输出数组
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;print_r()&lt;/code&gt;函数&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;var_dump()&lt;/code&gt;函数&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;foreach()&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;引用元素
    &lt;ol&gt;
      &lt;li&gt;只能通过key的引用来获取；&lt;/li&gt;
      &lt;li&gt;key区分大小写；&lt;/li&gt;
      &lt;li&gt;key是字符串的，通过$list[1]无法访问任何元素；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;追加元素
    &lt;ol&gt;
      &lt;li&gt;数值索引时：	&lt;code&gt;$list[] = &#39;pears&#39;&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;字符串索引：必须指定key；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;修改元素
    &lt;ol&gt;
      &lt;li&gt;数值索引：&lt;code&gt;$list[2] = &#39;pears&#39;&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;字符串索引：&lt;code&gt;$list[&#39;Wed&#39;] = &#39;pears&#39;&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;字符串索引时，不能使用数值；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;元素个数
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;$how_many = count($array)&lt;/code&gt;;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;删除元素
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;unset($list[1])&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;unset($list[&#39;Wed&#39;])&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;unset($list)&lt;/code&gt;;//删除整个数组&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;$list = array()&lt;/code&gt;;//等价于删除数组&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;合并数组
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;array_merge($list1， $list2)&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;$list = $list1 + $list2&lt;/code&gt;;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;数组排序：会单独列张表
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;sort($array)&lt;/code&gt;、&lt;code&gt;rsort()&lt;/code&gt;；&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;asort()&lt;/code&gt;、&lt;code&gt;arsort()&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;ksort()&lt;/code&gt;、&lt;code&gt;krsort()&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;shuffle()&lt;/code&gt;：数组元素顺序随机重组；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;字符串与数组间相互转换
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;implode()&lt;/code&gt;：数组转换为字符串；&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;explode()&lt;/code&gt;：字符串转换为数组；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;判断是否为数组
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;is_array($array)&lt;/code&gt;;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;额外几个函数
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;array_key_exists()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;array_search()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;in_array()&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数组使用过程总结如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 $list 不存在，&lt;code&gt;$list[] = &#39;value&#39;&lt;/code&gt;，会去创建数组；&lt;/li&gt;
  &lt;li&gt;数组中使用单引号 &lt;code&gt;&#39;&lt;/code&gt; 来引用 key 和 value，也可以使用双引号&lt;code&gt;&quot;&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;sizeof()&lt;/code&gt; 函数是 &lt;code&gt;count()&lt;/code&gt; 的别名，返回数组的元素个数；&lt;/li&gt;
  &lt;li&gt;当key为数值、变量、常数时，不用引号引用，即可调用；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特别要说的是foreach遍历数组，举例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//同时，使用key 和value
foreach($array as $key =&amp;gt; $value) {
	print &quot;&amp;lt;p&amp;gt;Key is $key. Value is $value. &amp;lt;/p&amp;gt;&quot;;
}

//只使用value
foreach($array as $value){
	print &quot;&amp;lt;p&amp;gt;Value is $value.&amp;lt;/p&amp;gt;&quot;;
}

//对于数值索引数组
for($n = 0; $n &amp;lt; count($array); $n++){
	print &quot;&amp;lt;p&amp;gt;Value is $array[$n].&amp;lt;/p&amp;gt;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;备注：上述&lt;code&gt;$key =&amp;gt; $value&lt;/code&gt;，可以替换为&lt;code&gt;$k =&amp;gt; $v&lt;/code&gt;等类似形式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多维数组&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$fruits = array (
	1 =&amp;gt; &#39;apples&#39;,
	2 =&amp;gt; &#39;bananas&#39;,
	3 =&amp;gt; &#39;oranges&#39;
);

$meats =array (
	&#39;fruits&#39; =&amp;gt; $fruits,
	&#39;other&#39; =&amp;gt; &#39;peanuts&#39;,
	&#39;cash&#39; =&amp;gt; 30.00
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数组排序，常用函数如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数&lt;/th&gt;
      &lt;th&gt;排序依据&lt;/th&gt;
      &lt;th&gt;是否保持key-value对应关系&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;sort()&lt;/td&gt;
      &lt;td&gt;Values&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rsort()&lt;/td&gt;
      &lt;td&gt;Values&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;asort()&lt;/td&gt;
      &lt;td&gt;Values&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;arsort()&lt;/td&gt;
      &lt;td&gt;Values&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ksort()&lt;/td&gt;
      &lt;td&gt;Keys&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;krsort()&lt;/td&gt;
      &lt;td&gt;Keys&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;natsort()&lt;/td&gt;
      &lt;td&gt;Keys，自然顺序&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;natcasesort()&lt;/td&gt;
      &lt;td&gt;Keys&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;字符串与数组之间转换，通常如下原因：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数组-&amp;gt;字符串，为了在URL中传输数组；&lt;/li&gt;
  &lt;li&gt;数组-&amp;gt;字符串，方便将数组存储到数据库；&lt;/li&gt;
  &lt;li&gt;字符串-&amp;gt;数组，逗号分割的文本，转化为相互独立形式；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数组与字符串间转换实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 将array以&#39;,&#39;为分割，转换为字符串
$string = implode(&#39;,&#39;, $array);

//将string以&#39;,&#39;为分割，转换为数组
$array = explode(&#39;,&#39;, $string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将数组中元素分别指定给不同变量，使用 list() 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$date = array(&#39;Thursday&#39;, 23, &#39;October&#39;);
//为3个变量赋值
list($weekday, $day, $month) = $date;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实践：查看PHP手册中的几个函数，&lt;code&gt;array_key_exists()&lt;/code&gt;、&lt;code&gt;array_search()&lt;/code&gt;、&lt;code&gt;in_array()&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;常量&lt;/h2&gt;

&lt;p&gt;与变量不同，常量在脚本的执行过程中，一直保持初始值；常量一旦设定就不能更改。&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;定义常量&lt;/h3&gt;

&lt;p&gt;使用define()函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(&#39;CONSTANT_NAME&#39;, value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;常量名，以字母、下划线开头，全部大写；&lt;/li&gt;
  &lt;li&gt;常量名，不需要以&lt;code&gt;$&lt;/code&gt;开头；&lt;/li&gt;
  &lt;li&gt;定义常量，define()中常量名，使用引号；&lt;/li&gt;
  &lt;li&gt;输出常量，直接使用常量名即可；&lt;/li&gt;
  &lt;li&gt;引号内部（单引号、双引号）无法输出常量；&lt;/li&gt;
  &lt;li&gt;判断是否定义常量：&lt;code&gt;defined(&#39;CONSTANT_NAME&#39;)&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;常量是全局作用域的；&lt;/li&gt;
  &lt;li&gt;常量的值不能修改，常量本身也不能修改；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-12&quot;&gt;预定义常量&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;PHP_VERSION：正在运行的PHP版本&lt;/li&gt;
  &lt;li&gt;PHP_OS：服务器操作系统&lt;/li&gt;
  &lt;li&gt;SID：session ID&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-13&quot;&gt;运算符&lt;/h2&gt;

&lt;p&gt;PHP中运算符，参考下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;运算符&lt;/th&gt;
      &lt;th&gt;用法&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;加&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;减&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;乘&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;/&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;除&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;取模&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;++&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;自增&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;自减&lt;/td&gt;
      &lt;td&gt;算数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;赋值&lt;/td&gt;
      &lt;td&gt;赋值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;==&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;相等&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;不等&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;小于&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;大于&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;小于等于&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;大于等于&lt;/td&gt;
      &lt;td&gt;比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;!&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;非&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;AND&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;与&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;与&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;OR&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;或&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;||&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;或&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;XOR&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;异或&lt;/td&gt;
      &lt;td&gt;逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;.&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;连接&lt;/td&gt;
      &lt;td&gt;字符串&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-14&quot;&gt;函数&lt;/h2&gt;

&lt;p&gt;特别说明：PHP中函数名与&lt;code&gt;()&lt;/code&gt;之间可以有空格，即，如下两种方式都正确：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;round(100.2);
round (100.2);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-15&quot;&gt;数值格式化&lt;/h3&gt;

&lt;p&gt;round()，进行数值四舍五入，具体参阅[PHP Manual]，举例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
	round(3.4);			//3
	round(4.12, 1);		//4.1
	round(1221, -2);	//1200
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似函数还有：&lt;code&gt;number_format()&lt;/code&gt;、&lt;code&gt;printf()&lt;/code&gt;、&lt;code&gt;sprintf()&lt;/code&gt;；&lt;/p&gt;

&lt;h3 id=&quot;section-16&quot;&gt;随机数&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;rand()&lt;/code&gt;、&lt;code&gt;mt_rand()&lt;/code&gt;，具体不多说，查看操作手册即可；&lt;/p&gt;

&lt;h3 id=&quot;section-17&quot;&gt;字符串连接&lt;/h3&gt;

&lt;p&gt;字符串连接：句点&lt;code&gt;.&lt;/code&gt;，举例：&lt;code&gt;$result = $first_name . $last_name&lt;/code&gt;;&lt;/p&gt;

&lt;h3 id=&quot;html&quot;&gt;转换HTML格式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;nl2br($string);		//将$string内的\n转换为&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;htmlsprcialchars();	//将特定的HTML标签转换为实体版本&lt;/li&gt;
  &lt;li&gt;htmlentities();		//将所有的HTML标签转换为实体版本&lt;/li&gt;
  &lt;li&gt;strip_tags();		//移除所有HTML和PHP标签&lt;/li&gt;
  &lt;li&gt;html_entity_decode();	//将HTML实体转换为相应HTML代码&lt;/li&gt;
  &lt;li&gt;wordwrap();			//按照指定长度，换行处理字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几个问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTML实体是什么？例如：&lt;code&gt;&amp;lt;&lt;/code&gt; 对应HTML实体为 &lt;code&gt;&amp;amp;lt;&lt;/code&gt; ；使用HTML实体主要原因：防止输入文本中包含HTML标签，打乱整个页面的布局，更近一步，防止用户提交JS进行跨站点攻击（XSS，Cross-Site Scripting）。补充：XSS 能够做的事情：破环网站风格、功能；盗取浏览用户的session信息。&lt;/li&gt;
  &lt;li&gt;通常先移除所有HTML、PHP标签，再将&lt;code&gt;\n&lt;/code&gt;等转义符，转换为HTML换行符，即：&lt;code&gt;strip_tags()&lt;/code&gt; 之后 &lt;code&gt;nl2br()&lt;/code&gt; ;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-18&quot;&gt;字符串编/解码&lt;/h3&gt;

&lt;p&gt;背景：通过URL的query向服务器发送参数时，要求参数不能包含空格、特殊字符等；如果一定要使用URL的query向服务器传送数据，可以先对数据进行编码，即可解决此问题。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;urlencode()&lt;/code&gt;，专门解决这一问题，将字符串转换为适合最为URL的一部分来传输。几点说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;表单发送出去的数据，会自动进行URL编码，在服务器端，会自动解码，因此，本例中，只需要在页面上通过 &lt;code&gt;urlencode()&lt;/code&gt; 编码即可，服务器能够自动解码；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;urldecode()&lt;/code&gt;，能够进行解码，但不常用，因为服务器能够自动解码；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-19&quot;&gt;子字符串&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;strtok($string, $token)&lt;/code&gt;，按照$token来分割$string，并返回最新的子串；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;substring($string, 0, 10)&lt;/code&gt;，从$string中索引为0的字符开始（包含在内），累计截取10个字符；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;substring($string, -3, 3)&lt;/code&gt;，从$string中倒数第3个字符开始（包含在内），累计截取3个字符；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;strlen($string)&lt;/code&gt;，字符串中字符个数；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;str_word_count()&lt;/code&gt;，字符串中单词个数；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;str_ireplace($needle, $replacement, $haystack)&lt;/code&gt;，将$haystack中$needle替换为$replacement；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;str_replace()&lt;/code&gt;，区分大小写，其余与str_ireplace()类似；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;trim()&lt;/code&gt;，删除字符串首尾的空格、换行符、制表符；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;rtrim()&lt;/code&gt;，删除最右端的空白字符；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ltrim()&lt;/code&gt;，删除最左端的空白字符；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;strtoupper()&lt;/code&gt;，字符串转换为大写；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;strtolower()&lt;/code&gt;，字符串转换为小写；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;substr_count($string, $substr)&lt;/code&gt;，子字符串出现的次数；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PHP中所有索引的位置都是从0开始的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$evens = range (0, 100, 2); 创建等差数列；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-20&quot;&gt;日期和时间&lt;/h3&gt;

&lt;p&gt;说几个函数，有点印象就行，具体用法去查PHP手册：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;date()&lt;/code&gt; 返回某一日期格式；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;date()&lt;/code&gt; 中第二参数为时间戳（timestamp），是表示从1970年1月1日算起的秒数；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;time()&lt;/code&gt; 返回当前时间戳；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;mktime()&lt;/code&gt; 返回一个给定日期和时间对应的时间戳；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;date_default_timezone_set()&lt;/code&gt; 设置时间默认的时区；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;date_default_timezone_get()&lt;/code&gt; 获取当前时间对应的时区；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;额外说明几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PHP是服务器端的技术，函数反映的是服务器上的时间，如果要获取客户端的时间，需要使用JavaScript；&lt;/li&gt;
  &lt;li&gt;PHP 5.3中，加入一个创建、操作日期和时间的类：DateTime类；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-21&quot;&gt;创建函数&lt;/h3&gt;

&lt;p&gt;一个典型函数的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//设置参数默认值
function function_name($arg1 = &#39;world&#39;, $arg2){
	statements;
	//函数的返回值（返回多个值：数组）
	return $name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;函数名，不区分大小写；&lt;/li&gt;
  &lt;li&gt;函数function_exists(function_name)，用于判断一个函数是否存在；&lt;/li&gt;
  &lt;li&gt;PHP中不要求：函数在调用之前就定义好，但，推荐在脚本开头就定义好函数；（放在引入文件中）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-22&quot;&gt;变量作用域&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;通常，变量作用域：整个脚本的声明周期中；&lt;/li&gt;
  &lt;li&gt;函数中传参数时，传递变量值，而不传递变量本身；&lt;/li&gt;
  &lt;li&gt;函数内部定义的变量，为局部变量；&lt;/li&gt;
  &lt;li&gt;global可以将函数内局部变量设置为全局变量；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-23&quot;&gt;控制结构&lt;/h2&gt;

&lt;p&gt;几点注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;{&lt;/code&gt;、&lt;code&gt;}&lt;/code&gt;的前后，不能出现&lt;code&gt;;&lt;/code&gt;，否则报错；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几个验证函数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;empty()&lt;/code&gt;，除去变量未定义、值为0、空字符串外，返回FALSE;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;isset()&lt;/code&gt;，仅当变量未定义时，返回False；（能够接受任意个数的变量）&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;is_numeric()&lt;/code&gt;，仅当变量为数值时，返回TRUE;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;checkdate()&lt;/code&gt;，验证日期是否存在；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;is_array()&lt;/code&gt;，判断是否数组；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$var1 = 0;
$var2 = &quot;&quot;;
$var3 = &quot;HELLO!&quot;

empty($var);	//TRUE，没有定义的变量
empty($var1);	//TRUE，空值
empty($var2);	//TRUE，空值
empty($var3);	//FALSE，非空（这个是这样吗？）

isset($var);	//FALSE，变量未定义
isset($var1);	//TRUE
isset($var2);	//TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;if&quot;&gt;if条件语句&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if (condition1) {
	statement(s);
} elseif (condition2) {
	statement(s);
} else {
	statements(s);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;switch&quot;&gt;switch条件语句&lt;/h3&gt;

&lt;p&gt;switch($var)，变量$var，可以为字符串、数值，在case后的value，如果是数值，则不需要加引号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;switch ($var) {
	case value1:
		statements1;
		break;
	case value2:
		statements2;
		break;
	default:
		statements3;
		break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-24&quot;&gt;循环语句&lt;/h3&gt;

&lt;p&gt;主要是for、while，以及foreach，不多说，给个示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(condition) {
	statement(s);
}

do {
	statement(s);
} while (condition);

for (init_exp; condition ; closing_exp){
	statement(s);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-25&quot;&gt;调试程序&lt;/h2&gt;

&lt;p&gt;调试程序有2种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;输出变量和错误信息；&lt;/li&gt;
  &lt;li&gt;用IDE，打断点，debug；&lt;/li&gt;
  &lt;li&gt;查看程序运行日志，特别是出错日志；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-26&quot;&gt;输出变量&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;echo “$var”;&lt;/li&gt;
  &lt;li&gt;print “$var”;&lt;/li&gt;
  &lt;li&gt;print_r “$_SERVER”;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-27&quot;&gt;输出错误信息&lt;/h3&gt;

&lt;p&gt;安装PHP之后，默认安全配置下，是不允许向Web端输出任何出错信息的，即，&lt;code&gt;display_errors&lt;/code&gt; 出于关闭状态；为了方便调试，有两种方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开启 &lt;code&gt;display_errors&lt;/code&gt; 设置；&lt;/li&gt;
  &lt;li&gt;为某些脚本单独开启 &lt;code&gt;display_errors&lt;/code&gt; 设置；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当前首选第一个选项，但是只有root用户才有如此权限；普通用户，可以在php页面中添加代码：&lt;code&gt;ini_set(&#39;display_errors&#39;, 1);&lt;/code&gt; 实现为某些脚本开启 &lt;code&gt;display_errors&lt;/code&gt; 。说明：这种方式进行的设置，只在当前php脚本执行期间有效，脚本结束后恢复原始设置；&lt;code&gt;display_errors&lt;/code&gt; 只能控制是否向浏览器发送错误信息，而不会控制错误的发生。&lt;/p&gt;

&lt;h3 id=&quot;section-28&quot;&gt;输出错误信息级别&lt;/h3&gt;

&lt;p&gt;通过设置display_errors可以实现输出错误信息，但是要输出哪一类的错误信息呢？警告信息要不要输出？&lt;/p&gt;

&lt;p&gt;PHP中错误的类型，见下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;示例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;通知&lt;/td&gt;
      &lt;td&gt;非致命性错误，程序不一定有问题&lt;/td&gt;
      &lt;td&gt;引用一个没有值的变量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;警告&lt;/td&gt;
      &lt;td&gt;非致命错误，程序有问题&lt;/td&gt;
      &lt;td&gt;函数误用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;解析错误&lt;/td&gt;
      &lt;td&gt;致命错误，语法错误&lt;/td&gt;
      &lt;td&gt;缺少分好、引号、圆括号、花括号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;错误&lt;/td&gt;
      &lt;td&gt;致命错误，一般错误&lt;/td&gt;
      &lt;td&gt;内存分配问题&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;错误报告常量（不完整，完整版查看[PHP Manual]），见下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;E_NOTICE&lt;/td&gt;
      &lt;td&gt;通知&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E_WARRING&lt;/td&gt;
      &lt;td&gt;警告&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E_PARSE&lt;/td&gt;
      &lt;td&gt;解析错误&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E_ERROR&lt;/td&gt;
      &lt;td&gt;错误&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E_ALL&lt;/td&gt;
      &lt;td&gt;所有错误（E_STRICT除外）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E_STRICT&lt;/td&gt;
      &lt;td&gt;PHP代码修改建议&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;注：上面的常量，是二进制位掩码，可以使用按位运算符来对其进行组合，例如，php.ini中，&lt;code&gt;|&lt;/code&gt;、&lt;code&gt;~&lt;/code&gt;、&lt;code&gt;&amp;amp;&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;两种方式可以设置错误提示级别：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;全局设置：PHP配置文件php.ini中，调整error_reporting()级别；&lt;/li&gt;
  &lt;li&gt;局部设置：php脚本中，使用error_reporting()函数；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;举例说明如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//不报告任何错误
error_reporting(0);

//报告所有错误
error_reporting(E_ALL);

//报告除通知之外的所有错误
error_reporting(E_ALL &amp;amp; ~E_NOTICE);

//所有错误以及代码修改建议
error_reporting(E_ALL | E_STRICT);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;web&quot;&gt;Web开发基本过程&lt;/h2&gt;

&lt;p&gt;Web开发的基本过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建模版HTML文件；&lt;/li&gt;
  &lt;li&gt;从模版中抽取：页头文件、页脚文件；&lt;/li&gt;
  &lt;li&gt;将页头、页脚文件导入php主文件中；
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;include(&#39;file.php&#39;);&lt;/code&gt; 若include()函数失败，发出警告；&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;require(&#39;file.php&#39;);&lt;/code&gt; 若require()函数失败，终止脚本；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;通常两个php脚本来处理表单：一个显示表单，一个接收和处理表单数据；
    &lt;ol&gt;
      &lt;li&gt;让同一个脚本来完成整个流程更好；&lt;/li&gt;
      &lt;li&gt;检查变量是否设置：&lt;code&gt;isset($_POST[&#39;something&#39;])；&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;检查表单提交的方法：&lt;code&gt;$_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;POST&#39;&lt;/code&gt;;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;表单粘性：若表单提交后出错，则，重新提交表单，希望能够记录初次填写的表单数值；
    &lt;ol&gt;
      &lt;li&gt;&amp;lt;input … value=”&lt;?php print $_POST[&#39;name&#39;]; ?&gt;” /&amp;gt;&lt;/li&gt;
      &lt;li&gt;不要引用不存在的变量；在引用之前，判断是否存在isset()&lt;/li&gt;
      &lt;li&gt;用户提交的内容，直接显示在表单中有样式问题，可以使用htmlspecialchars()；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;发送Email
    &lt;ol&gt;
      &lt;li&gt;服务器上Email应用程序发送Email；&lt;/li&gt;
      &lt;li&gt;具体：调用函数&lt;code&gt;mail(to, subject, body)&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;substr_count($_POST[&#39;eamil&#39;], &#39;@&#39;) == 1&lt;/code&gt;，邮件验证；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;输出缓冲，只能在服务器发出响应之前进行调用：
    &lt;ol&gt;
      &lt;li&gt;header()：&lt;/li&gt;
      &lt;li&gt;setcookie()：&lt;/li&gt;
      &lt;li&gt;session_start()：&lt;/li&gt;
      &lt;li&gt;ob_start()；开启输出缓存，output buffering；&lt;/li&gt;
      &lt;li&gt;ob_end_flush()；输出缓冲数据；&lt;/li&gt;
      &lt;li&gt;ob_end_clean()；删除缓冲数据，不进行传输；&lt;/li&gt;
      &lt;li&gt;php.ini中可设置输出缓冲区的大写；&lt;/li&gt;
      &lt;li&gt;ob_get_length()；当前输出缓冲区的大小；&lt;/li&gt;
      &lt;li&gt;ob_get_contents()；获取缓冲区内容；&lt;/li&gt;
      &lt;li&gt;ob_flush()；输出当前缓冲区内容，以方便继续缓冲新内容；&lt;/li&gt;
      &lt;li&gt;ob_clean()；清空缓冲区内容，但后续仍会继续缓冲；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP头，header()函数
    &lt;ol&gt;
      &lt;li&gt;重定向：header(‘Location: index.php’);&lt;/li&gt;
      &lt;li&gt;重定向，接着使用函数，exit()；&lt;/li&gt;
      &lt;li&gt;开启输出缓存：ob_start()；&lt;/li&gt;
      &lt;li&gt;如果浏览器已经收到HTTP头，则headers_sent()函数返回TRUE；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cookiesession&quot;&gt;cookie和session&lt;/h3&gt;

&lt;p&gt;cookie、session的作用：跟踪用户，记录用户信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么是cookie&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;客户端保存用户信息的一种方式，服务器通过此信息识别用户身份；将从几点来介绍cookie：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;建立cookie；&lt;/li&gt;
  &lt;li&gt;从cookie中检索信息；&lt;/li&gt;
  &lt;li&gt;删除cookie；&lt;/li&gt;
  &lt;li&gt;限制cookie的可选参数；&lt;/li&gt;
  &lt;li&gt;如何调试与cookie相关的问题；&lt;/li&gt;
  &lt;li&gt;如何传输和接收cookie；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;cookie的访问时间和方式：用户输入URL后，浏览器会将cookie信息包含至HTTP请求内发送给服务器。额外几点说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务器端的PHP和浏览器端的JavaScript都能发送、读取、删除cookie，这是两种脚本重叠的功能之一；&lt;/li&gt;
  &lt;li&gt;cookie必须在服务器发送任何信息之前，从服务器发送到客户端；&lt;/li&gt;
  &lt;li&gt;setcookie(name, value)函数，向浏览器发送cookie；&lt;/li&gt;
  &lt;li&gt;发送cookie，应位于整个HTML页面标签之前（&amp;lt;!DOCTYPE html … &amp;gt;）；&lt;/li&gt;
  &lt;li&gt;若使用输出缓存机制（output buffering），则setcookie()可以位于PHP脚本中任意位置；&lt;/li&gt;
  &lt;li&gt;cookie的总数，限制在4KB；&lt;/li&gt;
  &lt;li&gt;headers_sent()函数可用与测试HTTP头部是否发送出去；&lt;/li&gt;
  &lt;li&gt;cookie的值在发送时，将自动编码，接收时会自动解码；对于PHP表单发送的值也是如此；&lt;/li&gt;
  &lt;li&gt;setcookie()函数在不同的浏览器中，有兼容性问题；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;读取cookie&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;预定义的数组$_COOKIE中存储了所有cookie数据，按照key值，从数组$_COOKIE中读取即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;向cookie中添加参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;函数setcookie()，具体用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//expiration：过期时间点，单位秒(s)；默认关闭浏览器之前有效；
//domain：设置一个子域的cookie；
//secure：为1时，表示只能通过https传送；
//httponly：设置防止JS读取cookie，但不是所有浏览器都支持；
setcookie(name, value, expiration, path, domain, secure, httponly);

setcookie(name, value, time() + 3600)；
setcookie(name, value, time() + 3600, &#39;/subfolder/&#39;);
setcookie(name, value, time() + 3600, &#39;&#39;, &#39;forum.example.com&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;几点注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cookie过期时间的选择：
    &lt;ol&gt;
      &lt;li&gt;cookie持续时间如果同用户浏览网站的时间一样长，则，不需要设置过期时间；&lt;/li&gt;
      &lt;li&gt;如果需要cookie在关闭、重启浏览器之后继续存在，可将过期时间设置为数个月；&lt;/li&gt;
      &lt;li&gt;若cookie可能引发安全隐患，则可将过期时间设置为小于1h；&lt;/li&gt;
      &lt;li&gt;出于安全考虑，可以设定cookie过期时间为5min~10min，同时，让用户每访问一个新页面时，重新发送一次cookie；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;删除cookie&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;删除cookie，本质就是设置一个空值，同时可以设置一个过去的过期时间：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//重设值，同时设置过去的过期时间
setcookie(&#39;username&#39;, FALSE, time() - 600);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特别提醒：删除cookie时，一定要使用与设置cookie一致的参数（除去值和过期时间）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setcookie(&#39;user&#39;, &#39;larry&#39;, time() + 3600, &#39;&#39;, &#39;forums.example.com&#39;);
setcookie(&#39;user&#39;, &#39;&#39;, time() - 600, &#39;&#39;, &#39;forums.example.com&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;什么是session&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;session的数据保存在服务器端，cookie数据保存在客户端；由此，session比cookie拥有更多的优势：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;session通常更安全，因为数据不会在客户端、浏览器之间重复传输；&lt;/li&gt;
  &lt;li&gt;session存储比cookie更多的信息；&lt;/li&gt;
  &lt;li&gt;session能够在禁止cookie的浏览器上，继续工作；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几点说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开启一个session时，PHP会自动创建一个随机的session ID；&lt;/li&gt;
  &lt;li&gt;每个用户都拥有一个自己的Session ID，这也是服务器上存储该用户session数据的文件名称；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;cookie相对于session的优势有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cookie相对容易创建和使用；&lt;/li&gt;
  &lt;li&gt;cookie耗费服务端的资源少；&lt;/li&gt;
  &lt;li&gt;如果希望长期保存用户身份信息，则应采用cookie；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结论：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当保存数据较少，同时安全性要求不高时，推荐首选cookie；&lt;/li&gt;
  &lt;li&gt;保存数据较多或者敏感，同时安全性要求较高时，首选session；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;创建session&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;session_start()函数用于创建一个session，并且在session首次启动时发送一个cookie，因此，必须在所有HTML响应发送回浏览器之前，创建session。
第一次开启session时，随机产生一个session ID，并向Web浏览器发送一个名为PHPSESSID（session的名称）的cookie。&lt;/p&gt;

&lt;p&gt;一旦启用session，就可以通过向数组赋值的方式来存储数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$_SESSION[&#39;first_name&#39;] = &#39;Sam&#39;;
$_SESSION[&#39;age&#39;] = 14；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每次向session中添加数据时，PHP将向服务器上一个临时文件中添加一些数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//session数据在服务器文件中的存储方式
email|s:14:&quot;me@example.com&quot;; loggedin|i:1292;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于session几点信息：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;php.ini中可以配置session信息；&lt;/li&gt;
  &lt;li&gt;ini_set()函数可以设置session信息；&lt;/li&gt;
  &lt;li&gt;session_name()函数可以修改session名称（默认名称PHPSESSID），注意：必须在调用session_start()之前使用；&lt;/li&gt;
  &lt;li&gt;session_set_cookie_params()函数，用户修改session cookie的设置（过期时间、路径、域）；&lt;/li&gt;
  &lt;li&gt;常量SID用格式name=ID的方式保存一个字符串；&lt;/li&gt;
  &lt;li&gt;session中可以保存任意类型数据，甚至对象；&lt;/li&gt;
  &lt;li&gt;在session中，数据都会以纯文本的形式保存在一个开放可读的文本文件中；永远不要将真实的敏感信息存在session中，例如信用卡数据；&lt;/li&gt;
  &lt;li&gt;为提高安全性，可以将数据加密后保存到session中，在读取session后再解密（Mcrypt库）；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;删除session&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;服务器端session中包含的数据都保存在$_SESSION数组中，可以对数组重新赋值，以达到删除session的效果，但也需要删除服务器上保存session数据的临时文件，具体操作如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//重置session
$_SESSION = array();
//删除服务器端session临时文件
session_destroy();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数unset($var)，可用于删除一个变量，也能达到删除$_SESSION的效果；同时，如果浏览器禁用cookie，则可以在URL上添加session ID作为附属参数，以继续使用session，注意：需要在php.ini中启用enable_trans_side。&lt;/p&gt;

&lt;h3 id=&quot;section-29&quot;&gt;文件和目录&lt;/h3&gt;

&lt;p&gt;Web应用程序，不可避免两个问题：数据存储、检索数据。当前数据存储的方法主要有两种：文件（和目录）、数据库。这一部分，主要介绍一下文件的写入、读取和锁定。&lt;/p&gt;

&lt;p&gt;疑问：读取、上传的文件，为什么在Web目录之外？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;file_exists(‘somefile.ext’)，判断文件是否存在；&lt;/li&gt;
  &lt;li&gt;is_readable()测试文件是否可读；&lt;/li&gt;
  &lt;li&gt;touch(‘somefile.ext’)，创建空白文件；&lt;/li&gt;
  &lt;li&gt;chgrp()、chown()、chmod()，修改文件、目录权限；&lt;/li&gt;
  &lt;li&gt;file_put_contents($file, $data)，向文件写入数据；
    &lt;ol&gt;
      &lt;li&gt;文件不存在，则，函数主动创建；&lt;/li&gt;
      &lt;li&gt;文件存在，覆盖文件内容；&lt;/li&gt;
      &lt;li&gt;file_put_contents($file, $data, FILE_APPEND)，追加；&lt;/li&gt;
      &lt;li&gt;如果需要追加的内容独占一行，则需要在内容后，添加换行符，PHP专用常量 PHP_EOL 可以解决这一问题，file_put_contents($file, $data . PHP_EOL, FILE_APPEND)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;file_put_contents($file, $data, LOCK_EX);写文件同时锁定文件；
    &lt;ol&gt;
      &lt;li&gt;若同时追加文件、锁定文件，则，&lt;code&gt;LOCK_EX | FILE_APPEND&lt;/code&gt;；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;file_get_contents($file)，一次读取文件所有内容；&lt;/li&gt;
  &lt;li&gt;file($file)，读取文件内容，并且返回一个数组，每个元素为原文件中的一行；&lt;/li&gt;
  &lt;li&gt;更多文件读取方式：fgets()、fgetcsv()；&lt;/li&gt;
  &lt;li&gt;filesize($file)，返回文件大小（单位Byte）；&lt;/li&gt;
  &lt;li&gt;filetime($file)，返回文件修改时间戳，可使用date()格式化；&lt;/li&gt;
  &lt;li&gt;is_writeable()&lt;/li&gt;
  &lt;li&gt;is_readable()&lt;/li&gt;
  &lt;li&gt;is_dir()&lt;/li&gt;
  &lt;li&gt;is_file()&lt;/li&gt;
  &lt;li&gt;glob()，搜索名字与模式匹配的文件（*.jpg）&lt;/li&gt;
  &lt;li&gt;fileperms()，文件权限；&lt;/li&gt;
  &lt;li&gt;fileatime()，文件最后访问时间；&lt;/li&gt;
  &lt;li&gt;fileowner()，拥有该文件的用户名称；&lt;/li&gt;
  &lt;li&gt;basename()、dirname()，返回文件名、路径名；&lt;/li&gt;
  &lt;li&gt;finfo_file()，文件的MIME类型；&lt;/li&gt;
  &lt;li&gt;mkdir(‘dir_name’, permissions)，创建文件；&lt;/li&gt;
  &lt;li&gt;rmdir()，删除现有目录；&lt;/li&gt;
  &lt;li&gt;fgets()，返回指定长度的字符串；&lt;/li&gt;
  &lt;li&gt;feof()，判断是否达到文件末尾；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;补充几点：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;读取文件&lt;/strong&gt;：PHP 4 以及以下版本，不能使用file_put_contents()，需要按照旧方法来写数据：打开文件、写数据、关闭文件；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//文件模式mode，查PHP手册很详细
$file_pointer = fopen($file, mode);
fwrite($file_pointer, $data . PHP_EOL);
fclose($file_pointer);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;上传文件&lt;/strong&gt;：通过表单上传，修改3处：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;form表单添加enctype，即 &amp;lt;form action=… enctype=”multipart/form-data” method=”post” &amp;gt;；必须使用POST方式；&lt;/li&gt;
  &lt;li&gt;添加银行输入框：&lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;30000&quot; /&gt;，用于建议浏览器最大能够上传的文件；&lt;/li&gt;
  &lt;li&gt;使用file元素，创建所需的表单：&lt;input type=&quot;file&quot; name=&quot;pic&quot; /&gt;，file类型允许用户上传一个文件；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PHP脚本中，使用$_FILES变量能够引用上传的文件。$_FILES数组包含5个成员：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;name，用户上传文件的原始名字；&lt;/li&gt;
  &lt;li&gt;type，文件MIME类型，例：image/jpg；&lt;/li&gt;
  &lt;li&gt;size，文件大小（单位Byte）&lt;/li&gt;
  &lt;li&gt;tmp_name，文件存放在服务器上的临时文件名称；&lt;/li&gt;
  &lt;li&gt;error，发生错误时，保存的错误代码；（查看PHP手册）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;文件上传之后，需要将临时文件移动到最终目标位置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//将临时文件移动到最终位置
move_uploaded_file($_FILES[&#39;pic&#39;][&#39;tmp_name&#39;], &#39;/path/filename&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个php脚本可以同时处理多个文件上传，只要name属性不同即可，此时只需要一个隐含输入框设定MAX_FILE_SIZE。另外，针对移动文件的函数小结：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;move_uplodaded_file()，将上传的临时文件移动到最终位置；&lt;/li&gt;
  &lt;li&gt;unlink()，删除文件，不会进行移动或者复制；&lt;/li&gt;
  &lt;li&gt;copy()，复制文件；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上传文件时，有几点注意：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;php.ini中，开启file_uploads配置；&lt;/li&gt;
  &lt;li&gt;php.ini中，设置upload_tmp_dir，如果没有设置，可能会指定一个隐含值；&lt;/li&gt;
  &lt;li&gt;php.ini中，upload_max_filesize和post_max_size用于设定PHP能够处理的文件大小；&lt;/li&gt;
  &lt;li&gt;form中隐含input元素中设定的MAX_FILE_SIZE只是在前端浏览器处，进行的约束；&lt;/li&gt;
  &lt;li&gt;当缺失要上传大文件时，除了上述相关的配置，还应设置两个参数：memory_limit、max_execution_time，来给PHP脚本足够的处理时间和空间；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;目录相关&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;浏览目录：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;scandir($dir)，返回目录下所有内容，一个数组：包含文件和子目录；&lt;/li&gt;
  &lt;li&gt;旧版本的PHP中，需要使用opendir()、readdir()、closedir()；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mysql&quot;&gt;数据库MySQL&lt;/h3&gt;

&lt;p&gt;PHP中操作MySQL数据库，基本过程，连接数据库、操作、释放连接，具体几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$dbc = mysql_connect(hostname, username, passwd)，获取数据库连接&lt;/li&gt;
  &lt;li&gt;mysql_query($query, $dbc)&lt;/li&gt;
  &lt;li&gt;mysql_query(‘create database somedb’, $dbc);&lt;/li&gt;
  &lt;li&gt;mysql_select_db(‘somedb’, $dbc);&lt;/li&gt;
  &lt;li&gt;$result = mysql_query($query, $dbc)， 执行$query&lt;/li&gt;
  &lt;li&gt;mysql_num_rows($result)，返回查询结果的个数，可用于删除、查询之前判断？&lt;/li&gt;
  &lt;li&gt;$row = mysql_fetch_array($result)，每次返回一行数据，形式：数组；&lt;/li&gt;
  &lt;li&gt;mysql_fetch_array($result, MYSQL_ASSOC or MYSQL_NUM)，关联数组、索引数组；&lt;/li&gt;
  &lt;li&gt;while( $row = mysql_fetch_array($result) ){ … }，用于遍历结果；&lt;/li&gt;
  &lt;li&gt;mysql_affected_rows()，返回INSERT、DELETE、UPDATE等影响到的行数；&lt;/li&gt;
  &lt;li&gt;msyql_close($dbc)，释放连接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;PHP中对MySQL的支持&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PHP操作MySQL，根据扩展不同，分为两类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;标准MySQL，支持所有MySQL版本，函数以 &lt;code&gt;mysql_&lt;/code&gt; 作为前缀；&lt;/li&gt;
  &lt;li&gt;扩展MySQL，MySQLi（Improved MySQL Extension），PHP5之后引入的，支持MySQL4.1以上的版本，能够利用MySQL的一些额外特性，函数以 &lt;code&gt;mysqli_&lt;/code&gt; 最为前缀；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;MySQL错误处理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;常见的错误类型有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;连接MySQL失败；&lt;/li&gt;
  &lt;li&gt;选择数据库失败；&lt;/li&gt;
  &lt;li&gt;无法运行查询；&lt;/li&gt;
  &lt;li&gt;查询没有返回结果；&lt;/li&gt;
  &lt;li&gt;数据没有插入到表中；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体说几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mysql_error()，显示发生错误的详细信息；&lt;/li&gt;
  &lt;li&gt;错误控制符&lt;code&gt;@&lt;/code&gt;，在函数名之前使用，阻止显示错误信息，但并不能阻止错误的发生，仅当希望自己处理错误时，才使用&lt;code&gt;@&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;错误控制符&lt;code&gt;@&lt;/code&gt;，可以用于阻止任何函数的错误、通知、警告，而不仅限于MySQL相关函数；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于PHP中使用MySQL，具体说几点：&lt;/p&gt;

&lt;p&gt;为避免SQL注入攻击，可随意用mysql_real_escape_string()函数，来转义危险字符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$var = mysql_real_escape_string($var, $dbc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有文件编码方式需要与HTML中指定的charset一致；&lt;/li&gt;
  &lt;li&gt;如果为UTF-8编码方式，则，必须为UTF-8 without BOM方式；&lt;/li&gt;
  &lt;li&gt;通过include(‘path/file.php’)，路径为相对与最终php脚本的位置；&lt;/li&gt;
  &lt;li&gt;include_once()、require_once()，表示同一个文件只包含一次；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;特别说明&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/download/php-intro/PHP基础教程（第4版）.pdf&quot;&gt;PHP基础教程（第4版）&lt;/a&gt;的附录部分，有很多进一步学习的建议。&lt;/p&gt;

&lt;h2 id=&quot;section-30&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/download/php-intro/PHP基础教程（第4版）.pdf&quot;&gt;PHP基础教程（第4版）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/download/php-intro/php_enhanced_zh.chm&quot;&gt;PHP Manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>Linux下su和sudo进行身份变换</title>
     <link href="http://ningg.github.com/linux-su-sudo"/>
     <updated>2014-08-16T00:00:00+08:00</updated>
     <id>http://ningg.github.com/linux-su-sudo</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近，一些普通用户要在服务器上，安装软件，不时遇到权限问题，因此，只好将root密码献了出去；太多人知道root密码是件很危险的事，特别是，有的人习惯使用root权限登录，这中情况下，很有可能误操作，删除系统文件；有没有其他办法来避免这个问题呢？&lt;/p&gt;

&lt;p&gt;说几个典型场景：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;场景A&lt;/strong&gt;：用户 &lt;code&gt;UserA&lt;/code&gt; 输入命令 &lt;code&gt;find / -name &quot;hello&quot;&lt;/code&gt;，结果提示: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find: /etc/cups/ssl: Permission denied
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;操作服务器时，不同用户之间的权限差异，概括几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;是否有权限，读（r）、写（w）、执行（x），文件 &lt;code&gt;FileA&lt;/code&gt; ；&lt;/li&gt;
  &lt;li&gt;是否有权限，执行命令&lt;code&gt;commandA&lt;/code&gt;；实质上，命令&lt;code&gt;commandA&lt;/code&gt;对应了某个可执行的文件&lt;code&gt;commandA-File&lt;/code&gt;，有权限执行命令&lt;code&gt;commandA&lt;/code&gt;等价于具有文件&lt;code&gt;commandA-File&lt;/code&gt;的执行（x）权限；&lt;/li&gt;
  &lt;li&gt;用户&lt;code&gt;UserA&lt;/code&gt;，找不到命令&lt;code&gt;commandA&lt;/code&gt;，说明，没有将命令&lt;code&gt;commandA&lt;/code&gt;添加到用户&lt;code&gt;UserA&lt;/code&gt;的环境变量&lt;code&gt;PATH&lt;/code&gt;中；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前介绍的Linux ACL（Access Control List，访问控制列表），已经实现了对文件&lt;code&gt;rwx&lt;/code&gt;权限的控制，因此，问题基本解决。&lt;/p&gt;

&lt;p&gt;Linux下，进行身份变换这一功能，有必要吗？公认的原因有几个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用一般帐号：系统日常维护的好习惯。仅当需要设定系统环境时，才变换为root身份，来进行系统管理；&lt;/li&gt;
  &lt;li&gt;使用较低权限启动系统服务。例如，额外建立一个用户起名：apache，并以此来启动apache软件，这样如果apache程序被攻破了，系统还不至于被摧毁；&lt;/li&gt;
  &lt;li&gt;软件本身的限制：有些远程连接程序（例如ssh），可设置为仅允许非root用户登录；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于上述考虑，通常使用一般帐号登录，在必要的时候，切换成root身份。问题来了：如何使一般用户转换为root用户呢？主要方式有两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;su - root&lt;/code&gt;命令，直接切换为root用户：
    &lt;ul&gt;
      &lt;li&gt;需要输入root密码来确认；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;sudo CMD&lt;/code&gt;命令，利用root身份执行命令&lt;code&gt;CMD&lt;/code&gt;：
    &lt;ul&gt;
      &lt;li&gt;需要事先设定普通用户具备sudo的权限；&lt;/li&gt;
      &lt;li&gt;在进行sudo操作时，需要输入普通用户自己的密码；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;su&quot;&gt;su命令&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;man su&lt;/code&gt;来查看命令使用方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NAME
	   su - run a shell with substitute user and group IDs

SYNOPSIS
	   su [OPTION]... [-] [USER [ARG]...]

DESCRIPTION
	   Change  the  effective  user  id  and group id to that of
	   USER.

	   -, -l, --login
			  make the shell a login shell

	   -c, --command=COMMAND
			  pass a single COMMAND to the shell with -c

	   --session-command=COMMAND
			  pass a single COMMAND to the shell with -c and  do
			  not create a new session

	   -f, --fast
			  pass -f to the shell (for csh or tcsh)

	   -m, --preserve-environment
			  do not reset environment variables

	   -p     same as -m

	   -s, --shell=SHELL
			  run SHELL if /etc/shells allows it

	   --help display this help and exit

	   --version
			  output version information and exit

	   A mere - implies -l.   If USER not given, assume root.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要额外说明的一点：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;命令`su root`与`su - root`命令差异很大：
* `su root`：使用login shell方式登录；
* `su - root`：使用non-login shell方式登录；
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;（疑问：login shell 和 non-login shell之间有什么差异？）&lt;/p&gt;

&lt;p&gt;（说明：non-login shell方式登录，很多环境变量无法读取到，需要使用绝度路径的方式来执行）&lt;/p&gt;

&lt;p&gt;命令&lt;code&gt;su - root&lt;/code&gt;需要root密码，因此不方便多用户之间的使用；有没有既能够以root身份来执行命令，同时也不需要root密码的方式？有，sudo命令，就是干这个的。&lt;/p&gt;

&lt;h2 id=&quot;sudo&quot;&gt;sudo命令&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;man sudo&lt;/code&gt;来查看命令详情：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NAME
	   sudo, sudoedit - execute a command as another user

SYNOPSIS
	   sudo -h | -K | -k | -L | -V

	   sudo -v [-AknS] [-g group name|#gid] [-p prompt]
	   [-u user name|#uid] [command]

	   sudo -l[l] [-AknS] [-g group name|#gid] [-p prompt]
	   [-U user name] [-u user name|#uid] [command]

	   sudo [-AbEHnPS] [-C fd] [-g group name|#gid] [-p prompt]
	   [-r role] [-t type] [-u user name|#uid] [VAR=value]
	   [-i | -s] [command]

	   sudoedit [-AnS] [-C fd] [-g group name|#gid] [-p prompt]
	   [-u user name|#uid] file ...

DESCRIPTION
	   sudo allows a permitted user to execute a command as the
	   superuser or another user, as specified in the sudoers
	   file.  The real and effective uid and gid are set to
	   match those of the target user as specified in the passwd
	   file and the group vector is initialized based on the
	   group file (unless the -P option was specified).  If the
	   invoking user is root or if the target user is the same
	   as the invoking user, no password is required.
	   
	   Otherwise, sudo requires that users authenticate
	   themselves with a password by default (NOTE: in the
	   default configuration this is the user’s password, not
	   the root password).  Once a user has been authenticated,
	   a time stamp is updated and the user may then use sudo
	   without a password for a short period of time (5 minutes
	   unless overridden in sudoers).

	   When invoked as sudoedit, the -e option (described
	   below), is implied.

	   sudo determines who is an authorized user by consulting
	   the file /etc/sudoers.  By running sudo with the -v
	   option, a user can update the time stamp without running
	   a command.  If a password is required, sudo will exit if
	   the user’s password is not entered within a configurable
	   time limit.  The default password prompt timeout is 5
	   minutes.

	   If a user who is not listed in the sudoers file tries to
	   run a command via sudo, mail is sent to the proper
	   authorities, as defined at configure time or in the
	   sudoers file (defaults to root).  Note that the mail will
	   not be sent if an unauthorized user tries to run sudo
	   with the -l or -v option.  This allows users to determine
	   for themselves whether or not they are allowed to use
	   sudo.

	   If sudo is run by root and the SUDO_USER environment
	   variable is set, sudo will use this value to determine
	   who the actual user is.  This can be used by a user to
	   log commands through sudo even when a root shell has been
	   invoked.  It also allows the -e option to remain useful
	   even when being run via a sudo-run script or program.
	   Note however, that the sudoers lookup is still done for
	   root, not the user specified by SUDO_USER.

	   sudo can log both successful and unsuccessful attempts
	   (as well as errors) to syslog(3), a log file, or both.
	   By default sudo will log via syslog(3) but this is
	   changeable at configure time or via the sudoers file.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sudo命令，注意事项：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;默认，只有root能使用&lt;code&gt;sudo&lt;/code&gt;命令；&lt;/li&gt;
  &lt;li&gt;基本用法：&lt;code&gt;sudo -u [username] [command]&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;没有指定&lt;code&gt;-u [username]&lt;/code&gt;选项时，默认&lt;code&gt;-u root&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;root执行sudo时，不需要输入密码；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;sudo -u [username] [command]&lt;/code&gt;中当前用户即为&lt;code&gt;username&lt;/code&gt;时，也不需要输入密码；（即，自己切换为自己身份时，不需要输入密码）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;sudo执行流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用户执行sudo时，系统于/etc/sudoers文件中，查找用户是否有执行sudo的权限；&lt;/li&gt;
  &lt;li&gt;若具有执行sudo的权限，则让用户输入自己密码来确认执行；&lt;/li&gt;
  &lt;li&gt;密码正确，则执行命令；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用户是否具有sudo执行权限，依据是/etc/sudoers文件，因此，为某一用户开通sudo权限，本质就是修改/etc/sudoers文件，直接使用vim来编辑，有可能会破坏文件的规范，推荐使用命令&lt;code&gt;visudo&lt;/code&gt;来修改这一文件。&lt;/p&gt;

&lt;h2 id=&quot;visudo&quot;&gt;visudo命令&lt;/h2&gt;

&lt;h3 id=&quot;aroot&quot;&gt;场景A：单个用户拥有root所有命令&lt;/h3&gt;

&lt;p&gt;（分析：拥有root的所有命令？命令难道不是添加到PATH环境变量中就可以了吗？不是的，命令添加到PATH变量中，也是需要用户有这个命令的执行&lt;code&gt;x&lt;/code&gt;权限的。）&lt;/p&gt;

&lt;p&gt;如果希望dev用户使用root的所有命令，那么可以进行如下修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# visudo
...
## Allow root to run any commands anywhere
root    ALL=(ALL)       ALL
# 新增的一行
dev		ALL=(ALL)       ALL
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面对新增行的格式进行简要说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;用户      用户登录来源主机名=(可切换的身份)	可执行的命令
root                     ALL=(ALL)	       	ALL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面四个组件含义进行简要说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用户：这个用户可以使用sudo命令，默认为root用户；&lt;/li&gt;
  &lt;li&gt;用户登录来源主机：设定允许用户通过哪些主机登录过来；&lt;/li&gt;
  &lt;li&gt;可切换的身份：可以切换为什么身份来执行命令，默认root可以切换为任何用户；&lt;/li&gt;
  &lt;li&gt;可执行的命令：务必使用绝对路径；&lt;/li&gt;
  &lt;li&gt;ALL关键词：代表任何身份、主机、命令；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在dev用户就可以执行sudo命令了，按照下面操作试一试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[dev@localhost /]$ head -n 1 /etc/shadow
head: cannot open `/etc/shadow&#39; for reading: Permission denied
[dev@localhost /]$ sudo head -n 1 /etc/shadow
[sudo] password for devp:
root:$6$2t1NiW.e$SM0:16296:0:99999:7:::
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;授予sudo命令的执行权限之前，需调查用户的人品，除非必要，一概不授予普通用户sudo权限。上述设置中，dev用户相当于拥有了整个系统的所有权限，通过&lt;code&gt;sudo visudo&lt;/code&gt;命令，用户&lt;code&gt;dev&lt;/code&gt;也能够像&lt;code&gt;root&lt;/code&gt;用户一样设定所有用户的sudo权限，欧，这也太危险了。&lt;/p&gt;

&lt;h3 id=&quot;bsudo&quot;&gt;场景B：群组的sudo权限及免密码功能&lt;/h3&gt;

&lt;p&gt;如果希望&lt;code&gt;group=dev&lt;/code&gt;内的所有成员都具有sudo命令权限，则进行如下设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# visudo
...
## Allows people in group wheel to run all commands
# %wheel        ALL=(ALL)       ALL
# 新增的一行
%dev   ALL=(ALL)       ALL
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上述设置，&lt;code&gt;group=dev&lt;/code&gt;内成员都具有了sudo权限命令，今后赋予新的成员sudo权限时，只需要将其加入&lt;code&gt;dev&lt;/code&gt;组内即可，而不必每次都修改&lt;code&gt;/etc/sudoers&lt;/code&gt;文件。补充：如何设置用户免密码使用sudo权限？OK，请看如下操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# visudo
...
## Same thing without a password
# %wheel        ALL=(ALL)       NOPASSWD: ALL
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;csudo&quot;&gt;场景C：命令受限的sudo权限&lt;/h3&gt;

&lt;p&gt;前面两个场景中，普通用户获得了与root相当的权限，甚至普通用户反过来能修改root的密码（使用命令：&lt;code&gt;sudo -u root passwd&lt;/code&gt;），这是篡权啊，想想就害怕。然而，害怕并不能解决问题，一些情况下，又必须给普通用户sudo权限，好了，能不能只给用户受限制的sudo权限呢？&lt;/p&gt;

&lt;p&gt;下面以添加用户dev，使其辅助root修改其他用户的密码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# visudo
...
## 为`dev`用户添加权限，使其辅助root修改其他用户密码
dev        ALL=(root)       /usr/bin/passwd [A-Za-Z]*,!/usr/bin/passwd,!/usr/bin/passwd root
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;几点说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过sudo授权用户可执行的命令&lt;code&gt;/usr/bin/passwd&lt;/code&gt;等，要使用绝对路径；&lt;/li&gt;
  &lt;li&gt;多个授权命令之间，使用逗号&lt;code&gt;,&lt;/code&gt;分割；&lt;/li&gt;
  &lt;li&gt;在命令前添加感叹号&lt;code&gt;!&lt;/code&gt;，表示禁止执行此命令；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dvisudo&quot;&gt;场景D：visudo用别名简化配置&lt;/h3&gt;

&lt;p&gt;针对这个情况，举个例子，就清晰了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;User_Alias ADMPW = pro1,pro2
Cmnd_Alias ADMPWCMD = !/usr/bin/passwd, \
		/usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root

ADMPW ALL=(root) ADMPWCOM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际场景中如果忘记了这个例子，没有关系的，只需要&lt;code&gt;visudo&lt;/code&gt;命令，就能看到文件&lt;code&gt;/etc/sudoers&lt;/code&gt;中注释部分的提示了。&lt;/p&gt;

&lt;h3 id=&quot;sudo-1&quot;&gt;sudo命令密码有效时长&lt;/h3&gt;

&lt;p&gt;如果第一次执行sudo命令，则需要输入用户密码，但短时间内T，再次使用sudo命令时，并不需要输入密码。因为系统相信短时间T内，你不会离开服务器，所以再次执行sudo命令，是同一个人。&lt;/p&gt;

&lt;p&gt;（如何设置sudo命令密码的有效时长？）&lt;/p&gt;

&lt;h3 id=&quot;sudosu&quot;&gt;sudo搭配su的使用方式&lt;/h3&gt;

&lt;p&gt;很多时候，我们需要大量的执行很多root的工作，所以，一直使用sudo觉得很烦！那有没有方法使用sudo搭配su，一口气身份转换为root，并且还用用户自己的密码来编程root呢？是有的，而且方法简单的会让你想笑！具体如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@www ~]visudo
...
User_Alias ADMINS =pro1,pro2,pro3
ADMINS ALL=(root) /bin/su -
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，上述pro1、pro2、pro3共计3个用户，只需要输入&lt;code&gt;sudo su -&lt;/code&gt;命令，并且输入自己的密码后，立即转换为root身份了！但root密码不会外流。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特别说明&lt;/strong&gt;：所有sudo用户，都是经过人格调查后，服务器管理员绝对信任的用户，否则，禁掉这一用户的sudo权限。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;参考来源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;《&lt;a href=&quot;&quot;&gt;鸟哥的Linux私房菜 基础版（第三版）–Chapter 14&lt;/a&gt;》&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>ACL入门</title>
     <link href="http://ningg.github.com/linux-acl"/>
     <updated>2014-08-14T00:00:00+08:00</updated>
     <id>http://ningg.github.com/linux-acl</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;文件系统上，文件权限管理的时候，通常有一个词语：ACL。ACL到底是什么？&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;是什么&lt;/h2&gt;

&lt;p&gt;（侧重于ACL能做什么事）&lt;/p&gt;

&lt;p&gt;ACL（&lt;code&gt;Access Control List&lt;/code&gt;，访问控制列表），并不用于设定&lt;code&gt;文件&lt;/code&gt;/&lt;code&gt;目录&lt;/code&gt;的owner、group、others的read、write、execute（&lt;code&gt;r&lt;/code&gt;,&lt;code&gt;w&lt;/code&gt;,&lt;code&gt;x&lt;/code&gt;）权限，而是除此权限设置之外的更细节的权限设置。&lt;/p&gt;

&lt;p&gt;特别说明：实际上，ACL也可以设置文件owner、group、others对应的&lt;code&gt;r&lt;/code&gt;/&lt;code&gt;w&lt;/code&gt;/&lt;code&gt;e&lt;/code&gt;权限，但我们通常使用&lt;code&gt;chmod&lt;/code&gt;命令来实现此功能，而倾向将ACL用于除此之外的权限设置。&lt;/p&gt;

&lt;p&gt;ACL设定的权限主要有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用者（&lt;code&gt;user&lt;/code&gt;）：设置某个使用者（&lt;code&gt;user&lt;/code&gt;）读、写、执行一个文件的权限；解释：此处的&lt;code&gt;user&lt;/code&gt;，不是&lt;code&gt;owner&lt;/code&gt;，而是其他的用户；&lt;/li&gt;
  &lt;li&gt;群组（&lt;code&gt;group&lt;/code&gt;）：设置某个群组（&lt;code&gt;group&lt;/code&gt;）读、写、执行一个文件的权限；解释：此处的&lt;code&gt;group&lt;/code&gt;不是指，文件对应的&lt;code&gt;owning group&lt;/code&gt;的执行权限，而是除&lt;code&gt;owning group&lt;/code&gt;之外的其他&lt;code&gt;group&lt;/code&gt;，操作此文件的权限；&lt;/li&gt;
  &lt;li&gt;默认属性（&lt;code&gt;mask&lt;/code&gt;）：设定某一个&lt;code&gt;目录&lt;/code&gt;之下，新建&lt;code&gt;文件&lt;/code&gt;/&lt;code&gt;目录&lt;/code&gt;时，这些新建的&lt;code&gt;文件&lt;/code&gt;/&lt;code&gt;目录&lt;/code&gt;的默认权限;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（上面内容有待补充）&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;怎么用&lt;/h2&gt;

&lt;p&gt;ACL（&lt;code&gt;访问控制列表&lt;/code&gt;），是Unix-like操作系统权限的额外支持项目，需要文件系统（&lt;code&gt;File System&lt;/code&gt;）的支持。当前大部分文件系统都支持ACL，例如：EXT2/3
、JFS、XFS等。&lt;/p&gt;

&lt;h3 id=&quot;acl&quot;&gt;是否支持ACL&lt;/h3&gt;

&lt;p&gt;使用命令&lt;code&gt;dumpe2fs -h /dev/sda1&lt;/code&gt;查看某一分区上文件系统是否支持ACL，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost devp]# dumpe2fs -h /dev/sda1
dumpe2fs 1.41.12 (17-May-2010)
...
Default mount options:    user_xattr acl
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：&lt;code&gt;dumpe2fs&lt;/code&gt;含义：dump ext2/ext3/ext4 filesystem information.	&lt;/p&gt;

&lt;h3 id=&quot;acl-1&quot;&gt;是否启用ACL&lt;/h3&gt;

&lt;p&gt;文件系统支持ACL，即有能力开启ACL，但是文件系统需要开启ACL，通过如下方式来查询是否开启ACL：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 直接参阅挂载参数
[root@localhost ~]# mount
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
tmpfs on /dev/shm type tmpfs (rw)
/dev/sda1 on /boot type ext4 (rw)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;备注：“是否支持ACL”和“是否启用ACL”这两部分，自己理解不能肯定，需要补充。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;两个命令&lt;/h3&gt;

&lt;p&gt;filesystem启动ACL支持之后，就可以设定和查看ACL了，主要是两条命令：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;getfacl&lt;/code&gt;：查看文件的ACL；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;setfacl&lt;/code&gt;：设置文件的ACL；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两个命令侧重于使用命令：&lt;code&gt;man [COMMAND]&lt;/code&gt;来查看命令细节。两个命令相互配合使用，通常&lt;code&gt;setfacl&lt;/code&gt;之后，跟着一个&lt;code&gt;getfacl&lt;/code&gt;来查看设置是否成功。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;几个场景和实例&lt;/h3&gt;

&lt;h4 id=&quot;section-5&quot;&gt;简介&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;setfacl&lt;/code&gt;：&lt;code&gt;set file access control list&lt;/code&gt;，设置ACL。命令详情如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[superman@localhost /]$ setfacl --help
setfacl 2.2.49 -- `set file access control lists`
Usage: setfacl [-bkndRLP] { -m|-M|-x|-X ... } file ...
  -m, --modify=acl        modify the current ACL(s) of file(s)
  -M, --modify-file=file  read ACL entries to modify from file
  -x, --remove=acl        remove entries from the ACL(s) of file(s)
  -X, --remove-file=file  read ACL entries to remove from file
  -b, --remove-all        remove all extended ACL entries
  -k, --remove-default    remove the default ACL
	  --set=acl           set the ACL of file(s), replacing the current ACL
	  --set-file=file     read ACL entries to set from file
	  --mask              do recalculate the effective rights mask
  -n, --no-mask           don&#39;t recalculate the effective rights mask
  -d, --default           operations apply to the default ACL
  -R, --recursive         recurse into subdirectories
  -L, --logical           logical walk, follow symbolic links
  -P, --physical          physical walk, do not follow symbolic links
	  --restore=file      restore ACLs (inverse of `getfacl -R&#39;)
	  --test              test mode (ACLs are not modified)
  -v, --version           print version and exit
  -h, --help              this help text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getfacl&lt;/code&gt;：&lt;code&gt;get file access control lists&lt;/code&gt;，查看ACL。命令详情如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[god@localhost /]$ getfacl -h
getfacl 2.2.49 -- get file access control lists
Usage: getfacl [-aceEsRLPtpndvh] file ...
  -a,  --access           display the file access control list only
  -d, --default           display the default access control list only
  -c, --omit-header       do not display the comment header
  -e, --all-effective     print all effective rights
  -E, --no-effective      print no effective rights
  -s, --skip-base         skip files that only have the base entries
  -R, --recursive         recurse into subdirectories
  -L, --logical           logical walk, follow symbolic links
  -P, --physical          physical walk, do not follow symbolic links
  -t, --tabular           use tabular output format
  -n, --numeric           print numeric user/group identifiers
  -p, --absolute-names    don&#39;t strip leading &#39;/&#39; in pathnames
  -v, --version           print version and exit
  -h, --help              this help text
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;user&quot;&gt;场景1：设置user权限&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;场景描述：让devp用户获取查看&lt;code&gt;/root&lt;/code&gt;目录的权限。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;设置user权限的命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setfacl -m u:devp:rx /root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 查看目录详情（不是目录下内容列表）
// 查询结果中`dr-xr-x---+`，最后的`+`表示有ACL附加权限；
[god@localhost /]# ll -d root
dr-xr-x---+ 18 root root 4096 Aug  5 09:32 root
// 查看ACL详情
[god@localhost /]# getfacl root
# file: root 
# owner: root
# group: root
user::r-x       //`owner`的权限
user:devp:r-x   //用户`devp`的权限（ACL设置的细节）
group::r-x      //`owning group`的权限
mask::r-x       //什么含义？（ACL设置的细节）
other::---
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;user-1&quot;&gt;场景2：取消user权限&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;场景描述：在场景1中设置了devp用户查看&lt;code&gt;/root&lt;/code&gt;目录的权限，如何取消devp用户的这一权限呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;取消&lt;code&gt;user&lt;/code&gt;权限的命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setfacl -x u:devp /root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 查看ACL详情
[god@localhost /]# getfacl root
# file: root 
# owner: root
# group: root
user::r-x       //`owner`的权限
group::r-x      //`owning group`的权限
mask::r-x       
other::---
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;group&quot;&gt;场景3：设置group权限&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;场景描述：如何设置&lt;code&gt;devp&lt;/code&gt;组拥有&lt;code&gt;/root&lt;/code&gt;目录的查看权限？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;设置命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set -m g:devp:rx /root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询结果：&lt;/p&gt;

&lt;p&gt;（未完待续，各个典型场景）	&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;什么原理&lt;/h2&gt;

&lt;p&gt;（参考：Hadoop技术内幕中HDFS的架构设计与实现原理）&lt;/p&gt;

&lt;h2 id=&quot;hdfsacl&quot;&gt;HDFS中的ACL&lt;/h2&gt;

&lt;p&gt;Hadoop从2.4.0版本开始支持ACL（英文原版的出处），并且已经有人对此进行了测试：http://blog.csdn.net/j2eelamp/article/details/24594159&lt;/p&gt;

</content>
   </entry>
   
 
</feed>
