<!DOCTYPE html>
<html xmlns:wb="http://open.weibo.com/wb">
<head>
    <!--   Author: NingG   -->
    <meta charset="utf-8" />
	<meta property="wb:webmaster" content="7ea7f3d5f3edad6a" />
    <title>Java中文件读写 | ningg.top</title>
    <meta name="author" content="NingG" />
    <meta name="renderer" content="webkit">
    <meta name="description" content=" 找到文件、打开文件、读取内容/写入内容、关闭文件  " />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">

    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="" />
	
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
	<script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
	
    <div class="home-menu">
        <div class="home-icon-con">
            <a class="home-menu-icon" href="/">NingG</a>
            <a class="home-follow" href="#" title="Contact Me">+</a>
        </div>
        <div class="home-contact">
            <a href="http://weibo.com/ggningg/" target="_blank" style="margin-left:-5px;"><img src="http://www.weibo.com/favicon.ico" alt="" width="25"/></a>
            <a href="http://www.douban.com/people/ggningg/" target="_blank" style="text-align:center;"><img src="http://www.douban.com/favicon.ico" alt="" width="22"/></a>
			<a href="http://github.com/ningg" alt="" target="_blank" style="text-align:right;"><img src="/images/icon-cube-smaller.png" width="22"/></a>
        </div>
    </div>

    <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/java-file" title="Java中文件读写">Java中文件读写</a></h1>
        <p class="entry-date">2013-01-20</p>
        <h2 id="section">分析</h2>

<p>开篇即开扯，数年前，我被某人问道java如何进行文件读写，具体：从<code>FileA</code>中读取内容，并追加写入<code>FileB</code>内。我一听，简单呀，几个步骤：</p>

<ul>
  <li>Java中找到两个文件<code>FileA</code>和<code>FileB</code>；</li>
  <li>打开文件<code>FileA</code>和<code>FileB</code>；</li>
  <li>读取文件<code>FileA</code>的内容；</li>
  <li>将读取的文件<code>FileA</code>内容追加到<code>FileB</code>后；</li>
  <li>关闭文件<code>FileA</code>和<code>FileB</code>；</li>
</ul>

<p>打完收工，简简单单；然后，某人递给我一张纸，“把上述过程的java代码写到纸上吧”。沉思2分钟，我x，“我不会”。</p>

<h2 id="section-1">文件读写的基本原理</h2>

<p>（涉及到stream层面的内容）</p>

<ul>
  <li>FileInputStream、FileOutputStream：read(byte[])和write(byte[], int, int)</li>
  <li>InputStreamReader（利用：inputStream、FileInputStream）、OutputStreamWriter（利用：outputStream、FileOutputStream）</li>
  <li>FileReader、FileWriter（实际上为上述StreamReader和StreamWriter的子类）</li>
</ul>

<p><strong>补充梳理</strong>：</p>

<ul>
  <li>FileInputStream：byte–InputStreamReader–FileReader：char</li>
  <li>通过在InputStreamReader外封装一层BufferedReader，增加文件读取效率。</li>
  <li>下面两种情景下，一定要使用Reader，而不能简单的使用Stream：
    <ul>
      <li>读取文件，并进行正则匹配时：<code>InputStreamReader(InputStream, String charset)</code>，推荐利用<code>BufferedReader(Reader)</code>，其可以按行读取内容；</li>
      <li>读取文件，转换为另一种编码方式存储时：
        <ul>
          <li><code>InputStreamReader(InputStream, String charsetIn)</code> </li>
          <li><code>OutputStreamWriter(OutputStream, String charsetOut)</code></li>
          <li>小结：上述核心，char转换为byte之后，可以转换为任意编码方式的char</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>（涉及到class之间的继承关系，简洁的应用代码）</p>

<p><img src="/images/java-file/java-file-class.png" alt="" /></p>

<p>读取文件，两个维度：</p>

<ul>
  <li>按行，读写文件；
    <ul>
      <li><code>BufferedReader.readLine()</code></li>
      <li><code>BufferedWrite.newLine()</code></li>
    </ul>
  </li>
  <li>按缓存空间，读写文件：
    <ul>
      <li><code>Reader.read(char[])</code></li>
      <li><code>Writer.write(char[], int, int)</code></li>
      <li><code>FileInputStream.read(byte[])</code></li>
      <li><code>FileOutputStream.write(byte[], int, int)</code></li>
    </ul>
  </li>
  <li>调用缓存机制；
    <ul>
      <li><code>BufferedReader(Reader)</code>、<code>BufferedWriter(Writer)</code></li>
      <li><code>BufferedInputStream(InputStream)</code>、<code>BufferedOutputStream(OutputStream)</code></li>
    </ul>
  </li>
</ul>

<h2 id="bytechar">分类：byte和char</h2>

<p>差异：char是人眼可以识别的内容，可用于进行正则匹配或搜索；但需要经过一次byte与char之间的转换；</p>

<p><strong>疑问</strong>：到底有什么差异？上面只是自己直观的感受，可能有误差；需要查证一下，产生两种方式的原因；</p>

<h3 id="char">按char读写</h3>

<p>字符，是人眼可以识别的内容，可以进行正则匹配；<code>java.io.Reader</code>和<code>java.io.Writer</code>，按字符（character）读写文件，具体几种方式：</p>

<ul>
  <li><code>java.io.FileReader</code>和<code>java.io.FileWriter</code>
    <ul>
      <li>默认的编码方式（系统编码）</li>
      <li>默认的byte-buffer size</li>
      <li>读写操作：
        <ul>
          <li>读取：<code>charLen = FileReader.read(char[] charBuf)</code></li>
          <li>循环条件：<code>charLen != -1</code></li>
          <li>写入：<code>FileWriter.write(charBuf, 0, charLen)</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code>java.io.InputStreamReader</code>和<code>java.io.OutputStreamWriter</code>
    <ul>
      <li>编码方式：初始化对象时指定，<code>InputStreamReader(InputStream, charset)</code></li>
      <li>编码方式：初始化对象时指定，<code>OutputStreamWriter(OutputStream, charset)</code></li>
      <li>两个Stream：FileInputStream、FileOutputStream；</li>
    </ul>
  </li>
  <li><code>java.io.BufferedReader</code>和<code>java.io.BufferedWriter</code>
    <ul>
      <li>初始化对象：
        <ul>
          <li><code>BufferedReader(Reader)</code></li>
          <li><code>BufferedWriter(Writer)</code></li>
        </ul>
      </li>
      <li>按行读取、按行写入、追加换行：
        <ul>
          <li><code>BufferedReader.readLine() != null</code></li>
          <li><code>BufferedWriter.write(String)</code></li>
          <li><code>BufferedWriter.newLine()</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="byte">按byte读写</h3>

<p>字节，机器识别的内容；<code>java.io.InputStream</code>和<code>java.io.OutputStream</code>，具体几种方式：</p>

<ul>
  <li><code>java.io.FileInputStream</code>和<code>java.io.FileOutputStream</code>；
    <ul>
      <li>读取：<code>byteLen = FileInputStream.read(byte[] byteBuf)</code></li>
      <li>循环条件：<code>byteLen != -1</code></li>
      <li>写入：<code>FileOutputStream.write(byteBuf, 0, byteLen)</code></li>
    </ul>
  </li>
  <li><code>java.io.BufferedInputStream</code>和<code>java.io.BufferedOutputStream</code>
    <ul>
      <li>初始化对象：
        <ul>
          <li><code>BufferedInputStream(InputStream)</code></li>
          <li><code>BufferedOutputStream(OutputStream)</code></li>
        </ul>
      </li>
      <li>读写文件，具体参照<code>FileInputStream</code>和<code>FileOutputStream</code>；</li>
    </ul>
  </li>
</ul>

<p><strong>思考</strong>：Buffered中详细的机制，特别是其中几个方法：<code>mark()</code>、<code>skip()</code>、<code>reset()</code>、<code>ready()</code>等等；</p>

<h2 id="filereader--filewriter">FileReader &amp; FileWriter</h2>

<p>java.io.FileReader和java.io.FileWriter，几点：</p>

<ul>
  <li>以character来读写文件；</li>
  <li>default character encoding；</li>
  <li>default byte-buffer size；</li>
</ul>

<p><strong>疑问</strong>：<code>byte-buffer size</code>什么东西？</p>

<p>程序的处理过程，几点：</p>

<ul>
  <li>新建实例：FileReader和FileWriter</li>
  <li>为存储从FileReader中读取的内容，新建：
    <ul>
      <li><code>char[] bufChar = new char[100]</code></li>
      <li><code>int bufLen = -1</code></li>
    </ul>
  </li>
  <li>循环读取和写入
    <ul>
      <li>终止条件：<code>(bufLen = fileReader.read(bufChar)) != -1</code></li>
      <li>写入新文件：<code>fileWriter(bufChar, 0, bufLen)</code></li>
    </ul>
  </li>
  <li>刷新并关闭数据流：
    <ul>
      <li><code>fileWriter.flush()</code></li>
      <li><code>fileWriter.close()</code></li>
      <li><code>fileReader.read()</code></li>
    </ul>
  </li>
</ul>

<p>核心代码：</p>

<pre><code>File srcFile = new File(srcFilename);
File destFile = new File(destFilename);

FileReader srcFileReader = new FileReader(srcFile);
FileWriter destFileWriter = new FileWriter(destFile);

char[] bufChar = new char[1000];
int bufLen = -1;

while( (bufLen = srcFileReader.read(bufChar)) != -1 ){
	destFileWriter.write(bufChar, 0, bufLen);
	Arrays.fill(bufChar, '\0');
}

destFileWriter.flush();
destFileWriter.close();
srcFileReader.close();
</code></pre>

<p>完整示例代码如下：</p>

<pre><code>package com.github.ningg;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;

public class TestFile {

	public static void main(String[] args) throws IOException {
		
		String srcFilePath = "E:/2.log";
		String destFilePath = "E:/2char.log";
		
		File srcFile = new File(srcFilePath);
		File destFile = new File(destFilePath);
		
		FileReader fileReader = new FileReader(srcFile);
		FileWriter fileWriter = new FileWriter(destFile);
		
		char[] charArray = new char[1000];
		int charLen = -1;
		
		while ( (charLen = fileReader.read(charArray)) != -1) {
			System.out.println(Arrays.toString(charArray));
			fileWriter.write(charArray, 0, charLen);
			Arrays.fill(charArray, '\0');
		};
		
		fileWriter.flush();
		fileReader.close();
		fileWriter.close();
		
	}
}
</code></pre>

<p><strong>疑问</strong>：上述<code>FileReader.read()</code>和<code>FileWriter.write()</code>，其中，<code>write()</code>本质是覆盖写，是否有追加写？</p>

<ul>
  <li><code>FileWriter.write(String filename)</code>：
    <ul>
      <li>若filename对应文件不存在，则程序自动创建；</li>
      <li>若filename对应文件为只读，则抛出异常；</li>
      <li>若filename对应文件已被打开，并且OS限制只允许一个进程占用文件，则抛出异常；</li>
    </ul>
  </li>
  <li><code>FileWriter.write(String filename, boolean append)</code>：
    <ul>
      <li><code>boolean append</code>字段，设置为<code>true</code>时，将以<code>追加</code>方式写入文件；</li>
      <li>默认，以<code>覆盖</code>方式写入文件；</li>
    </ul>
  </li>
</ul>

<p><strong>疑问</strong>：按照char的方式读写文件时，<code>FileReader</code>和<code>FileWriter</code>利用了默认的编码方式，通常是<code>UTF-8</code>；那，有没有按照char方式读写文件，同时可以指定<code>charset</code>的办法呢？</p>

<h2 id="inputstreamreader--outputstreamwriter">InputStreamReader &amp; OutputStreamWriter</h2>

<p>完整示例代码如下：</p>

<pre><code>package com.github.ningg;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;

public class InputStreamReaderAndOutputStreamWriter {

	public static void main(String[] args) throws IOException {
		
		String charset = "GBK";

		String srcFilepath = "E:/1.log";
		String destFilepath = "E:/1char.log";
		
		FileInputStream srcFileInputStream = new FileInputStream(srcFilepath);
		FileOutputStream destFileOutputStream = new FileOutputStream(destFilepath);
		
		InputStreamReader srcStreamReader = new InputStreamReader(srcFileInputStream, charset);
		OutputStreamWriter destStreamWriter = new OutputStreamWriter(destFileOutputStream, charset);
		
		char bufChar[] = new char[1000];
		int bufLen = -1;
		
		while( (bufLen = srcStreamReader.read(bufChar)) != -1 ){
			destStreamWriter.write(bufChar, 0, bufLen);
			System.out.println(Arrays.toString(bufChar));
			Arrays.fill(bufChar, '\0');
		}
		
		destStreamWriter.flush();
		destStreamWriter.close();
		srcStreamReader.close();
		
	}
}
</code></pre>

<h2 id="bufferedreader--bufferedwriter">BufferedReader &amp; BufferedWriter</h2>

<p><strong>思考</strong>：BufferedReader和BufferedWriter的实现机制？</p>

<ul>
  <li>BufferedReader：
    <ul>
      <li>缓存空间：
        <ul>
          <li><code>BufferedReader(Reader)</code>和<code>BufferedReader(Reader, int bufSize)</code>；</li>
          <li>默认buffer size：8192（8K char），能够满足大部分需要；</li>
        </ul>
      </li>
      <li>按行读取；
        <ul>
          <li><code>BufferedReader.readLine()</code>：读取下一行的内容，不包含<code>换行符</code>；</li>
          <li><code>readLine() == null</code>为文章末尾；</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>BufferedWriter：
    <ul>
      <li>缓存空间：
        <ul>
          <li><code>BufferedWriter(Writer)</code>和<code>BufferedWriter(Writer, int bufSize)</code>；</li>
          <li>默认buffer size：8192（8K char），能满足大部分需要；</li>
        </ul>
      </li>
      <li>写入数据：
        <ul>
          <li><code>BufferedWriter.wirte(String)</code>：写入数据</li>
          <li>增加换行符：<code>BufferedWriter.newLine()</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>完整示例代码如下：</p>

<pre><code>package com.github.ningg;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class BufferedReaderAndBufferedWriter {

	public static void main(String[] args) throws IOException {
		
		String srcFile = "E:/1.log";
		String destFile = "E:/lbuf.log";
		String charset = "GBK";
		
		FileInputStream fileInputStream = new FileInputStream(srcFile);
		FileOutputStream fileOutputStream = new FileOutputStream(destFile);
		
		InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, charset);
		OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream, charset);
		
		BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
		BufferedWriter bufferedWriter = new BufferedWriter(outputStreamWriter);
		
		String inputLine = null;
		
		while((inputLine = bufferedReader.readLine()) != null ){
			bufferedWriter.write(inputLine);
			bufferedWriter.newLine();
			System.out.println(inputLine);
		}
		
		bufferedWriter.flush();
		bufferedWriter.close();
		bufferedReader.close();
		
		fileOutputStream.flush();
		fileOutputStream.close();
		fileInputStream.close();
	}
}
</code></pre>

<p><strong>思考</strong>：几个方法的作用，以及联系：</p>

<ul>
  <li>输出数据时，flush()：
    <ul>
      <li>FileOutputStream：自身flush()</li>
      <li>FileWriter：本质，OutputStream.flush()</li>
      <li>OutputStreamWriter：本质，调用OutputStream.flush()</li>
      <li>BufferedWriter：本质，调用Writer.flush()</li>
    </ul>
  </li>
  <li>输出数据时，close()：
    <ul>
      <li>FileOutputStream</li>
      <li>FileWriter</li>
      <li>OutputStreamWriter</li>
      <li>BufferedWriter</li>
    </ul>
  </li>
  <li>读取数据时，close()：
    <ul>
      <li>FileInputStream</li>
      <li>FileReader</li>
      <li>InputStreamReader</li>
      <li>BufferedReader</li>
    </ul>
  </li>
</ul>

<p><strong>小结</strong>：只要最高级的Reader、Writer、InputStream、OutputStream，完成flush\close，则无需向下递归；</p>

<p><strong>备注</strong>：上述InputStream、OutputStream、Reader、Writer，之间关系的图形化表述；（TODO：需要一张图来表示其中的联系）</p>

<h2 id="fileinputstream--fileoutputstream">FileInputStream &amp; FileOutputStream</h2>

<p>完整示例代码如下：</p>

<pre><code>package com.github.ningg;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;

public class FileInputStreamAndFileOutputStream {

	public static void main(String[] args) throws IOException {
		
		String srcFilepath = "E:/1.log";
		String destFilepath = "E:/1byte.log";
		
		FileInputStream srcInputStream = new FileInputStream(srcFilepath);
		FileOutputStream destOutputStream = new FileOutputStream(destFilepath);
		
		byte[] bufByte = new byte[1000];
		int bufLen = -1;
		
		while( (bufLen = srcInputStream.read(bufByte)) != -1 ){
			destOutputStream.write(bufByte, 0, bufLen);
			System.out.println(Arrays.toString(bufByte));
		}
		
		destOutputStream.flush();
		destOutputStream.close();
		srcInputStream.close();
		
	}
}
</code></pre>

<h2 id="bufferedinputstream--bufferedoutputstream">BufferedInputStream &amp; BufferedOutputStream</h2>

<p>完整示例代码如下：</p>

<pre><code>package com.github.ningg;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class BufferedInputStreamAndBufferedOutputStream {

	public static void main(String[] args) throws IOException {
		
		String srcFile = "E:/1.log";
		String destFile = "E:/1BufByte.log";
		
		FileInputStream fileInputStream = new FileInputStream(srcFile);
		FileOutputStream fileOutputStream = new FileOutputStream(destFile);
		
		BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
		BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream);
		
		byte[] byteBuf = new byte[1000];
		int byteLen = -1;
		
		while( (byteLen = bufferedInputStream.read(byteBuf)) != -1 ){
			bufferedOutputStream.write(byteBuf, 0, byteLen);
		}
		
		bufferedOutputStream.flush();
		bufferedOutputStream.close();
		bufferedInputStream.close();
		
	}
}
</code></pre>

<h2 id="section-2">参考来源</h2>

<ul>
  <li><a href="http://docs.oracle.com/javase/tutorial/essential/io/">Java Tutorials：Basic I/O</a></li>
  <li><a href="http://www.tutorialspoint.com/java/java_files_io.htm">Java-Streams, Files and I/O</a></li>
</ul>

<h2 id="todo">TODO</h2>

<p>几点：</p>

<ul>
  <li><a href="http://docs.oracle.com/javase/tutorial/essential/io/">Java Tutorials：Basic I/O</a>，需要阅读一遍，当前没有阅读；</li>
  <li>File相关的Stream机制，特别是，为什么有Reader、又有Stream？底层实现有什么差异？适用场景？</li>
  <li>buffered机制中，skip、mark、reset等方法的用途？</li>
</ul>



        <div id="disqus_container">
            <div style="margin-bottom:20px" class="right">
				<wb:share-button appkey="2306590132" addition="simple" type="button" ralateUid="2356527183"></wb:share-button>
            </div>
            <!--<a href="#" class="comment" onclick="return false;">点击查看评论</a>-->
            <div id="disqus_thread"></div>
        </div>
    </div>

	
    <div class="sidenav">
		<iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=2356527183&verifier=1ccfb61e&colors=d6f3f7,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe>
    </div>

</div>

<script src="/js/post.js" type="text/javascript"></script>


	<div id="gotoTop">Top</div>


    <!--*********************************************************-->
    <!--****** 宝贝儿，看见这个时候，删掉下面的统计代码哦~ ******-->
    <!--*********************************************************-->
	<script>
	  (function(i,s,o,g,r,a,m){
		  i['GoogleAnalyticsObject']=r;i[r]=i[r] || function(){
			(i[r].q=i[r].q||[]).push(arguments)}, i[r].l=1*new Date();
			a=s.createElement(o), m=s.getElementsByTagName(o)[0];
			a.async=1;
			a.src=g;
			m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-48535193-1', 'ningg.github.io');
	  ga('send', 'pageview');
	</script>
    
	
    <script type="text/javascript">
		function gotoTop(min_height){
			$("#gotoTop").click(
				function(){$('html,body').animate({scrollTop:0},700);
			}).hover(
				function(){$(this).addClass("hover");},
				function(){$(this).removeClass("hover");
			});
			min_height ? min_height = min_height : min_height = 600;
			$(window).scroll(function(){
				
				var s = $(window).scrollTop();
				
				if( s > min_height){
					$("#gotoTop").fadeIn(100);
				}else{
					$("#gotoTop").fadeOut(200);
				};
			});
		};
		gotoTop();

        $(function(){
            $('.home-follow').click(function(e){
                e.preventDefault();

                if($('.home-contact').is(':visible')){
                    $('.home-contact').slideUp(100);
                }else{
                    $('.home-contact').slideDown(100);
                }
            });
        })

    </script>
</body>
</html>
