<!DOCTYPE html>
<html xmlns:wb="http://open.weibo.com/wb">
<head>
    <!--   Author: NingG   -->
    <meta charset="utf-8" />
	<meta property="wb:webmaster" content="7ea7f3d5f3edad6a" />
    <title>Java并发 - 并发 1 | ningg.top</title>
    <meta name="author" content="NingG" />
    <meta name="renderer" content="webkit">
    <meta name="description" content=" Java编程思想  " />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">

    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="" />
	
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
	<script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
	
    <div class="home-menu">
        <div class="home-icon-con">
            <a class="home-menu-icon" href="/">NingG</a>
            <a class="home-follow" href="#" title="Contact Me">+</a>
        </div>
        <div class="home-contact">
            <a href="http://weibo.com/ggningg/" target="_blank" style="margin-left:-5px;"><img src="http://www.weibo.com/favicon.ico" alt="" width="25"/></a>
            <a href="http://www.douban.com/people/ggningg/" target="_blank" style="text-align:center;"><img src="http://www.douban.com/favicon.ico" alt="" width="22"/></a>
			<a href="http://github.com/ningg" alt="" target="_blank" style="text-align:right;"><img src="/images/icon-cube-smaller.png" width="22"/></a>
        </div>
    </div>

    <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/java-concurrency-2" title="Java并发 - 并发 1">Java并发 - 并发 1</a></h1>
        <p class="entry-date">2012-08-18</p>
        <h2 id="section">21.1小节：为什么要学习并发？</h2>

<p>总结起来就是两点：</p>

<ul>
  <li><code>速度</code></li>
  <li><code>设计可管理性</code></li>
</ul>

<p>速度非常容易理解，我举个例子就可以说明问题：</p>

<blockquote>
  <p>现在你是《仙剑奇侠传》的主程，需要在用户开大游戏时，渲染一副非常美丽的场景。如下图所示：有花、有草、天空、人物等等，这些物体在程序中就是一个个独立的数据结构（本质就是不同的像素点集合）。你需要按照一定的顺序将它们渲染出来（比如先渲染人物、然后是大地、然后是花花草草、然后是天空、然后是光线等等）。你会如何初始化？先自己思考1分钟。</p>
</blockquote>

<p>如果让一个初学者回答，一般而言会按照这个物体在游戏中的重要程度一个一个按顺序渲染，而这个想法就是顺序编程的思维。那么，问题来了：挖掘机……噗，不对，假如每个物体的渲染速度都为10ms，刚才那些元素总和为1000个。那么，等用户可以看到完整的效果就需要10s，10s 是什么概念？想想平时打开网页，如果超过5s 还没有内容，你是不是立即就关闭了？那么这里的10s 简直就是不可理喻。</p>

<p>而这就是并发要解决的第一个问题：<strong>速度</strong>，或者称为<strong>性能</strong></p>

<p>现在一个高手来了，它将这1000个元素按照重要程度做一个排序（当然，这都是离线搞好的），然后“同时”去完成 N（假如为10） 个元素的渲染。那么，看到完整的效果就需要1s。为什么可以这样做呢？因为现在机器无论是 Server 端还是 Client 端，都有2-8核的处理器，只要我们充分压榨它们的性能，就能让程序跑的更快。当然，<strong>这个例子是最最最最简单的，而且它有个重要特征就是每个元素都是独立的。如果它们之间有关联，情况就会更复杂，后面我们再讨论</strong></p>

<p>速度问题说过了，再说下设计可管理性。那么，什么是<strong>设计可管理性</strong>呢？</p>

<p>仔细看了21.1.2小节，但是讲的很晦涩。我尝试着说下自己的看法吧。设计可管理性可以认为是程序的结构。比如广泛使用的消息系统，一个 server，多个 client。如果你不使用并发，先给 client1发送消息，然后 client2……但是如果在这个期间clientN 对刚才那个消息的内容做了改变怎么办？还是举个例子：</p>

<blockquote>
  <p>最典型的是扣费系统，现在 server 总余额是1000，10个 client，server 计算后决定给每个 client分100。但是client6没分到钱之前余额花光了，它现在要花费180，你分给100肯定不够。那么，server 如何办？？是重新收回前面 client 分到的钱还是忽略client6的请求，继续给100？</p>
</blockquote>

<p>这个问题相当头疼，因为这样你需要在服务器端写很多繁琐的代码。但是如果有了并发，你可以在让不同的线程负责不同的模块，比如有个线程专门处理分开过程中 client 的响应，然后更改总余额。比如刚才的例子，如果 client 在分开过程中请求说“我需要180”，这个线程会根据情况（server 这次都给100，client6要180），那么我就可以多给 client6一点，少给后面一点。如果后面不够，我再从前面匀一点出来。</p>

<p>总之，有了并发。可以让<strong>程序的组织更加简单且具有伸缩性</strong>。当然，这些是我的片面理解，不一定正确。如果你对这块有更深入的了解，欢迎指正~~~~~</p>

<h2 id="section-1">21.2小节：并发的最基本使用</h2>

<p>上面解答了并发的好处，那么将下来就要讲讲如何使用并发。而第21.2小节其实就是讲解如何使用并发的。show time…</p>

<h3 id="section-2">1. 定义任务</h3>

<p>线程是用来干活的，那么你需要跟线程说“线程，你把这些活做一下。”——描述线程需要做什么东西的过程，就是定义任务。<strong>这可以由实现 Runnable 接口中的 run()方法来实现</strong>。下面是例子：</p>

<pre><code>public class LiftOff implements Runnable { // 实现 Runnable 接口

	protected int countDown = 10; //Default
	private static int taskCount = 0;
	private final int id = taskCount++;
	public LiftOff() {}
	public LiftOff(int countDown) {
		this.countDown = countDown;
	}
	
	public String status() {
		return "#Thread id: " + id + ", time: " + (countDown &gt; 0 ? countDown : "Liftoff!");
	}
	
	@Override
	public void run() { // 定义需要做的任务
		while(countDown-- &gt; 0) {
		System.out.println(status());
		Thread.yield();
		}
	}
}
</code></pre>

<p>Tips：</p>

<blockquote>
  <p><code>Thread.yield()</code>需要解释一下，它是对<strong>线程调度器</strong>（Java 线程机制的一部分，可以将 CPU 从一个线程转移到另一个线程）的一种建议，它在声明：”我已经执行完生命周期中最重要的部分了，此刻可以切换给别的任务，让它们执行吧（我不知道它们重要的部分有没有执行）。”但是<strong>这是一种建议，线程调度器不一定会执行</strong>（还记得吗，finalize() 方法也不保证一定执行，原因忘了的可以再去翻翻）</p>
</blockquote>

<p>这里有必要说明一下<strong>任务和线程</strong>的概念：</p>

<p><strong>任务和线程是各自独立的</strong>。在刚才的 demo 中，我们实现了 Runnable 接口，并重写了 run()方法，但这只是<strong>定义任务</strong>，和线程没有任何关系。<strong>要实现线程行为，必须显式地将一个任务附着到线程上</strong>。具体的区别请学习21.2.10小节，P669页。下面是我对21.2.10小节的总结：</p>

<blockquote>
  <p><strong>任务就是描述这个工作怎样做才能完成，而线程相当于一个工人，它只负责机械地执行交给他的任务</strong>。从宏观上看，任务是我们占主导的，而线程则是一个黑盒，我们只能把任务提交，至于他怎么干活我们是不知道的。所以，在描述如何执行工作时，我们使用术语——任务；在引用到驱动任务的具体机制时，才使用术语——线程。在99.9%的情况下，我们根本就不需要提到线程，因为 <strong>Executor 就可以帮我们管理一切线程工作</strong>。我们只需要关注如何描述任务即可。</p>
</blockquote>

<p>Tips:</p>

<blockquote>
  <p>因为 Java 的线程机制是基于来自 C 语言的低级 p 线程方式（pthread 和 fork），所以最好去学习一下 pthread 的相关知识。</p>
</blockquote>

<h3 id="thread-">2. Thread 类</h3>

<p>将 Runnable 定义的任务依附到线程的一般做法是把它提交给一个 Thread 构造器。下面是例子：</p>

<pre><code>public class BasicThreads {
	public static void main(String[] args) {
		Thread thread = new Thread(new LiftOff());
		thread.start();
		System.out.println("Waiting for LiftOff");
	}
}
</code></pre>

<p>Thread 构造器只需要一个 Runnable 对象。调用 start()方法为该线程执行必需的初始化操作，然后调用 Runnable 接口的 run()方法，以便在这个新线程中启动该任务。注意执行结果，在 start()方法执行时，虽然调用了 run()方法，但是 start()迅速返回了（先输出了 Waiting for LiftOff），这是因为：<strong>main()方法是一个线程，LiftOff.run()是新建的另外一个线程，所以两个线程可以同时执行</strong>。</p>

<p>思考：直接使用<code>new LiftOff().start()</code>可以启动新的线程吗？</p>

<h3 id="executor--thread">3. 使用 Executor 管理 Thread</h3>

<p><code>java.util.concurrent</code> 中的执行器（Executor）将为你管理 Thread 对象，从而简化了并发编程。什么意思呢？</p>

<p>本来任务需要提交给 Thread 才能执行，但是任务比较多的情况下，Thread 也相应的有很多，不容易进行统一的管理。基于这种情况，Java 提供了 concurrent 包中的 Executor。它其实就是任务和运行线程的客户端的一个中介。因为它管理了 Thread 对象，所以即使有多个任务，都可以统一由 Executor 来管理相应的 Thread 对象。<strong>非常常见的情况是，单个的 Executor 被用来创建和管理系统中所有的任务</strong>。</p>

<p>下面举个例子来说明吧。在完全使用 Thread 的时候：</p>

<pre><code>public class MoreBasicThreads {
	public static void main(String[] args) {
		for(int i = 0; i &lt; 5; i++) {
			new Thread(new LiftOff()).start();
		}
		System.out.println("Waiting for LiftOff");
	}
}
</code></pre>

<p>如果现在出现意外状况，需要把线程全部关闭。那么你必须对5个Thread 对象进行操作。推而广之，越多的任务会带来更高的后续代价。但是我们尝试用 Executor 来完成同样的工作：</p>

<pre><code>public class CachedThreadPool {
  public static void main(String[] args) {
	ExecutorService exec = Executors.newCachedThreadPool();
	for(int i = 0; i &lt; 5; i++) {
	  exec.execute(new LiftOff());
	}
	exec.shutdown();
  }
}
</code></pre>

<p>我们可以看到，我们拿到一个 ExecutorService 来管理所有的 Thread 对象，在执行完所有的任务后，只需要调用一个 shutdown()即可关闭所有管理的 Thread 对象，非常优雅。</p>

<p>总结一下，Executor 管理的 Thread 中，常见的类型有：</p>

<ul>
  <li><code>CachedThreadPool</code>：创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程</li>
  <li><code>FixedThreadPool</code>：固定数量的线程池，创建时需要一定时间去初始化。后续不需要付出创建线程的代价</li>
  <li><code>SingleThreadPool</code>：FixedThreadPool 的特例，但是也有特殊之处（它提供了一种重要的并发保证，其他线程不会被并发调用，这会改变任务的加锁需求）</li>
</ul>

<h3 id="callable-">4. 任务有返回值？Callable 接口来帮忙！</h3>

<p>从标题我们就掌握了这一个小节，因为 Runnable 需要重写的 run()方法返回值是 void，所以有返回值的情况，使用 Callable 接口的 call()即可。有2点需要注意：</p>

<ul>
  <li>call()返回值的类型参数是泛型</li>
  <li>使用 ExecutorService 管理的话，需要通过 submit()方法调用（而 run()是 使用 ExecutorService.execute()方法）</li>
</ul>

<p>一个例子：</p>

<pre><code>import java.util.ArrayList;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

class TaskWithResult implements Callable&lt;String&gt; {

  private int id;

  public TaskWithResult(int id) {
	this.id = id;
  }

  @Override
  public String call() {
	return "result of TaskWithResult: " + id;
  }
}

public class CallableDemo {
  public static void main(String[] args) {
	ExecutorService exec = Executors.newCachedThreadPool();
	ArrayList&lt;Future&lt;String&gt;&gt; result = new ArrayList&lt;Future&lt;String&gt;&gt;();
	for (int i = 0; i &lt; 10; i++) {
	  result.add(exec.submit(new TaskWithResult(i)));
	}
	
	for(Future&lt;String&gt; fs : result) {
	  try {
		System.out.println(fs.get());
	  } catch (InterruptedException | ExecutionException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	  } finally {
		exec.shutdown();
	  }
	}
  }
}/*output:
result of TaskWithResult: 0
result of TaskWithResult: 1
result of TaskWithResult: 2
result of TaskWithResult: 3
result of TaskWithResult: 4
result of TaskWithResult: 5
result of TaskWithResult: 6
result of TaskWithResult: 7
result of TaskWithResult: 8
result of TaskWithResult: 9
*/
</code></pre>

<p>这段代码非常好懂，但是可能多了个 Future 对象，我来解释一下。</p>

<blockquote>
  <p>ExecutorService.submit()方法会返回 Future 对象，它用 Callable 返回结果的特定类型进行了参数化。可以用 isDone()来查询 Future 是否完成——当任务完成时，它具有一个结果，可以调用 get()方法来获取该结果；如果不使用 isDone()而是直接用 get()去拿结果，那么在结果没有返回的这段时间内，get()将阻塞，直至结果返回。通常情况下，可以使用 isDone()或者具有超时时间的 get()来查询该任务是否完成。</p>
</blockquote>

<h3 id="section-3">5. 线程干活累了，想睡会</h3>

<p>这个直接上例子：</p>

<pre><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class SleepingTask extends LiftOff {
  @Override
  public void run() {
	try {
	  while(countDown-- &gt; 0) {
		System.out.println(status());
		// Old-style:
		// Thread.sleep(100);
		// Java SE5/6-style:
		TimeUnit.MILLISECONDS.sleep(100);
	  }
	} catch(InterruptedException e) {
	  System.err.println("Interrupted");
	}
  }
  
  public static void main(String[] args) {
	ExecutorService exec = Executors.newCachedThreadPool();
	for(int i = 0; i &lt; 5; i++) {
	  exec.execute(new SleepingTask());
	}
	System.out.println("Waiting For LiftOff");
	exec.shutdown();
  }
}
</code></pre>

<p>这里需要注意的有两点：</p>

<ul>
  <li>对 sleep()的调用可能抛出 InterruptedException 异常（很容易想象，你在睡觉的时候也会被闹钟打断。这是调用 Thread的 interrupt()方法），并且你可以看到，它在 run()中被捕获。<strong>因为异常不能跨线程传播回 main(因为线程之间除了共享资源，其他都是线程私有的)，所以你必须在本地处理所有在任务内部产生的异常，谨记。</strong></li>
  <li><code>sleep()</code> VS <code>TimeUnit.MILLISECONDS.sleep()</code>。具体可以参照文档，但是更推荐直接看源码。源码其实也非常简单，但是为什么这样做？值得我们去思考，尤其推荐结合枚举那一章来学习 TimeUnit 源码，味道极佳：）</li>
</ul>

<h3 id="section-4">6. 让步</h3>

<p>前面有个地方提到了<code>Thread.yield()</code>，这里具体说明一下这个方法的使用场景和需要注意的地方。</p>

<blockquote>
  <p>如果知道已经完成了在 run()方法的循环中的一次迭代过程中所需的工作，就可以给线程调度机制一个暗示：我的工作已经差不多了，可以让别的线程使用 CPU 了。这个暗示将通过调用 yield()方法来作出（不过这只是一个提示，没有任何机制保证它将会被采纳）。当调用 yield()时，其实是在建议线程调度器去调度具有相同优先级的其他线程工作。
但是大体上，对于任何重要的控制或在调整应用时，都<strong>不能依赖 yield()</strong>。实际上，yied()经常被误用。所以使用的时候一定要非常谨慎！</p>
</blockquote>

<h3 id="section-5">7. 后台线程</h3>

<p>这个作者在总结中明确指出“后台线程几乎不是一种好的思想，非后台的 Executor 通常是一种更好的方式，因为 Executor 控制的所有任务可以同时被管理”。顾名思义，后台线程就是在后台运行的。类似 shell 的 <code>&amp;</code>，更严谨的定义是这样的：</p>

<blockquote>
  <p>后台线程是指在程序运行的时候在后台提供一种通用服务的线程，并且<strong>这种线程并不属于程序中不可或缺的部分（意思是非必要）</strong>。因此，<strong>当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程</strong>。所以，只要有任何非后台线程还在运行，程序就不会终止。<strong>main()就是一个非后台线程</strong></p>
</blockquote>

<p>示例代码：</p>

<pre><code>import java.util.concurrent.TimeUnit;

public class SimpleDaemons implements Runnable {
  @Override
  public void run() {
	try {
	  while (true) {
		TimeUnit.MILLISECONDS.sleep(100);
		System.out.println(Thread.currentThread() + " " + this);
	  }
	} catch (InterruptedException e) {
	  System.out.println("sleep() interrupted");
	  e.printStackTrace();
	}
  }
  
  public static void main(String[] args) throws InterruptedException {
	for(int i = 0; i &lt; 10; i++) {
	  Thread daemon = new Thread(new SimpleDaemons());
	  daemon.setDaemon(true); // Must call before start();
	  daemon.start();
	}
	System.out.println("All daemons started");
	TimeUnit.MILLISECONDS.sleep(275); //不断调整这个时间，就能理解上面那段话了。
  }
}
</code></pre>

<p>设置<strong>后台线程</strong>有一个注意点：必须在 start()之前设定。</p>

<h3 id="section-6">8. 加入一个线程</h3>

<p>这个小节看的很恶心，主要是翻译的太晦涩了，根本看不懂。很简单的意思愣是翻译的看不懂，也是醉了。。我总结一下这个小节吧。</p>

<p>现在有2个线程A 和 B，现在想在执行 B 的过程中加入 A，那么就可以在 B 中调用 A.join()，那么在 B 中就会等待 A 执行完毕才继续运行。下面是例子：</p>

<pre><code>class Sleeper extends Thread {
  private int duration;
  public Sleeper(String name, int sleepTime) {
	super(name);
	duration = sleepTime;
	start();
  }
  
  public void run() {
	try {
	  sleep(duration);
	} catch(InterruptedException e) {
	  System.out.println(getName() + " was interrupted. " + "isInterrupted(): " + isInterrupted());
	  return ;
	}
	System.out.println(getName() + " has awakened");
  }
}

class Joiner extends Thread {
  private Sleeper sleeper;
  public Joiner(String name, Sleeper sleeper) {
	super(name);
	this.sleeper = sleeper;
	start();
  }
  
  public void run() {
	try {
	  sleeper.join();
	} catch(InterruptedException e) {
	  System.out.println("Interrpted");
	}
	System.out.println(getName() + " join completed");
  }
}

public class Joining {
  public static void main(String[] args) {
	Sleeper sleepy = new Sleeper("Sleepy", 1500);
	Sleeper grumpy = new Sleeper("grumpy", 1500);
	
	Joiner dopey = new Joiner("Dopey", sleepy);
	Joiner doc = new Joiner("Doc", grumpy);
	
	grumpy.interrupt();
  }
}/*output:
grumpy was interrupted. isInterrupted(): false
Doc join completed
Sleepy has awakened
Dopey join completed
*/
</code></pre>

<p>认真看下，其实就是这个意思。我是按宏替换来理解的，把 join()的那个线程的代码给替换进来。。。。</p>

<p>Tips:</p>

<blockquote>
  <p>代码中有一个需要注意的是interrput()的调用结果：isInterrupted(): false，明明这个线程被我们 interrupt()了呀，为什么状态是 false？原来是因为当调用 interrupt()的时候，将给这个线程设定一个标志，表明该线程已经被中断。然而，<strong>异常被捕获的时候将清理这个标志</strong>，所以在 catch 子句中，这个标志被识别为 false。</p>
</blockquote>

<h3 id="section-7">9. 呀，抛出异常肿么办？</h3>

<p>先来个小测试，看看下面的代码输出如何？</p>

<pre><code> import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
 public class ExceptionThread implements Runnable {
   @Override
   public void run() {
	 throw new RuntimeException();
   }
 
   public static void main(String[] args) {
	 try {
	   ExecutorService exec = Executors.newCachedThreadPool();
	   exec.execute(new ExceptionThread());
	 } catch (Exception e) {
	   System.out.println("catch run() exception...");
	 }
   }
 }
</code></pre>

<p>想好的话，实际运行一下这个程序。答案竟然是没有捕获到，直接抛到 console 中！！！为什么呢？</p>

<blockquote>
  <p>前面我们说过，<strong>线程之间是无法传播异常</strong>（上面线程干活累了，想睡会小节中提到过），所以抛出的异常直接抛给 JVM 并打印到 console 中。</p>
</blockquote>

<p>当然，在 Java SE5以后，可以用 Executor 来解决这个问题。如下所示：</p>

<pre><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;

class ExceptionThread2 implements Runnable {
  @Override
  public void run() {
	Thread t = Thread.currentThread();
	System.out.println("run() by " + t);
	System.out.println("eh = " + t.getUncaughtExceptionHandler());
	throw new RuntimeException();
  }
}

class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {
  @Override
  public void uncaughtException(Thread t, Throwable e) {
	System.out.println("caught " + e);
  }
}

class HandlerThreadFactory implements ThreadFactory {
  @Override
  public Thread newThread(Runnable r) {
	System.out.println(this + " creating new Thread");
	Thread t = new Thread(r);
	System.out.println("created " + t);
	t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
	System.out.println("eh = " + t.getUncaughtExceptionHandler());
	return t;
  }
}

public class CaptureUncaughtException {
  public static void main(String[] args) {
	ExecutorService exec = Executors.newCachedThreadPool(new HandlerThreadFactory());
	exec.execute(new ExceptionThread2());
  }
}/*output:
concurrency.HandlerThreadFactory@5c647e05 creating new Thread
created Thread[Thread-0,5,main]
eh = concurrency.MyUncaughtExceptionHandler@33909752
run() by Thread[Thread-0,5,main]
eh = concurrency.MyUncaughtExceptionHandler@33909752
concurrency.HandlerThreadFactory@5c647e05 creating new Thread
created Thread[Thread-1,5,main]
eh = concurrency.MyUncaughtExceptionHandler@359d9ad4
caught java.lang.RuntimeException
*/
</code></pre>

<p>不知道为何我的输出多了一个线程Thread-1,5,main的创建。。。留待明天解决。。。。。。</p>

<p>在实际使用时，可以按照具体情况重写 uncaughtException()来逐个处理不同的异常，如果在代码中都只使用相同的异常处理器，就可以设置 Thread 的静态域：</p>

<pre><code>public class SettingDefaultHandler {
  public static void main(String[] args) {
	Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
	ExecutorService exec = Executors.newCachedThreadPool();
	exec.execute(new ExceptionThread());
  }
}
</code></pre>

<p>这个处理器只在<strong>不存在线程专有的未捕获异常处理器的情况下才会被调用</strong>。具体的步骤是：</p>

<ol>
  <li>系统会检查线程专有版本</li>
  <li>如果没有发现，则检查线程组是否有其专有的 uncaughtException()方法（Java SE5以后完全可以认为没有线程组的概念，因为被 Executor 完全取代），</li>
  <li>如果也没有，再调用 defaultUncaughtExceptionHandler。</li>
</ol>



        <div id="disqus_container">
            <div style="margin-bottom:20px" class="right">
				<wb:share-button appkey="2306590132" addition="simple" type="button" ralateUid="2356527183"></wb:share-button>
            </div>
            <!--<a href="#" class="comment" onclick="return false;">点击查看评论</a>-->
            <div id="disqus_thread"></div>
        </div>
    </div>

	
    <div class="sidenav">
		<iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=2356527183&verifier=1ccfb61e&colors=d6f3f7,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe>
    </div>

</div>

<script src="/js/post.js" type="text/javascript"></script>


	<div id="gotoTop">Top</div>


    <!--*********************************************************-->
    <!--****** 宝贝儿，看见这个时候，删掉下面的统计代码哦~ ******-->
    <!--*********************************************************-->
	<script>
	  (function(i,s,o,g,r,a,m){
		  i['GoogleAnalyticsObject']=r;i[r]=i[r] || function(){
			(i[r].q=i[r].q||[]).push(arguments)}, i[r].l=1*new Date();
			a=s.createElement(o), m=s.getElementsByTagName(o)[0];
			a.async=1;
			a.src=g;
			m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-48535193-1', 'ningg.github.io');
	  ga('send', 'pageview');
	</script>
    
	
    <script type="text/javascript">
		function gotoTop(min_height){
			$("#gotoTop").click(
				function(){$('html,body').animate({scrollTop:0},700);
			}).hover(
				function(){$(this).addClass("hover");},
				function(){$(this).removeClass("hover");
			});
			min_height ? min_height = min_height : min_height = 600;
			$(window).scroll(function(){
				
				var s = $(window).scrollTop();
				
				if( s > min_height){
					$("#gotoTop").fadeIn(100);
				}else{
					$("#gotoTop").fadeOut(200);
				};
			});
		};
		gotoTop();

        $(function(){
            $('.home-follow').click(function(e){
                e.preventDefault();

                if($('.home-contact').is(':visible')){
                    $('.home-contact').slideUp(100);
                }else{
                    $('.home-contact').slideDown(100);
                }
            });
        })

    </script>
</body>
</html>
