<!DOCTYPE html>
<html xmlns:wb="http://open.weibo.com/wb">
<head>
    <!--   Author: NingG   -->
    <meta charset="utf-8" />
	<meta property="wb:webmaster" content="7ea7f3d5f3edad6a" />
    <title>Ganglia 3.6.1：Ganglia Monitoring Daemon v3.6.1 Configuration | ningg.top</title>
    <meta name="author" content="NingG" />
    <meta name="renderer" content="webkit">
    <meta name="description" content=" Ganglia官方文档：Gmond的配置信息  " />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">

    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="" />
	
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
	<script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
	
    <div class="home-menu">
        <div class="home-icon-con">
            <a class="home-menu-icon" href="/">NingG</a>
            <a class="home-follow" href="#" title="Contact Me">+</a>
        </div>
        <div class="home-contact">
            <a href="http://weibo.com/ggningg/" target="_blank" style="margin-left:-5px;"><img src="http://www.weibo.com/favicon.ico" alt="" width="25"/></a>
            <a href="http://www.douban.com/people/ggningg/" target="_blank" style="text-align:center;"><img src="http://www.douban.com/favicon.ico" alt="" width="22"/></a>
			<a href="http://github.com/ningg" alt="" target="_blank" style="text-align:right;"><img src="/images/icon-cube-smaller.png" width="22"/></a>
        </div>
    </div>

    <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/ganglia-gmond-conf" title="Ganglia 3.6.1：Ganglia Monitoring Daemon v3.6.1 Configuration">Ganglia 3.6.1：Ganglia Monitoring Daemon v3.6.1 Configuration</a></h1>
        <p class="entry-date">2014-11-22</p>
        <blockquote>
  <p>原文地址：<a href="http://sourceforge.net/projects/ganglia/files/">ganglia-3.6.1(ganglia monitoring core)</a>的源码包中gmond/gmond.conf.html文件。</p>
</blockquote>

<h2 id="name">NAME</h2>

<p><strong>gmond.conf</strong> - configuration file for ganglia monitoring daemon (<strong>gmond</strong>)</p>

<h2 id="description">DESCRIPTION</h2>

<p>The gmond.conf file is used to configure the ganglia monitoring daemon (gmond) which is part of the <strong>Ganglia Distributed Monitoring System</strong>.</p>

<h2 id="sections-and-attributes">SECTIONS AND ATTRIBUTES</h2>

<p>All sections and attributes are case-insensitive. For example, <code>name</code> or <code>NAME</code> or <code>Name</code> or <code>NaMe</code> are all equivalent.</p>

<p>Some sections can be included in the configuration file <code>multiple</code> times and some sections are <code>singular</code>. For example, you can have only one <code>cluster</code> section to define the attributes of the cluster being monitored; however, you can have multiple <code>udp_recv_channel</code> sections to allow gmond to receive message on multiple UDP channels.</p>

<p><strong>notes(ningg)</strong>：gmond.conf配置文件，说几点：</p>

<ul>
  <li>整个配置文件，分为：多个section，每个section下有多个attribute；</li>
  <li>section和attribute是case-insensitive的；</li>
  <li>在整个配置文件中，有的section只能有一个，有的section可以有多个；</li>
</ul>

<h3 id="cluster">cluster</h3>

<p>There should <strong>only be one cluster section</strong> defined. This section controls how gmond reports the attributes of the cluster that it is part of.</p>

<p>The cluster section has four attributes: <code>name</code> , <code>owner</code> , <code>latlong</code> , <code>url</code>.</p>

<p>For example,</p>

<pre><code>cluster {
    name = "Millennium Cluster"
    owner = "UC Berkeley CS Dept."
    latlong = "N37.37 W122.23"
    url = "http://www.millennium.berkeley.edu/";
}
</code></pre>

<ul>
  <li>The <code>name</code> attributes specifies the name of the cluster of machines. 
    <ul>
      <li>When the node is polled for an XML summary of cluster state, this name is inserted in the CLUSTERelement. </li>
      <li>The gmetad polling the node uses this value to name the directory where the cluster data RRD files are stored. </li>
      <li>It supersedes a cluster name specified in the  <code>gmetad.conf</code> configuration file.</li>
      <li>The multicast address and the UDP port specify whether a host is on the cluster.</li>
      <li>The <code>name</code> attribute acts just as an identifier when polling.</li>
    </ul>
  </li>
  <li>The <code>owner</code> tag specifies the administrators of the cluster. 
    <ul>
      <li>The pair <code>name/owner</code> should be unique to all clusters in the world.</li>
    </ul>
  </li>
  <li>The <code>latlong</code> attribute is the latitude and longitude GPS coordinates of this cluster on earth. Specified to 1 mile accuracy with two decimal places per axis in decimal.</li>
  <li>The <code>url</code> for more information on the cluster. Intended to give purpose, owner, administration, and account details for this cluster.</li>
</ul>

<p>There directives directly control the XML output of <strong>gmond</strong>. For example, the cluster configuration example above would translate into the following XML.</p>

<pre><code>&lt;CLUSTER NAME="Millennium Cluster" OWNER="UC Berkeley CS Dept."
	LATLONG="N37.37 W122.23" URL="http://www.millennium.berkeley.edu/"&gt;
...
&lt;/CLUSTER&gt;
</code></pre>

<p><strong>notes(ningg)</strong>：gmond收集的数据，以什么形式上传给gmetad？以什么形式与同一cluster内的gmond进行共享？XML形式是怎么回事？什么地方传输？还有，这个gmond属于这一cluster，那其他同一cluster中的gmond是否需要保持cluster section的完全一致？而下文中，同一个cluster对应的广播地址，仅仅用于cluster内部节点之间的信息共享？还需要验证XML中的cluster属性是否一致？</p>

<h3 id="host">host</h3>

<p>The host section provides information the host running this instance of gmond. Currently only the <strong>location</strong> string attribute is supported. Example:</p>

<pre><code>host {
    location = "1,2,3"
}
</code></pre>

<p>The numbers represent <strong>Rack</strong>, <strong>Rank</strong> and <strong>Plane</strong> respectively.</p>

<h3 id="globals">globals</h3>

<p>The <strong>globals</strong> section controls general characteristics of <strong>gmond</strong> such as whether is should daemonize, what user it should run as, whether is should send/receive date and such. The globals section has the following attributes: 
<code>daemonize</code> , <code>setuid</code> , <code>user</code> , <code>debug_level</code> , <code>mute</code> , <code>deaf</code> , <code>allow_extra_data</code> , <code>host_dmax</code> , <code>host_tmax</code> , <code>cleanup_threshold</code> , <code>gexec</code> , <code>send_metadata_interval</code> , <code>module_dir</code>.</p>

<p><strong>notes(ningg)</strong>：<strong>globals</strong> section设定对象是 gmond deamon itself.</p>

<p>For example,</p>

<pre><code>globals {
    daemonize = true
    setuid = true
    user = nobody
    host_dmax = 3600
    host_tmax = 40
}
</code></pre>

<ul>
  <li>The <code>daemonize</code> attribute is a <code>boolean</code>. 
    <ul>
      <li>When <code>true</code>, gmond will daemonize. </li>
      <li>When <code>false</code>, gmond will run in the foreground.</li>
    </ul>
  </li>
</ul>

<p><strong>notes(ningg)</strong>：在配置文件中，boolean数据，的取值可以为：<code>yes</code>/<code>true</code>/<code>on</code>，<code>no</code>/<code>false</code>/<code>off</code>。</p>

<ul>
  <li>The <code>setuid</code> attribute is a <code>boolean</code>. 
    <ul>
      <li>When <code>true</code>, gmond will set its effective UID to the uid of the user specified by the <code>user</code> attribute. </li>
      <li>When <code>false</code>, gmond will not change its effective user.</li>
    </ul>
  </li>
  <li>The <code>debug_level</code> is an <code>integer</code> value. 
    <ul>
      <li>When set to <code>zero</code> (0), gmond will run normally. </li>
      <li>A <code>debug_level</code> greater than zero will result in gmond running in the foreground and outputting debugging information. </li>
      <li>The higher the <code>debug_level</code> the more verbose the output.</li>
    </ul>
  </li>
  <li>The <code>mute</code> attribute is a <code>boolean</code>. 
    <ul>
      <li>When <code>true</code>, gmond will <code>not send</code> data regardless of any other configuration directives.</li>
      <li>当设置<code>mute=true</code>时，gmond不会向任何gmond发送UDP package，但仍然会响应gmetad的请求；</li>
      <li>当设置<code>mute=true</code>时，gmond不会统计自己的metric，这也合理，因为这样的node专门用于收集其他所有节点的metridc；</li>
    </ul>
  </li>
  <li>The <code>deaf</code> attribute is a <code>boolean</code>. 
    <ul>
      <li>When <code>true</code>, gmond will <code>not receive</code> data regardless of any other configuration directives.</li>
    </ul>
  </li>
  <li>The <code>allow_extra_data</code> attribute is a <code>boolean</code>. 
    <ul>
      <li>When <code>false</code>, gmond will not send out the <code>EXTRA_ELEMENT</code> and <code>EXTRA_DATA</code> parts of the XML. </li>
      <li>This might be useful if you are using your own frontend to the metric data and will like to save some bandwith.</li>
    </ul>
  </li>
</ul>

<p><strong>notes(ningg)</strong>：XML中<code>EXTRA_ELEMENT</code> and <code>EXTRA_DATA</code>中存储了哪些信息？</p>

<ul>
  <li>The <code>host_dmax</code> value is an <code>integer</code> with units in seconds. 
    <ul>
      <li>When set to <code>zero</code> (0), gmond will never delete a host from its list even when a remote host has stopped reporting. </li>
      <li>If host_dmax is set to a positive number then gmond will flush a host after it has not heard from it for <code>host_dmax</code> seconds. By the way, dmax means <code>delete max</code>.</li>
    </ul>
  </li>
</ul>

<p><strong>notes(ningg)</strong>：上述gmond与host什么关系？从list中删除某个host的有什么影响？gmond接收不到某个host的report信息，那留着他有什么用？如果有新增的host，gmond能够自动识别出来吗？
<strong>RE</strong>：删除host还是很必要的，增加list的动态退出机制，如果host死亡，则一些情况下，不需要在list保存。<em>（list就是gweb下显示的cluster吗？如果是，那这样解释就能够简化gweb页面）</em></p>

<ul>
  <li>The <code>host_tmax</code> value is an <code>integer</code> with units in seconds. 
    <ul>
      <li>This value represents the maximum amount of time that gmond should wait between updates from a host. </li>
      <li>As messages may get lost in the network, gmond will consider the host as being down if it has not received any messages from it after <code>4 times</code> this value. </li>
      <li>For example, if host_tmax is set to 20, the host will appear as down after 80 seconds with no messages from it. By the way, tmax means <code>timeout max</code>.</li>
    </ul>
  </li>
</ul>

<p><strong>notes(ningg)</strong>：上述gmond与host什么区别和联系？gmond与cluster之间什么关系？此处的<code>host_tmax</code>超过这一时间，认为host down，与上面的 delete host from list有什么区别？</p>

<ul>
  <li>The <code>cleanup_threshold</code> is the minimum amount of time before gmond will cleanup any hosts or metrics where <code>tn &gt; dmax</code> a.k.a. expired data.</li>
</ul>

<p><strong>notes(ningg)</strong>：<code>a.k.a.</code>，also known as，别名。参数<code>cleanup_threshold</code>表示，当host需要被delete时，仍需等待的最短时间。</p>

<ul>
  <li>
    <p>The <code>gexec</code> boolean allows you to specify whether gmond will announce the hosts availability to run gexec jobs. <strong>Note</strong>: this requires that <code>gexecd</code> is running on the host and the proper keys have been installed.</p>
  </li>
  <li>
    <p>The <code>send_metadata_interval</code> establishes an interval in which gmond will send or resend the metadata packets that describe each enabled metric. </p>
    <ul>
      <li>This directive by default is set to <code>0</code> which means that gmond will only send the metadata packets at startup and upon request from other gmond nodes running remotely. </li>
      <li>If a new machine running gmond is added to a cluster, it needs to announce itself and inform all other nodes of the metrics that it currently supports. </li>
      <li>In <code>multicast</code> mode, this isn’t a problem because any node can request the metadata of all other nodes in the cluster. </li>
      <li>However in <code>unicast</code> mode, a resend interval must be established. The interval value is the minimum number of seconds between resends.</li>
    </ul>
  </li>
</ul>

<p>几个要点与疑问：</p>

<ul>
  <li>metadata由gmond发送，其描述了gmond收集哪些metrics；</li>
  <li><code>unicast</code> mode下，必须为gmond设置一个非零的<code>send_metadata_interval</code>参数；</li>
  <li>gmond向谁发送metadata？</li>
  <li>“upon request from other gmond nodes”，gmond会从远端gmond中请求数据吗？</li>
  <li><code>multicast</code> mode时，gmond可以从cluster内的所有node请求metadata？怎么实现的？multicast机制支持？</li>
</ul>

<p><strong>notes(ningg)</strong>：为什么<code>multicast</code>和<code>unicast</code>（组播与单播）方式有差异？（哈哈，multicast用的是D类保留IP，这个应该是基本知识，准备单写一篇文章来说这个事。）</p>

<ul>
  <li>
    <p>The <code>override_hostname</code> and <code>override_ip</code> parameters allow an arbitrary hostname and/or IP (hostname can be optionally specified without IP) to use when identifying metrics coming from this host.</p>
  </li>
  <li>
    <p>The <code>module_dir</code> is an <code>optional</code> parameter indicating the directory where the <code>DSO</code> modules are to be located. </p>
    <ul>
      <li>If <code>absent</code>, the value to use is set at configure time with the <code>--with-moduledir</code> option which will default if omitted to the a subdirectory named “ganglia” in the directory where libganglia will be installed.</li>
    </ul>
  </li>
</ul>

<p>For example, in a 32-bit Intel compatible Linux host that is usually:</p>

<pre><code>/usr/lib/ganglia
</code></pre>

<p><strong>notes(ningg)</strong>：<code>DSO</code> modules是什么？</p>

<h3 id="udpsendchannel">udp_send_channel</h3>

<p>You can define as many <code>udp_send_channel</code> sections as you like within the limitations of memory and file descriptors. If <strong>gmond</strong> is configured as <code>mute</code> this section will be ignored.</p>

<p><strong>notes(ningg)</strong>：说几点：</p>

<ul>
  <li><code>udp_send_channel</code> section，可以设置多个；</li>
  <li>如果<code>mute</code>属性设置为true，则，<code>udp_send_channel</code>配置信息不会启用；</li>
</ul>

<p>The <code>udp_send_channel</code> has a total of seven attributes: 
<code>mcast_join</code> , <code>mcast_if</code> , <code>host</code> , <code>port</code> , <code>ttl</code> , <code>bind</code> , <code>bind_hostname</code>.</p>

<p><code>bind</code> and <code>bind_hostname</code> are mutually exclusive.（两个属性<code>bind</code>和<code>bind_hostname</code>互斥，只需配置一个）</p>

<p>For example, the 2.5.x version gmond would send on the following single channel by default…</p>

<pre><code>udp_send_channel {
    mcast_join = 239.2.11.71
    port       = 8649
}
</code></pre>

<p>The <code>mcast_join</code> and <code>mcast_if</code> attributes are <code>optional</code>. When specified, <code>gmond</code> will create the UDP socket and join the <code>mcast_join</code> multicast group and send data out the interface specified by <code>mcast_if</code>.(eth0, for example).</p>

<p><strong>notes(ningg)</strong>：几个疑问：</p>

<ul>
  <li>mcast_join用来标识一个multicast group，必须是IP吗？这个IP的用途是什么？IP必须是cluster中某个node吗?<strong>RE</strong>：mcast_join，是保留的D类地址，用于进行multicast，这个IP不是cluster中某个node的IP，是保留IP。</li>
  <li>设置了mcast_join之后，还能设置host吗？</li>
  <li>multicast方式时，只能使用UDP吗？<strong>RE</strong>：当前看，只能走UDP socket方式；</li>
  <li>设置mcast_join之后，没有指定mcast_if，这个有影响吗？UDP socket通过哪个端口进行连接？</li>
  <li>multicast方式时，gmond部署的服务器的CPU等运行状态数据是怎么获取的？gmond向cluster内其他host广播自己的运行状态，然后，从其他host再获取自己的运行状态数据？</li>
</ul>

<p>You can use the <code>bind</code> attribute to bind to a particular local address to be used as the source for the multicast packets sent or let gmond resolve the default hostname if <code>bind_hostname = yes</code>.</p>

<p><strong>notes(ningg)</strong>：几点：</p>

<ul>
  <li><code>bind</code>与<code>bind_hostname</code>只能配置一个，或者都不配置；</li>
  <li>两个参数怎么用，没弄明白；<em>（针对多网口，每个有不同IP的情况？）</em></li>
</ul>

<p>If only a <code>host</code> and <code>port</code> are specified then gmond will send <code>unicast</code> UDP messages to the hosts specified.</p>

<p>You could specify <code>multiple</code> <code>unicast</code> hosts for redundancy as <code>gmond</code> will send UDP messages to <code>all</code> UDP channels.</p>

<p>Be careful though not to mix <code>multicast</code> and <code>unicast</code> attributes in the same <code>udp_send_channel</code> definition.</p>

<p>For example…</p>

<pre><code>udp_send_channel {
    host = host.foo.com
    port = 2389
}
  
udp_send_channel {
    host = 192.168.3.4
    port = 2344
}
</code></pre>

<p>would configure gmond to send messages to two hosts. The <code>host</code> specification can be an IPv4/IPv6 address or a resolvable hostname.</p>

<p>The <code>ttl</code> attribute lets you modify the Time-To-Live (TTL) of outgoing messages (unicast or multicast).The time-to-live, this setting is particularly important for <code>multicast</code> environments, as it limits the number of hops over which the metric transmissions are permitted to propagate. Setting this value to any value higher than necessary could result in metrics being transmitted across WAN connections to multiple sites or even out into the global Internet.</p>

<h3 id="udprecvchannel">udp_recv_channel</h3>

<p>You can specify as many <code>udp_recv_channel</code> sections as you like within the limits of memory and file descriptors. If gmond is configured <code>deaf</code> this attribute will be ignored.</p>

<p>The <code>udp_recv_channel</code> section has following attributes: <code>mcast_join</code>, <code>bind</code>, <code>port</code>, <code>mcast_if</code>, <code>family</code>, <code>retry_bind</code> and <code>buffer</code>. The <code>udp_recv_channel</code> can also have an <code>acl</code> definition (see <strong>ACCESS</strong> <strong>CONTROL</strong> <strong>LISTS</strong> below).</p>

<p>For example, the 2.5.x gmond ran with a single udp receive channel…</p>

<pre><code>udp_recv_channel {
    mcast_join = 239.2.11.71
    bind       = 239.2.11.71
    port       = 8649
}
</code></pre>

<p>The <code>mcast_join</code> and <code>mcast_if</code> should only be used if you want to have this UDP channel receive multicast packets the multicast group <code>mcast_join</code> on interface <code>mcast_if</code>. If you do not specify multicast attributes then gmond will simply create a UDP server on the specified port.
（gmond通过<code>mcast_join</code>:<code>mcast_if</code>来收集广播地址上的UDP数据，如果没有设定multicast方式收集数据，则gmond会在指定port上，创建一个UDP server。）<em>（multicast mode下，利用port还是mcast_if，这个存疑。）</em></p>

<p>You can use the <code>bind</code> attribute to bind to a particular local address.</p>

<p>The family address is set to <code>inet4</code> by default. If you want to bind the port to an <code>inet6</code> port, you need to specify that in the family attribute. Ganglia will not allow <code>IPV6=&gt;IPV4</code> mapping (for portability and security reasons). If you want to listen on both inet4 and inet6 for a particular port, explicitly state it with the following:</p>

<pre><code>udp_recv_channel {
    port = 8666
    family = inet4
}
udp_recv_channel {
    port = 8666
    family = inet6
}
</code></pre>

<p>If you specify a bind address, the family of that address takes precedence. If your IPv6 stack doesn’t support IPV6_V6ONLY, a warning will be issued but gmond will continue working (this should rarely happen).</p>

<p><strong>Multicast Note</strong>: for multicast, specifying a <code>bind</code> address with the same value used for <code>mcast_join</code> will prevent unicast UDP messages to the same port from being processed.</p>

<p><strong>疑问</strong>：multicast与unicast接收UDP时，可以使用相同的port？难道不是分别通过<code>mcast_if</code>和<code>port</code>来配置的端口？</p>

<p>The sFlow protocol (see [http://www.sflow.org][http://www.sflow.org]) can be used to collect a standard set of performance metrics from servers. For servers that don’t include embedded sFlow agents, an open source sFlow agent is available on SourceForge (see [http://host-sflow.sourceforge.net][http://host-sflow.sourceforge.net]).</p>

<p>To configure <strong>gmond</strong> to receive sFlow datagrams, simply add a udp_recv_channel with the port set to <code>6343</code> (the IANA registered port for sFlow):</p>

<pre><code>udp_recv_channel {
    port = 6343
}
</code></pre>

<p><strong>Note</strong>: sFlow is unicast protocol, so don’t include mcast_join join. Note: To use some other port for sFlow, set it here and then specify the port in an sflow section (see below).</p>

<p>gmond will fail to run if it can’t bind to all defined <code>udp_recv_channels</code>. Sometimes, on machines configured by DHCP, for example, the gmond daemon starts before a network address is assigned to the interface. Consequently, the bind fails and the gmond daemon does not run. To assist in this situation, the boolean parameter retry_bind can be set to the value true and then the daemon will not abort on failure, it will enter a loop and repeat the bind attempt every 60 seconds:
（如果gmond在绑定<code>udp_recv_channels</code>出现错误，则gmond进程将终止运行，为了解决这一问题，可在每个<code>udp_recv_channel</code>中配置参数<code>retry_bind=true</code>，其会在channel绑定失败后，每60s重新绑定一次。）</p>

<pre><code>udp_recv_channel {
    port = 6343
    retry_bind = true
}
</code></pre>

<p>If you have a large system with lots of metrics, you might experience UDP drops. This happens when gmond is not able to process the UDP fast enough from the network. In this case you might consider changing your setup into a more distributed setup using aggregator gmond hosts. Alternatively you can choose to create a bigger receive buffer:
（被监控的节点很多时，其网络中传送的metrics较多，网络流量巨大，不可避免会丢包，原因无非是：UDP package处理速度 <code>&lt;</code> 网络接收UDP package的速度；解决思路有两个：重新设计分布式节点的布局，减轻一些关键节点的集中程度，另一种方法，增大可能丢包节点的receive buffer）</p>

<pre><code>udp_recv_channel {
    port = 6343
    buffer = 10485760
}
</code></pre>

<p><code>buffer</code>is specified in bytes, i.e.: 10485760 will allow 10MB UDP to be buffered in memory.</p>

<p><strong>Note</strong>: increasing buffer size will increase memory usage by gmond.</p>

<h3 id="tcpacceptchannel">tcp_accept_channel</h3>

<p>You can specify as many <code>tcp_accept_channel</code> sections as you like within the limitations of memory and file descriptors. If <strong>gmond</strong> is configured to be <code>mute</code>, then these sections are ignored.</p>

<p>The <code>tcp_accept_channel</code> has the following attributes: <code>bind</code>, <code>port</code>, <code>interface</code>, <code>family</code> and <code>timeout</code>. A <code>tcp_accept_channel</code> may also have an <code>acl</code> section specified (see <strong>ACCESS CONTROL LISTS</strong> below).</p>

<p>For example, 2.5.x gmond would accept connections on a single TCP channel.</p>

<pre><code>tcp_accept_channel {
    port = 8649
}
</code></pre>

<p>The <code>bind</code> address is <strong>optional</strong> and allows you to specify which local address gmond will bind to for this channel.</p>

<p>The <code>port</code> is an integer than specifies which port to answer requests for data.</p>

<p>The <code>family</code> address is set to <code>inet4</code> by default. If you want to bind the port to an <code>inet6</code> port, you need to specify that in the family attribute. Ganglia will not allow <code>IPV6=&gt;IPV4</code> mapping (for portability and security reasons). If you want to listen on both inet4 and inet6 for a particular port, explicitly state it with the following:</p>

<pre><code>tcp_accept_channel {
    port = 8666
    family = inet4
}
tcp_accept_channel {
    port = 8666
    family = inet6
}
</code></pre>

<p>If you specify a bind address, the family of that address takes precedence. If your IPv6 stack doesn’t support IPV6_V6ONLY, a warning will be issued but gmond will continue working (this should rarely happen).</p>

<p>The <code>timeout</code> attribute allows you to specify how many microseconds to block before closing a connection to a client. The default is set to -1 (blocking IO) and will never abort a connection regardless of how slow the client is in fetching the report data.</p>

<p>The <code>interface</code> is not implemented at this time (use <code>bind</code>).</p>

<h3 id="collectiongroup">collection_group</h3>

<p>You can specify as many <code>collection_group</code> section as you like within the limitations of memory. A <code>collection_group</code> has the following attributes: <code>collect_once</code>, <code>collect_every</code> and <code>time_threshold</code>. A <code>collection_group</code> must also contain one or more <code>metric</code> sections.</p>

<p>The <code>metric</code> section has the following attributes: (one of <code>name</code> or <code>name_match</code>; <code>name_match</code> is only permitted if <strong>pcre</strong> support is compiled in), <code>value_threshold</code> and <code>title</code>. For a list of available metric names, run the following command:</p>

<pre><code>%gmond -m
</code></pre>

<p>Here is an example of a collection group for a static metric…</p>

<pre><code>collection_group {
    collect_once = yes
    time_threshold = 1800
    metric {
        name = "cpu_num"
        title = "Number of CPUs"
    }
}
</code></pre>

<p>This <code>collection_group</code> entry would cause gmond to collect the cpu_num metric once at startup (since the number of CPUs will not change between reboots). The metric cpu_num would be send every 1/2 hour (1800 seconds). The default value for the time_threshold is 3600 seconds if no time_threshold is specified.
（参数<code>collect_once</code>，<code>collect_every</code>，设定什么时间提交metrics）</p>

<p>The <code>time_threshold</code> is the maximum amount of time that can pass before gmond sends all metrics specified in the collection_group to all configured <code>udp_send_channels</code>. A metric may be sent before this <code>time_threshold</code> is met if during collection the value surpasses the <code>value_threshold</code> (explained below).
（参数<code>time_threshold</code>设定collection_group中metrics发送给所有<code>udp_send_channels</code>之前允许花费的时间。）<em>（前面的表述对吗？）</em></p>

<p>Here is an example of a collection group for a volatile metric…</p>

<pre><code>collection_group {
    collect_every = 60
    time_threshold = 300
    metric {
        name = "cpu_user"
        value_threshold = 5.0
        title = "CPU User"
    }
    metric {
        name = "cpu_idle"
        value_threshold = 10.0
        title = "CPU Idle"
    }
}
</code></pre>

<p>This collection group would collect the <code>cpu_user</code> and <code>cpu_idle</code> metrics every 60 seconds (specified in <code>collect_every</code>). If <code>cpu_user</code> varies by 5.0% or <code>cpu_idle</code> varies by 10.0%, then the entire <code>collection_group</code> is sent. If no <code>value_threshold</code> is triggered within <code>time_threshold</code> seconds (in this case 300), the entire <code>collection_group</code> is sent.
（基本流程是这样的，以<code>collect_every</code>时间间隔来采集metric，然后判断<code>value_threshold</code>和<code>time_threshold</code>，如果有一个满足，则发送整个<code>collection_group</code>）</p>

<p>Each time the metric value is collected the new value is compared with the old value collected. If the difference between the last value and the current value is greater than the value_threshold, the entire collection group is send to the <code>udp_send_channels</code> defined.</p>

<p>It’s important to note that all metrics in a collection group are sent even when only a single <code>value_threshold</code> is surpassed.</p>

<p>In addition a user friendly title can be substituted for the metric name by including a <code>title</code> within the <code>metric</code> section.</p>

<p>By using the <code>name_match</code> parameter instead of <code>name</code>, it is possible to use a single definition to configure multiple metrics that match a regular expression. The perl compatible regular expression (<strong>pcre</strong>) syntax is used. This approach is particularly useful for a series of metrics that may vary in number between reboots (e.g. metric names that are generated for each individual NIC or CPU core).</p>

<p>Here is an example of using the <code>name_match</code> directive to enable the multicpu metrics:</p>

<pre><code>metric {
    name_match = "multicpu_([a-z]+)([0-9]+)"
    value_threshold = 1.0
    title = "CPU-\\2 \\1"
}
</code></pre>

<p>Note that in the example above, there are two matches: the alphabetical match matches the variations of the metric name (e.g. idle, system) while the numeric match matches the CPU core number. The second thing to note is the use of substitutions within the argument to title.</p>

<p>If both name and <code>name_match</code> are specified, then <code>name</code> is ignored.</p>

<p><strong>notes(ningg)</strong>：说几点：</p>

<ul>
  <li>如何判断<code>value_threshold</code>满足条件？当前测量值，与前一个测量值之间的差异，超过<code>value_threshold</code>；</li>
  <li>当<code>collection_group</code>中某个<code>value_threshold</code>条件被触发之后，整个collection group内部的metric都会被发送出去；</li>
  <li>在metric section中增加<code>title</code>属性，用于展示metric的标题；</li>
  <li><code>collection_group</code>下的metric section用于设定metric的约束（通过<code>name</code>或者<code>name_match</code>来匹配），而不是用于重新定义metric；</li>
  <li>同时设定<code>name</code>和<code>name_match</code>时，以<code>name_match</code>为准；</li>
</ul>

<h3 id="modules">Modules</h3>

<p>A <code>modules</code> section contains the parameters that are necessary to load a metric module. A metric module is a dynamically loadable module that extends the available metrics that gmond is able to collect. Each modules section contains at least one module section. Within a module section are the directives <code>name</code>, <code>language</code>, <code>enabled</code>, <code>path</code> and <code>params</code>. The module <code>name</code> is the name of the module as determined by the module structure if the module was developed in C/C++. Alternatively, the name can be the name of the source file if the module has been implemented in a interpreted language such as python. A language designation must be specified as a string value for each module. The <code>language</code> directive must correspond to the source code language in which the module was implemented (ex. language = “python”). If a language directive does not exist for the module, the assumed language will be “C/C++”. The <code>enabled</code> directive allows a metric module to be easily enabled or disabled through the configuration file. If the enabled directive is not included in the module configuration, the enabled state will default to “yes”. One thing to note is that if a module has been disabled yet the metric which that module implements is still listed as part of a collection group, gmond will produce a warning message. However gmond will continue to function normally by simply ignoring the metric. The <code>path</code> is the path from which gmond is expected to load the module (C/C++ compiled dynamically loadable module only). The <code>params</code> directive can be used to pass a single string parameter directly to the module initialization function (C/C++ module only). Multiple parameters can be passed to the module’s initialization function by including one or more param sections. Each param section must be named and contain a value directive. Once a module has been loaded, the additional metrics can be discovered by invoking <code>gmond -m</code>.</p>

<pre><code>modules {
 	 module {
 	   name = "example_module"
 	   language = "C/C++"
 	   enabled = yes
 	   path = "modexample.so"
 	   params = "An extra raw parameter"
 	   param RandomMax {
 		 value = 75
 	   }
 	   param ConstantValue {
 		 value = 25
 	   }
 	 }
}
</code></pre>

<p><strong>notes(ningg)</strong>：<code>path</code>参数设定的默认路径是哪个？</p>

<h3 id="sflow">sFlow</h3>

<p>sFlow is an industry standard technology for monitoring high-speed switched networks. Originally targeted at embedded network hardware, sFlow collectors now exist for general-purpose operating systems as well as popular applica-tions such as Tomcat, memcached, and the Apache Web Server. gmond can be con-figured to act as a collector for sFlow agents on the network, packaging the sFlow agent data so that it may be transparently reported to gmetad. </p>

<p>The <code>sflow</code> group is optional and has the following optional attributes: <code>udp_port</code>, <code>accept_vm_metrics</code>, <code>accept_http_metrics</code>, <code>accept_memcache_metrics</code>, <code>accept_jvm_metrics</code>, <code>multiple_http_instances</code>, <code>multiple_memcache_instances</code>, <code>multiple_jvm_instances</code>. By default, a <code>udp_recv_channel</code> on port <code>6343</code> (the IANA registered port for sFlow) is all that is required to accept and process sFlow datagrams. To receive sFlow on some other port requires both a udp_recv_channel for the other port and a udp_port setting here. For example:</p>

<pre><code>udp_recv_channel {
    port = 7343
}
sflow {
    udp_port = 7343
}
</code></pre>

<p>An sFlow agent running on a hypervisor may also be sending metrics for its local virtual machines. By default these metrics are ignored, but the <code>accept_vm_metrics</code> flag can be used to accept those metrics too, and prefix them with an identifier for each virtual machine.</p>

<pre><code>sflow {
    accept_vm_metrics = yes
}
</code></pre>

<p>The sFlow feed may also contain metrics sent from HTTP or memcached servers, or from Java VMs. Extra options can be used to ignore or accept these metrics, and to indicate that there may be multiple instances per host. For example:</p>

<pre><code>sflow {
    accept_http_metrics = yes
    multiple_http_instances = yes
}
</code></pre>

<p>will allow the HTTP metrics, and also mark them with a distinguishing identifier so that each instance can be trended separately. (If multiple instances are reporting and this flag is not set, the results are likely to be garbled.)</p>

<p><strong>notes(ningg)</strong>：sFlow怎么用？跟之前gmond通过UDP socket收集所有metric有差异吗？sFlow用于采集metric，还是收集metric？原始gmond、gmetad、gweb结构中，sFlow的位置在哪？</p>

<h3 id="include">Include</h3>

<p>This directive allows the user to include additional configuration files rather than having to add all gmond configuration directives to the <code>gmond.conf</code> file. The following example includes any file with the extension of .conf contained in the directory <code>conf.d</code> as if the contents of the included configuration files were part of the original <code>gmond.conf</code> file. This allows the user to modularize their configuration file. One usage example might be to load individual metric modules by including module specific <code>.conf</code> files.
（添加定制的配置文件）</p>

<pre><code>include ('/etc/ganglia/conf.d/*.conf')
</code></pre>

<h2 id="access-control">ACCESS CONTROL</h2>

<p>The <code>udp_recv_channel</code> and <code>tcp_accept_channel</code> directives can contain an Access Control List (ACL). This ACL allows you to specify exactly which hosts gmond process data from.</p>

<p>An example of an <code>acl</code> entry looks like：</p>

<pre><code>acl{
   default = "deny"
   access {
     ip = 192.168.0.4
     mask = 32
     action = "allow"
   }
}
</code></pre>

<p>This ACL will by default reject all traffic that is not specifically from host 192.168.0.4 (the mask size for an IPv4 address is 32, the mask size for an IPv6 address is 128 to represent a single host).</p>

<p>Here is another example</p>

<pre><code>acl {
  default = "allow"
  access {
    ip = 192.168.0.0
    mask = 24
    action = "deny"
  }
  access {
    ip = ::ff:1.2.3.0
    mask = 120
    action = "deny"
  }
}
</code></pre>

<p>This ACL will by default allow all traffic unless it comes from the two subnets specified with action = “deny”.</p>

<h2 id="example">EXAMPLE</h2>

<p>The default behavior for a 2.5.x gmond would be specified as…</p>

<pre><code>udp_recv_channel {
  mcast_join = 239.2.11.71
  bind       = 239.2.11.71
  port       = 8649
}
udp_send_channel {
  mcast_join = 239.2.11.71
  port       = 8649
}
tcp_accept_channel {
  port       = 8649
}
</code></pre>

<p>To see the complete default configuration for gmond simply run:</p>

<pre><code>% gmond -t
</code></pre>

<p>gmond will print out its default behavior in a configuration file and then exit. Capturing this output to a file can serve as a useful starting point for creating your own custom configuration.</p>

<pre><code>% gmond -t &gt; custom.conf
</code></pre>

<p>edit <code>custom.conf</code> to taste and then</p>

<pre><code>% gmond -c ./custom.conf
</code></pre>

<h2 id="see-also">SEE ALSO</h2>

<p>gmond(1).</p>

<h2 id="notes">NOTES</h2>

<p>The ganglia web site is at [http://ganglia.info/][http://ganglia.info/].</p>

<h2 id="copyright">COPYRIGHT</h2>

<p>Copyright (c) 2005 The University of California, Berkeley</p>

<h2 id="section">参考来源</h2>

<ul>
  <li><a href="http://sourceforge.net/projects/ganglia/files/">ganglia-3.6.1(ganglia monitoring core)</a>的源码包中gmond/gmond.conf.html文件</li>
  <li><a href="http://shop.oreilly.com/product/0636920025573.do">Monitoring with Ganglia</a> Chapter 2: Installing and Configuring Ganglia</li>
</ul>



        <div id="disqus_container">
            <div style="margin-bottom:20px" class="right">
				<wb:share-button appkey="2306590132" addition="simple" type="button" ralateUid="2356527183"></wb:share-button>
            </div>
            <!--<a href="#" class="comment" onclick="return false;">点击查看评论</a>-->
            <div id="disqus_thread"></div>
        </div>
    </div>

	
    <div class="sidenav">
		<iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=2356527183&verifier=1ccfb61e&colors=d6f3f7,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe>
    </div>

</div>

<script src="/js/post.js" type="text/javascript"></script>


	<div id="gotoTop">Top</div>


    <!--*********************************************************-->
    <!--****** 宝贝儿，看见这个时候，删掉下面的统计代码哦~ ******-->
    <!--*********************************************************-->
	<script>
	  (function(i,s,o,g,r,a,m){
		  i['GoogleAnalyticsObject']=r;i[r]=i[r] || function(){
			(i[r].q=i[r].q||[]).push(arguments)}, i[r].l=1*new Date();
			a=s.createElement(o), m=s.getElementsByTagName(o)[0];
			a.async=1;
			a.src=g;
			m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-48535193-1', 'ningg.github.io');
	  ga('send', 'pageview');
	</script>
    
	
    <script type="text/javascript">
		function gotoTop(min_height){
			$("#gotoTop").click(
				function(){$('html,body').animate({scrollTop:0},700);
			}).hover(
				function(){$(this).addClass("hover");},
				function(){$(this).removeClass("hover");
			});
			min_height ? min_height = min_height : min_height = 600;
			$(window).scroll(function(){
				
				var s = $(window).scrollTop();
				
				if( s > min_height){
					$("#gotoTop").fadeIn(100);
				}else{
					$("#gotoTop").fadeOut(200);
				};
			});
		};
		gotoTop();

        $(function(){
            $('.home-follow').click(function(e){
                e.preventDefault();

                if($('.home-contact').is(':visible')){
                    $('.home-contact').slideUp(100);
                }else{
                    $('.home-contact').slideDown(100);
                }
            });
        })

    </script>
</body>
</html>
