<!DOCTYPE html>
<html xmlns:wb="http://open.weibo.com/wb">
<head>
    <!--   Author: NingG   -->
    <meta charset="utf-8" />
	<meta property="wb:webmaster" content="7ea7f3d5f3edad6a" />
    <title>java的编码问题：byte、char、string | ningg.top</title>
    <meta name="author" content="NingG" />
    <meta name="renderer" content="webkit">
    <meta name="description" content=" 出现乱码？原因挺简单的，byte与char之间映射出错  " />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">

    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="" />
	
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
	<script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
	
    <div class="home-menu">
        <div class="home-icon-con">
            <a class="home-menu-icon" href="/">NingG</a>
            <a class="home-follow" href="#" title="Contact Me">+</a>
        </div>
        <div class="home-contact">
            <a href="http://weibo.com/ggningg/" target="_blank" style="margin-left:-5px;"><img src="http://www.weibo.com/favicon.ico" alt="" width="25"/></a>
            <a href="http://www.douban.com/people/ggningg/" target="_blank" style="text-align:center;"><img src="http://www.douban.com/favicon.ico" alt="" width="22"/></a>
			<a href="http://github.com/ningg" alt="" target="_blank" style="text-align:right;"><img src="/images/icon-cube-smaller.png" width="22"/></a>
        </div>
    </div>

    <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/java-encode-byte-char-string" title="java的编码问题：byte、char、string">java的编码问题：byte、char、string</a></h1>
        <p class="entry-date">2013-02-05</p>
        <h2 id="section">关注点</h2>

<p>要解决几个问题：</p>

<ul>
  <li>java中，出现乱码的原因？解决的基本原理？（下面两个是具体问题）
    <ul>
      <li>java中，对字符串String的读取，出现乱码的解决办法？</li>
      <li>java中，对文件File的读写，出现乱码的解决办法？</li>
    </ul>
  </li>
  <li>补充知识：
    <ul>
      <li><code>编码</code>：几种编码方式之间的差异：ASCII、UTF-8、GB2312、GBK、ISO8859-1；</li>
      <li><code>文件</code>：java下，文件读写，效率和编码；</li>
      <li><code>数组</code>：java下，基础类型（char、byte、int）数组的定义和使用</li>
    </ul>
  </li>
</ul>

<h2 id="section-1">乱码</h2>

<p><img src="/images/java-encode-byte-char-string/encode-process.png" alt="" /></p>

<p>java中，对String进行编码、解码的基本过程，见上图；简要解释一下：</p>

<ul>
  <li>编码解码，<code>String</code>通过<code>charsetIn</code>字符集映射为<code>byte[]</code>，然后<code>byte[]</code>再依照<code>charsetOut</code>映射为<code>String</code>的过程；</li>
  <li><code>String</code>是<code>char[]</code>；</li>
  <li>编码解码，本质是：<code>char[]</code>通过<code>charsetIn</code>字符集映射为<code>byte[]</code>，然后<code>byte[]</code>再依照<code>charsetOut</code>映射为<code>char[]</code>的过程；</li>
  <li><code>charset</code>字符集，对应编码方式，通俗说，就是一张映射表，既可以将char映射为byte，也可以将byte映射为char。</li>
</ul>

<h3 id="section-2">编码的基本解释</h3>

<p><img src="/images/java-encode-byte-char-string/general-explain.png" alt="" /></p>

<p>几点：</p>

<ul>
  <li>编码方式，字符集，都是针对 <code>byte[]</code> 来说的，即，针对机器上存储的原始二进制字节；</li>
  <li>无论什么编码方式，在 <code>char[]</code> 上是统一的；</li>
</ul>

<h3 id="java--string-">java 中 String 的编解码</h3>

<p><img src="/images/java-encode-byte-char-string/java-string-encode.png" alt="" /></p>

<h3 id="java--file-">java 中 File 的编解码</h3>

<p><img src="/images/java-encode-byte-char-string/java-file-encode.png" alt="" /></p>

<p>java 读写 file，有两种方式：</p>

<ul>
  <li>按照 byte 读取，此为文件的镜像，不涉及文件编码问题；</li>
  <li>按照 char 读取，此过程中，涉及两处编码字符集：读取文件、写入文件；</li>
</ul>

<h3 id="section-3">何时出现乱码？如何解决？</h3>

<p>依照前文分析的编码解码基本过程，产生乱码，本质是输入的<code>char[]</code>与最终输出的<code>char[]</code>不一致，有如下几种：</p>

<ul>
  <li><code>char</code>在<code>charsetIn</code>字符集中不存在，无法找出对应的<code>byte[]</code>，只能强制转换为某个默认的<code>byte[]</code>；</li>
  <li><code>charsetIn</code>与<code>charsetOut</code>不一致；</li>
</ul>

<p>因此，解决乱码问题的思路也是清晰的：</p>

<ul>
  <li>选用合适的字符集<code>charsetIn</code>，当然，尽可能大的字符集<code>charsetIn</code>最好，不过，能够满足需求即可；</li>
  <li>保证<code>charsetIn</code>与<code>charsetOut</code>字符集完全一致；</li>
</ul>

<p><strong>思考</strong>：上数的讨论都是基于原始输入<code>String</code>为正常String，没有携带乱码，但有一种情况：原始<code>String</code>中自身就携带乱码，此时，如何处理？
<strong>RE</strong>：特别是，针对ASCII中的控制字符（contorl code），例如：<code>^M</code>、<code>^C</code>，此类字符，会产生转码后的换行问题，如何提前对此类字符进行处理？具体需要认真分析此类字符产生的原因，初步分析，两类场景：</p>

<ul>
  <li>control code：当作普通字符，不进行换行、tab等特殊操作，可以直接替换为特征字符，例如：<code>^M</code>，替换为<code>Carriage return</code>;</li>
  <li>control code：传统用法，都是翻译成其特殊含义对应的操作吗？例如：<code>^M</code>，就翻译为换行的操作；</li>
</ul>

<p><strong>疑问</strong>：ASCII的control code是如何输入到File中的？可以直接通过键盘输入吗？还有哪些场景？</p>

<h4 id="update-2015-03-18">UPDATE 2015-03-18</h4>

<p>中文编码问题：</p>

<ul>
  <li>通常读取文件内容，两类：按照byte读取、按照char读取；</li>
  <li>按照char方式读取会出现乱码；</li>
  <li>char方式在哪个阶段出现乱码？byte转换为char的时候。</li>
  <li>因此，图片中展示的基本原理，而在实际情况中，是byte–char–byte–char，根据发生地点来划分的？本地的byte–char–byte，然后以byte方式发送出去，对端再将byte–char。</li>
</ul>

<p>参考下文的示例代码即可。</p>

<h3 id="section-4">字符串的编解码</h3>

<p>几点：</p>

<ul>
  <li>获取<code>String</code>对应的<code>byte[]</code>：<code>String.getBytes(charset)</code>；</li>
  <li>输出<code>byte[]</code>内容：<code>Arrays.toString(byte[])</code></li>
  <li>将<code>byte[]</code>编码为<code>String</code>：<code>new String(byte[], charset);</code></li>
</ul>

<p>测试代码如下：</p>

<pre><code>package com.github.ningg;

import java.io.UnsupportedEncodingException;
import java.util.Arrays;

public class ByteAndString {

	public static void main(String[] args) throws UnsupportedEncodingException{
		
		String inputStr = "你好, Hello";
		String charset = "UTF-8";
		String outputStr = null;
		byte[] firstLayerByteArray = null;
		
		// default
		firstLayerByteArray = inputStr.getBytes();
		outputStr = new String(firstLayerByteArray);

		System.out.println("default:");
		System.out.println(Arrays.toString(firstLayerByteArray));
		System.out.println(outputStr);
		System.out.println("-------------");
		
		// UTF-8
		charset = "UTF-8";
		firstLayerByteArray = inputStr.getBytes(charset);
		outputStr = new String(firstLayerByteArray, charset);
		
		System.out.println(charset + ":");	
		System.out.println(Arrays.toString(firstLayerByteArray));
		System.out.println(outputStr);
		System.out.println("-------------");

		// GBK
		charset = "GBK";
		firstLayerByteArray = inputStr.getBytes(charset);
		outputStr = new String(firstLayerByteArray, charset);
		
		System.out.println(charset + ":");
		System.out.println(Arrays.toString(firstLayerByteArray));
		System.out.println(outputStr);
		System.out.println("-------------");

		// GB2312
		charset = "GB2312";
		firstLayerByteArray = inputStr.getBytes(charset);
		outputStr = new String(firstLayerByteArray, charset);
		
		System.out.println(charset + ":");
		System.out.println(Arrays.toString(firstLayerByteArray));
		System.out.println(outputStr);
		System.out.println("-------------");

		// ISO-8859-1
		charset = "ISO-8859-1";
		firstLayerByteArray = inputStr.getBytes(charset);
		outputStr = new String(firstLayerByteArray, charset);
		
		System.out.println(charset + ":");
		System.out.println(Arrays.toString(firstLayerByteArray));
		System.out.println(outputStr);
		System.out.println("-------------");
		
	}
}
</code></pre>

<p>输出内容，如下：</p>

<pre><code>default:
[-28, -67, -96, -27, -91, -67, 44, 32, 72, 101, 108, 108, 111]
你好, Hello
-------------
UTF-8:
[-28, -67, -96, -27, -91, -67, 44, 32, 72, 101, 108, 108, 111]
你好, Hello
-------------
GBK:
[-60, -29, -70, -61, 44, 32, 72, 101, 108, 108, 111]
你好, Hello
-------------
GB2312:
[-60, -29, -70, -61, 44, 32, 72, 101, 108, 108, 111]
你好, Hello
-------------
ISO-8859-1:
[63, 63, 44, 32, 72, 101, 108, 108, 111]
??, Hello
-------------
</code></pre>

<p><strong>备注</strong>：之前写过，一个java中数组的博文，可以参考一下；</p>

<h3 id="section-5">文件内容的编解码</h3>

<p>下面示例代码，简要说明，以某一指定charsetIn读取文件，再以指定charsetOut写入文件即可；完整示例代码如下：</p>

<pre><code>package com.github.ningg;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class FileAndCharset {

	public static void main(String[] args) throws IOException {
		
		String srcFile = "E:/1.log";
		String destFile = "E:/1utf8.log";
		
		String charsetIn = "GBK";
		String charsetOut = "UTF-8";
		
		FileInputStream fileInputStream = new FileInputStream(srcFile);
		FileOutputStream fileOutputStream = new FileOutputStream(destFile);
		
		InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, charsetIn);
		OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream, charsetOut);
		
		BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
		BufferedWriter bufferedWriter = new BufferedWriter(outputStreamWriter);
		
		String singleLine = null;
		
		while( (singleLine = bufferedReader.readLine()) != null ){
			bufferedWriter.write(singleLine);
			bufferedWriter.newLine();
		}
		
		bufferedWriter.flush();
		bufferedWriter.close();
		bufferedReader.close();
		
	}
}
</code></pre>

<p><strong>备注</strong>：之前写过一篇Java读写File的博客，可以参考一下。</p>

<h2 id="section-6">编码方式</h2>

<p><strong>思考</strong>：几个小疑问：</p>

<ul>
  <li>什么是字符集（charset）？是一个char与byte之间的映射表吗？</li>
  <li>定长码、变长码；</li>
  <li>存储编码、传输编码；</li>
</ul>

<p>几种编码方式之间的联系：</p>

<h3 id="ascii">ASCII</h3>

<p>ASCII：American Standard Code for Information Interchange（信息交换，美国标准码）；简单说几点：</p>

<p><code>US-ASCII</code>：原始的ASCII</p>

<ul>
  <li>1963年</li>
  <li>7-bit（128个字符）</li>
  <li>letters、numerals、symbols、device control code</li>
  <li>fixed-length</li>
</ul>

<p>但是，计算机中一个byte有8bit，因此，就打起了剩余1-bit的主意：</p>

<ul>
  <li>ISO 8859，针对8-bit ASCII extensions部分，定义的规范；</li>
  <li>ISO 8859-1，又称，<code>ISO Latin 1</code>，针对西欧常用语言（Western European Language）的拓展；</li>
  <li>ISO 8859-2，东欧常用语言（Eastern European Language）的扩展；</li>
</ul>

<p>一个byte，8 bit，并不能满足所有character encodings的需要，因此出现了multi-byte character encodings，整体上两类：</p>

<ul>
  <li>Extended ASCII：多字节编码时，ASCII已经表示的字符，仍用ASCII的8-bit表示：
    <ul>
      <li>保留<code>0x00-0x7F</code>来标识原始的ASCII；</li>
      <li>启用<code>0x80--0xFF</code>来标识多字节的字符；</li>
      <li>典型代表：UTF-8</li>
    </ul>
  </li>
  <li>非 Extended ASCII：不保留单字节的ASCII表示；</li>
</ul>

<h3 id="gb2312">GB2312</h3>

<p>整体上说一下GB2312、GBK、GB18030几种编码之间的关系：</p>

<ul>
  <li>GB2312，固定码，2 byte：
    <ul>
      <li>简体汉字</li>
      <li>原有的拉丁字母、数字、符号，编码进去，称为<code>全角</code>；</li>
      <li>原有US-ASCII（7 bit）的拉丁字母、数字、符号，称为<code>半角</code>；</li>
    </ul>
  </li>
  <li>GBK
    <ul>
      <li>繁体字</li>
      <li>生僻字</li>
      <li>当前软件，支持GBK的较多，而相对GB18030更为普及</li>
    </ul>
  </li>
  <li>GB18030
    <ul>
      <li>少数民族字符</li>
      <li>生僻字</li>
    </ul>
  </li>
</ul>

<p><strong>备注</strong>：<code>GB</code>，<code>Guojia Biaozhun</code>（国标）；</p>

<p>几点：</p>

<ul>
  <li>GB2312，为GBK、GB18030的子集；
    <ul>
      <li>GBK\GB18030，相对于GB2312，在罕见字、繁体字上，有增强；</li>
    </ul>
  </li>
  <li>GB2312，包含<code>6763</code>个中文字符；</li>
  <li>GB2312，对应一个<code>94x94</code>的表格，每个空格（codepoint），都是two-byte（<code>2 bytes</code>）；</li>
  <li><code>EUC-CN</code>（Extended Unix Code），GB2312标准的常用实现，同时兼容ASCII（<code>0x00-0X7F</code>，最高位为<code>0</code>）；
    <ul>
      <li>1st byte：<code>0xA1-0xF7</code>；（最高位为<code>1</code>）</li>
      <li>2nd byte：<code>0xA1-0xFE</code>；</li>
    </ul>
  </li>
</ul>

<p><strong>疑问</strong>：<code>EUC</code>，官网提到，其是<code>ISO-2022</code>标准的实现，多字节编码，最大可包含<code>G0</code>`G1<code>\</code>G2<code>\</code>G3<code>，4个字节；其中</code>G0<code>通常兼容</code>ISO-646<code>标准（</code>US-ASCII`），但GB2312为 2 byte的定长字符集，这可如何是好？</p>

<p><strong>RE</strong>：</p>

<ul>
  <li>charset，字符集，标识char与byte之间的映射关系；</li>
  <li>GB2312标准，ISO-2022标准，是标准，而不是char与byte之间映射的字符集；</li>
  <li>GB2312标准，只说明了原理：用2byte标识，而没有设定每个char对应的byte一定要为多少，具体实现方式可以调整；</li>
  <li>ISO-2022标准，说明原理：最多可以利用 4 byte来标识字符；</li>
  <li><code>EUC-CN</code>（Extended Unix Code），是具体实现，满足GB2312和ISO-2022两个标准；<em>（有时，EUC-CN为GB18030标准和ISO-2022标准的具体实现）</em></li>
</ul>

<p>相对于<code>UTF-8</code>，<code>GB2312</code>效率更高，几点：</p>

<ul>
  <li>没有保留bits，用于标识 3 byte 或 4 byte；</li>
  <li>没有保留bit，用于detect tailing bytes；<em>（什么含义？需要检测末尾byte吗？之前Huffman coding，变长编码，不需要额外的字节，来标识tailing bytes）</em></li>
</ul>

<p><strong>思考</strong>：</p>

<ul>
  <li>GB2312中包含ASCII中已经包含的英文字符吗？
    <ul>
      <li>GB2312标准中，不包含ASCII；但其实现方式：EUC-CN，除了支持GB2312（2 byte）之外，还兼容ASCII（1 byte）；</li>
    </ul>
  </li>
  <li>若包含ASCII的英文字符，那英文字符占几个字节？
    <ul>
      <li>EUC-CN：实现GB2312的字符，字节高位为<code>1</code>；ASCII的字符，字节高位为<code>0</code>；</li>
      <li>EUC-CN：为变长编码，既包含 2 byte的GB2312字符，也包含 1 byte的ASCII字符；</li>
    </ul>
  </li>
</ul>

<p><strong>建议</strong>：推荐使用大字符集，GBK、GB18030；</p>

<h3 id="gbk">GBK</h3>

<p>几点：</p>

<ul>
  <li>GBK：Guojia Biaozhun Kuozhan；</li>
  <li>简体中文、繁体中文；</li>
  <li>字符集：
    <ul>
      <li>GB2312</li>
      <li>ASCII</li>
    </ul>
  </li>
</ul>

<h3 id="gb18030">GB18030</h3>

<p>几点：</p>

<ul>
  <li>同时兼容<code>GB2312</code>和<code>GBK</code>两个标准；</li>
  <li>是Unicode的一种？支持简体字、繁体字；</li>
  <li>Unicode Transformation Format（an encoding of all Unicode code points）；</li>
  <li>字符集：
    <ul>
      <li>ASCII</li>
      <li>GB2312</li>
      <li>GBK</li>
    </ul>
  </li>
  <li>具体编码实现：
    <ul>
      <li>1 byte</li>
      <li>2 byte</li>
      <li>4 byte</li>
    </ul>
  </li>
</ul>

<p>更多阅读：</p>

<ul>
  <li><a href="http://wenku.baidu.com/view/19810c2e4b73f242326c5f07.html">信息交换用汉字编码字符集·基本集</a></li>
</ul>

<h3 id="unicode">Unicode</h3>

<p>几点：</p>

<ul>
  <li>目标：通用字符集；</li>
  <li>包含100,000+的字符；</li>
  <li>前256个字符，保留给ISO-8859-1，基本的拉丁字母（西欧语系的字母）；<em>（基本的拉丁字母用途太广泛）</em></li>
  <li>具体实现：
    <ul>
      <li>UTF-8</li>
      <li>UTF-16</li>
      <li>UTF-32</li>
    </ul>
  </li>
</ul>

<h3 id="utf-8">UTF-8</h3>

<p>几点：</p>

<ul>
  <li>基于Unicode标准的一个具体实现方式；</li>
  <li>完全兼容<code>ISO-8859-1</code>编码方式；（第一字节，兼容ASCII）</li>
  <li>变长码，每个字符使用1-3个byte编码，并利用首位<code>0</code>或<code>1</code>进行识别；</li>
  <li>Unicode的实现方式称为<code>Unicode转换格式</code>（Unicode Transformation Format，简称UTF）</li>
  <li>补充：UTF-8编码方式，中文占 3 byte；</li>
</ul>

<p>具体：</p>

<ul>
  <li>128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。</li>
  <li>带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要两个字节编码（Unicode范围由U+0080至U+07FF）。</li>
  <li>其他基本多文种平面（BMP）中的字符（这包含了大部分常用字）使用三个字节编码（Unicode范围由U+0800至U+FFFF）。</li>
  <li>其他极少使用的 Unicode 辅助平面的字符使用四至六字节编码（Unicode范围由U+10000至U+1FFFFF使用四字节，Unicode范围由U+200000至U+3FFFFFF使用五字节，Unicode范围由U+4000000至U+7FFFFFFF使用六字节）</li>
</ul>

<p>网络上数据编码的演进趋势：（网络上传输的byte，是char通过哪种字符集映射过来的？）</p>

<p><img src="/images/java-encode-byte-char-string/UnicodeGrow2b.png" alt="" /></p>

<h2 id="section-7">附录</h2>

<h3 id="huffman-coding">Huffman coding</h3>

<p>Huffman coding，霍夫曼编码：</p>

<ul>
  <li>基本原则：符号的编码长度，按照符号出现概率大小，逆向排序；</li>
  <li>最优二叉树：带权路径长度最小的二叉树；</li>
  <li>常用语数据压缩，无损耗压缩，是一致性编码（“熵编码”）；</li>
  <li>具体操作：按概率大小排序，最小的两个概率相加，迭代到总概率<code>1</code>；</li>
</ul>

<p><img src="/images/java-encode-byte-char-string/huffman.gif" alt="" /></p>

<p><img src="/images/java-encode-byte-char-string/huffman-result.png" alt="" /></p>

<p>更多阅读，参考<a href="http://en.wikipedia.org/wiki/Huffman_coding">Huffman coding</a>。</p>

<h3 id="section-8">字母体系</h3>

<p>世界三大字母体系：</p>

<ul>
  <li>拉丁字母</li>
  <li>斯拉夫字母</li>
  <li>阿拉伯字母</li>
</ul>

<p>拉丁字母（下图）：
<img src="/images/java-encode-byte-char-string/lading.png" alt="" /></p>

<p><strong>备注</strong>：中国的汉语拼音方案，也是以拉丁字母为基础的。</p>

<p>斯拉夫字母（下图）：
<img src="/images/java-encode-byte-char-string/silafu.jpg" alt="" /></p>

<p>阿拉伯字母（下图）：
<img src="/images/java-encode-byte-char-string/alabo.jpg" alt="" /></p>

<h3 id="utfunicodeciutf8generalci">utf_unicode_ci和utf8_general_ci</h3>

<p>在数据库系统MySQL中有多种字符集，其中utf8_unicode_ci和utf8_general_ci是最常用的，但是utf8_general_ci对某些语言的支持有一些小问题，如果可以接受，那最好使用utf8_general_ci，因为它速度快。否则，请使用较为精确的utf8_unicode_ci，不过速度会慢一些。</p>

<p>多语言无差错，首选“utf_unicode_ci”。</p>

<h3 id="section-9">全角 &amp; 半角</h3>

<p><a href="http://wenku.baidu.com/view/19810c2e4b73f242326c5f07.html">信息交换用汉字编码字符集·基本集</a>对应的是GB2312，其中也指定了拉丁字母（英文字母）对应的 2 byte编码，这个只有在<code>全角</code>情况下，才输入GB2312字符集中的拉丁字母，而<code>半角</code>时，输入的为ASCII下的拉丁字母编码；</p>

<p><strong>备注</strong>：上述查询文档中，字符对应的二进制表示时，借助工具<code>UltraEdit</code>中的<code>十六进制模式</code>。</p>

<p>关于<code>全角</code>`半角`，几点：</p>

<ul>
  <li>输入汉字，全角、半角，没有区别，对应的GB2312编码完全一致，2 byte；</li>
  <li>输入英文字母、符号、数字，有区别：
    <ul>
      <li>全角：使用GB2312中对应的编码，占用 2 byte；</li>
      <li>半角：使用ASCII中编码，占用 1 byte；</li>
      <li>补充：全角存在的意义是，方便显示的整齐和美观；</li>
    </ul>
  </li>
</ul>

<h2 id="section-10">参考来源</h2>

<ul>
  <li><a href="http://en.wikipedia.org/wiki/ASCII">ASCII wiki</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Extended_ASCII">Extended ASCII wiki</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Character_encoding">Character Encoding wiki</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Extended_Unix_Code#EUC-CN">Extended Unix Code wiki</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Huffman_coding">Huffman coding</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Unicode">Unicode wiki</a></li>
  <li><a href="http://en.wikipedia.org/wiki/UTF-8">UTF-8 wiki</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/Unicode">Unicode wiki(中文)</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/ISO/IEC_8859-1">ISO-8859-1 wiki(中文)</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/UTF-8">UTF-8 wiki(中文)</a></li>
  <li><a href="http://wenku.baidu.com/view/19810c2e4b73f242326c5f07.html">信息交换用汉字编码字符集·基本集</a></li>
  <li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode和UTF-8</a></li>
</ul>

<p><strong>推荐</strong>：此次编码相关的<strong>中文wiki</strong>内容；</p>



        <div id="disqus_container">
            <div style="margin-bottom:20px" class="right">
				<wb:share-button appkey="2306590132" addition="simple" type="button" ralateUid="2356527183"></wb:share-button>
            </div>
            <!--<a href="#" class="comment" onclick="return false;">点击查看评论</a>-->
            <div id="disqus_thread"></div>
        </div>
    </div>

	
    <div class="sidenav">
		<iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=2356527183&verifier=1ccfb61e&colors=d6f3f7,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe>
    </div>

</div>

<script src="/js/post.js" type="text/javascript"></script>


	<div id="gotoTop">Top</div>


    <!--*********************************************************-->
    <!--****** 宝贝儿，看见这个时候，删掉下面的统计代码哦~ ******-->
    <!--*********************************************************-->
	<script>
	  (function(i,s,o,g,r,a,m){
		  i['GoogleAnalyticsObject']=r;i[r]=i[r] || function(){
			(i[r].q=i[r].q||[]).push(arguments)}, i[r].l=1*new Date();
			a=s.createElement(o), m=s.getElementsByTagName(o)[0];
			a.async=1;
			a.src=g;
			m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-48535193-1', 'ningg.github.io');
	  ga('send', 'pageview');
	</script>
    
	
    <script type="text/javascript">
		function gotoTop(min_height){
			$("#gotoTop").click(
				function(){$('html,body').animate({scrollTop:0},700);
			}).hover(
				function(){$(this).addClass("hover");},
				function(){$(this).removeClass("hover");
			});
			min_height ? min_height = min_height : min_height = 600;
			$(window).scroll(function(){
				
				var s = $(window).scrollTop();
				
				if( s > min_height){
					$("#gotoTop").fadeIn(100);
				}else{
					$("#gotoTop").fadeOut(200);
				};
			});
		};
		gotoTop();

        $(function(){
            $('.home-follow').click(function(e){
                e.preventDefault();

                if($('.home-contact').is(':visible')){
                    $('.home-contact').slideUp(100);
                }else{
                    $('.home-contact').slideDown(100);
                }
            });
        })

    </script>
</body>
</html>
