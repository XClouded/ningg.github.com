<!DOCTYPE html>
<html xmlns:wb="http://open.weibo.com/wb">
<head>
    <!--   Author: NingG   -->
    <meta charset="utf-8" />
	<meta property="wb:webmaster" content="7ea7f3d5f3edad6a" />
    <title>HTTP协议 | ningg.top</title>
    <meta name="author" content="NingG" />
    <meta name="renderer" content="webkit">
    <meta name="description" content=" 打开浏览器，输入一个网址，回车，一个HTTP请求就发送出去了，等待HTTP响应返回，就看到网上的内容了  " />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">

    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="" />
	
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
	<script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
	
    <div class="home-menu">
        <div class="home-icon-con">
            <a class="home-menu-icon" href="/">NingG</a>
            <a class="home-follow" href="#" title="Contact Me">+</a>
        </div>
        <div class="home-contact">
            <a href="http://weibo.com/ggningg/" target="_blank" style="margin-left:-5px;"><img src="http://www.weibo.com/favicon.ico" alt="" width="25"/></a>
            <a href="http://www.douban.com/people/ggningg/" target="_blank" style="text-align:center;"><img src="http://www.douban.com/favicon.ico" alt="" width="22"/></a>
			<a href="http://github.com/ningg" alt="" target="_blank" style="text-align:right;"><img src="/images/icon-cube-smaller.png" width="22"/></a>
        </div>
    </div>

    <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/protocol-http-intro" title="HTTP协议">HTTP协议</a></h1>
        <p class="entry-date">2014-08-13</p>
        <h2 id="section">背景</h2>

<blockquote>
  <p>最近要用java来构造HTTP请求、接收HTTP响应，并从HTTP响应中获取尽可能多的上下文信息，自己每次都查看JAVA的API，不过结果总是浑浑噩噩的感觉，因为自己并不确定HTTP响应中包含了哪些详细的信息，更何谈要提取这些信息了。</p>
</blockquote>

<p>（备注：不要求大而全，而要求先能够解决问题）</p>

<h2 id="http">HTTP协议的由来</h2>

<p>OSI模型把网络通信分成七层：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层，对于开发网络应用人员来说，一般把网络分成五层，这样比较容易理解。这五层为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层（最顶层），如下图所示：</p>

<p>网络中的计算机互相通信就是实现了层与层之间的通信，要实现层与层之间的通信，则各层都要遵守规则，这样才能完成更好的通信， 我们就把它们之间遵守的规则就叫个“协议”，然而网络上的五层之间遵守的协议不一样，每层都有各自的协议。下面就对各层进行简要介绍：</p>

<p><strong>物理层</strong></p>

<p>物理层是五层模型中的最底层，物理层为计算机之间的数据通信提供了传输媒体和互连设备的标准，为数据传输提供了可靠的环境，媒体包括电缆、光纤、无线信道等，互连设备指是计算机和调制解调器之间的互连设备，如各种插头、插座等。该层的作用是透明的传输比特流（即二进制流），为数据链路层提供一个传输原始比特流的物理连接。</p>

<p>总结一下：</p>

<ul>
  <li>目标：透明地传输bit。</li>
  <li>传输单元：bit。</li>
</ul>

<p><strong>数据链路层</strong></p>

<p>数据链路层是模型中的第2层，该层对接受到物理层传输过来的比特流进行分组，一组电信号构成的数据包，就叫做”帧”，数据链链路层就是来传输以”帧”为单位的数据包，把数据传递给上一层（网络层），帧数据由两部分组成：帧头和帧数据，帧头包括接受方物理地址（就是网卡的地址）和其他的网络信息，帧数据就是要传输的数据体。数据帧的最长为1500字节，如果数据很长，就必须分割成多个帧进行发送。</p>

<p>总结一下：</p>

<ul>
  <li>目标：通过<code>MAC地址</code>来标识设备，并且在两个相邻设备之间，透明、可靠地传输<code>数据帧</code>。</li>
  <li>传输单元：<code>帧</code>，包含帧头和帧数据。</li>
</ul>

<p><strong>网络层</strong></p>

<p>该层通过寻址（寻址地址）来建立两个节点之间的连接，大家都知道我们的电脑连接上网络后都一个IP地址，我们可以通过IP地址来确定不同的计算机是否在同一个子网内。如果我们的电脑连接上网络后就有两种地址：物理地址和网络地址（IP地址），网络上的计算机要通信，必须要知道通信的计算机“在哪里”， 首先通过网络地址来判断是否处于同一个子网，然后再对物理地址（MAC）地址进行处理，从而准确确定要通信计算机的位置。</p>

<p>在网络层中有我们熟悉的IP协议（即规定网络地址的协议），目前广泛采用的是IP协议第四版（IPv4）,这个版本规定，网络地址由32位二进制位组成。</p>

<p>网络层中以IP数据包的形式来传递数据，IP数据包也包括两部分：头（Head）和数据(Data)，IP数据包放进数据帧中的数据部分进行传输。</p>

<p>总结一下：</p>

<ul>
  <li>目标：通过<code>IP地址</code>来标识网络节点，并且在网络中任意两个节点之间，透明、可靠地传输<code>IP数据包</code>。</li>
  <li>传输单元：<code>IP数据包</code>，包含包头和数据。</li>
</ul>

<p><strong>传输层</strong></p>

<p>通过MAC和IP地址，我们可以找到互联网上任意两台主机来建立通信。然而这里有一个问题，找到主机后，主机上有很多程序都需要用到网络，比如说你在一边听歌和好用QQ聊天，当网络上发送来一个数据包时，是怎么知道它是表示聊天的内容还是歌曲的内容的， 这时候就需要一个参数来表示这个数据包是发送给那个程序（进程）来使用的，这个参数我们就叫做<code>端口号</code>，主机上用端口号来标识不同的程序（进程），端口是0到65535之间的一个整数，0到1023的端口被系统占用，用户只能选择大于1023的端口。</p>

<p>传输层的功能就是建立端口到端口的通信，网络层就是建立主机与主机的通信，这样如果我们确定了主机和端口，这样就可以实现程序之间的通信了。我们所说的Socket编程就是通过代码来实现传输层之间的通信。因为初始化Socket类对象要指定IP地址和端口号。</p>

<p>在传输层有两个非常重要的协议：UDP 协议和TCP协议</p>

<p>采用UDP协议话传输的就是UDP数据包，同样UDP数据包也由头和数据两部分组成，头部分主要标识了发送端口和接受端口，数据部分就是具体的内容信息。同样UDP数据包是放入IP数据包中的”数据”部分，IP数据包再放入数据帧中在网络上传输。</p>

<p>由于UDP协议的可靠性差（数据发送后无法确定对方是否收到），所以又定义了一个可靠性高的协议——TCP协议，TCP协议采取了握手的方式要确保对方收到了数据。</p>

<p>总结一下：</p>

<ul>
  <li>目标：通过<code>IP地址：端口号</code>来标识网络节点上的一个进程，并在网络中任意两个节点上的两个进程之间，实现消息的透明传输。</li>
  <li>传输单元：数据包，TCP数据包或者UDP数据包。</li>
</ul>

<p><strong>应用层</strong></p>

<p>应用层是模型中的最顶层，是用户与网络的接口，HTTP协议就属于这一层。HTTP协议能做什么？
很多人首先一定会想到：浏览网页。没错，浏览网页是HTTP的主要应用，但是这并不代表HTTP就只能应用于网页的浏览。HTTP是一种协议，只要通信的双方都遵守这个协议，HTTP就能有用武之地。比如咱们常用的QQ，迅雷这些软件，都会使用HTTP协议(还包括其他的协议)。需要说明的是，应用层HTTP协议传输的数据，在传输层，是由TCP协议承载的。</p>

<p>数据流动的时候，发送端，应用数据从上层向下，层层打包（添加包头），接收端，数据从下层向上，层层解包（去除包头）。</p>

<p>（应用层到底是什么？应用层与端口之间什么关系？会话层、表示层、应用层之间又有什么差异？）</p>

<h2 id="http-1">HTTP协议如何工作</h2>

<p>利用HTTP协议传输数据时，其基本过程：Client发送HTTP请求，Server返回HTTP响应；如下图所示：</p>

<p>（插入一个图片）</p>

<h3 id="requestresponse">Request\Response格式</h3>

<p>详细信息请参考：<a href="http://tools.ietf.org/html/rfc2616">RFC2616</a>.</p>

<p>关于HTTP headers的简要汇总和介绍，请参看：<a href="http://www.cs.tut.fi/~jkorpela/http.html">Quick reference to HTTP headers</a></p>

<h3 id="request">Request</h3>

<p>Request格式：</p>

<p>（插入一张图片：Request格式）</p>

<p>备注：</p>

<ol>
  <li><code>&lt;CR&gt;&lt;LF&gt;</code>为回车换行，其中：CR，Carriage Return，回车，打字机头部位置；LF，Line Feed，换行，打字机向下换一行；</li>
  <li><code>Null Line</code>中必须只有<code>&lt;CR&gt;&lt;LF&gt;</code>而无其他空格；</li>
  <li>在HTTP/1.1协议中，所有的<code>Headers</code>中，除Host外，都是可选的；</li>
</ol>

<p>Requset实例：</p>

<pre><code>GET http://www.cnblogs.com/gpcuster/ HTTP/1.1
Host: www.cnblogs.com
Proxy-Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36
Referer: http://www.baidu.com/s?wd=http%3A%2F%2Fwww.cnblogs.com%2Fgpcuster%2F&amp;rsv_spt=1&amp;issp=1&amp;rsv_bp=0&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_n=2&amp;rsv_sug3=1&amp;rsv_sug4=271&amp;inputT=2186
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: __gads=ID=d58f6aafc2b1682a:T=1399182693:S=ALNI_MbGQmpINTGEw1DKhg8-v-WGcqmDGg; CNZZDATA4902471=cnzz_eid%3D780096130-1402377079-http%253A%252F%252Fwww.baidu.com%252F%26ntime%3D1403490466; CNZZDATA3980738=cnzz_eid%3D371156967-1402987944-http%253A%252F%252Fwww.baidu.com%252F%26ntime%3D1404384515; CNZZDATA1923552=cnzz_eid%3D857445479-1402888944-http%253A%252F%252Fwww.cnblogs.com%252F%26ntime%3D1405079579; AJSTAT_ok_times=5; gs_u_GSN-690926-A=567797657:3115:11443:1407743725372; _ga=GA1.2.1054927095.1399182860; __utma=226521935.1054927095.1399182860.1407743656.1407743991.33; __utmb=226521935.2.10.1407743991; __utmc=226521935
If-Modified-Since: Mon, 11 Aug 2014 07:59:18 GMT
</code></pre>

<p>Request常用的Headers：</p>

<p>（todo）	</p>

<h3 id="response">Response</h3>

<p>Response格式：</p>

<p>（插入一张图片：Response格式）</p>

<pre><code>HTTP/1.1 200 OK
Date: Mon, 11 Aug 2014 07:59:41 GMT
Content-Type: text/html; charset=utf-8
Transfer-Encoding: chunked
Proxy-Connection: keep-alive
Vary: Accept-Encoding
Cache-Control: private, max-age=10
Expires: Mon, 11 Aug 2014 07:59:33 GMT
Last-Modified: Mon, 11 Aug 2014 07:59:23 GMT
X-UA-Compatible: IE=10
Content-Encoding: gzip
</code></pre>

<p>常用的Headers：</p>

<p>（doing…）</p>

<p>参考：</p>

<p>http://blog.csdn.net/adparking/article/details/7265496
http://blog.csdn.net/kfanning/article/details/6062118
http://www.cnblogs.com/loveyakamoz/archive/2011/07/22/2113614.html
http://blog.sina.com.cn/s/blog_5dd2af0901012oko.html
http://canrry.iteye.com/blog/1331292</p>

<h3 id="section-1">建立连接的方式</h3>

<p>HTTP支持2种建立连接的方式：非持久连接和持久连接（HTTP 1.0 默认：持久连接的带流水线方式）</p>

<h4 id="section-2">非持久连接</h4>

<p>让我们查看一下非持久连接情况下，从Server到Client传送一个Web页面的步骤。假设该页面由：1个基本HTML文件和10个JPEG图像构成，而且所有这些对象都存放在同一台服务器中。再假设该基本HTML文件的URL为：<code>gpcuster.cnblogs.com/index.html</code>。</p>

<p>下面是具体步骡:</p>

<ol>
  <li><code>HTTP Client</code>初始化一个与<code>HTTP Server</code>之间的TCP连接。<code>HTTP Server</code>使用默认端口号80监听来自<code>HTTP Client</code>的连接建立请求。</li>
  <li><code>HTTP Client</code>经由与TCP连接相关联的本地套接字，发出—个HTTP请求消息。这个消息中包含路径名/somepath/index.html。</li>
  <li><code>HTTP Server</code> 经由与TCP连接相关联的本地套接字，接收这个请求消息，再从服务器主机的内存或硬盘中取出对象/somepath/index.html，经由同一个套接字发出包含该对象的响应消息。</li>
  <li><code>HTTP Server</code>告知TCP关闭这个TCP连接(不过TCP要到客户收到刚才这个响应消息之后才会真正终止这个连接)。</li>
  <li><code>HTTP Client</code>经由同一个套接字接收这个响应消息，TCP连接随后终止。</li>
  <li>HTTP响应中，所封装的对象是一个HTML文件。<code>HTTP Server</code>从响应中取出这个HTML文件，加以分析后发现其中有10个JPEG对象的引用。</li>
  <li><code>HTTP Client</code>针对每一个JPEG对象引用，重复步骡1-5。</li>
</ol>

<p>上述步骤之所以称为<code>非持久连接</code>，原因是每次<code>HTTP Server</code>返回一个HTTP响应后，相应的TCP连接就被关闭，即，每个TCP连接只用于传输一个请求消息和一个响应消息。针对上述例子，用户每请求一次那个web页面，就反复建立、释放了11个TCP连接。</p>

<p>关于非持久连接，总结一下：</p>

<ul>
  <li>HTTP请求之前，建立TCP连接，HTTP响应之后，释放TCP连接；</li>
  <li>每个TCP连接只承载一组HTTP请求和响应消息；</li>
</ul>

<p>备注：</p>

<ul>
  <li>名词<code>套接字</code>socket是什么？</li>
  <li>TCP连接建立时，有3次握手，详细过程；</li>
  <li>TCP连接释放时，也有4次握手，详细过程；</li>
</ul>

<h4 id="section-3">持久连接</h4>

<p><code>非持久连接</code>有几点效率问题：</p>

<ol>
  <li>每个等待请求的对象，都需要建立并维护一个独立的TCP连接；对于每个这样的连接，TCP得在客户端和服务器端分配TCP缓冲区，并维持TCP变量。对于有可能同时为来自数百个不同客户的请求提供服务的web服务器来说，这会严重增加其负担。</li>
  <li>如前所述，每个对象都有2个RTT的响应延长——一个RTT用于建立TCP连接，另—个RTT用于请求和接收对象。</li>
  <li>每个对象都受TCP慢启动影响，因为每个TCP连接都有一个慢启动阶段。</li>
  <li><em>（优点）</em>也有优势：并行TCP连接的使用，能够部分减轻RTT延迟和慢启动延迟的影响。</li>
</ol>

<p>为解决非持久连接情况下，反复建立、释放TCP连接时，所产生的资源占用、效率低下的问题，提出了<code>持久连接</code>，其核心：</p>

<ol>
  <li><code>HTTP Server</code>返回一个HTTP响应之后，TCP连接保持存活一段时间，用于承载后续的其他HTTP请求/响应;</li>
  <li>TCP连接的存活时间是可以设定的;</li>
  <li>超过存活时间之后，TCP连接自动释放；</li>
</ol>

<p>持久连接分为<code>不带流水线(without pipelining)</code>和<code>带流水线(with pipelining)</code>两个版本。</p>

<p>不带流水线的持久化连接，特点如下：</p>

<ol>
  <li>Client只在收到前一个请求的响应后才发出新的请求，这种情况下，web页面所引用的每个对象(上例中的10个图像)都经历1个RTT的延迟，用于请求和接收该对象；</li>
  <li>服务器返回一个响应后，开始等待下一个请求，而这个新请求却不能马上到达，这段时间服务器资源便闲置了；</li>
</ol>

<p>带流水线的持久化连接，特点如下：</p>

<ol>
  <li>HTTP/1.1的默认模式；</li>
  <li>HTTP Client每碰到一个对象引用，就立即发出一个请求（如果没有可用的TCP连接，则新建一个），<code>HTTP Server</code>每收到一个请求，就立即返回一个响应；</li>
  <li>所有引用到的对象一共只经历1个RTT的延迟(而不是像不带流水线的版本那样，每个引用到的对象都各有1个RTT的延迟)；</li>
  <li>带流水线的持久连接中服务器空等请求的时间比较少；</li>
</ol>

<h3 id="section-4">缓存机制</h3>

<p>HTTP/1.1中缓存机制主要目标：提高页面访问速度；实现途径，有两条：</p>

<ol>
  <li>减少Client发送请求的次数：Client本地缓存页面，发送请求之前先检查一下，当前缓存页面是否<code>过期（expiration）</code>；</li>
  <li>Server只发送局部响应信息：即，Server不返回完整的响应信息，以此减少网络带宽的占用，<code>验证（validation）</code>机制能够实现此目标；</li>
</ol>

<p>实际上，HTTP定义了3中缓存机制：</p>

<ul>
  <li><strong>Freshness</strong> allows a response to be used without re-checking it on the origin server, and can be controlled by both the server and the client. For example, the Expires response header gives a date when the document becomes stale, and the Cache-Control: max-age directive tells the cache how many seconds the response is fresh for.</li>
  <li><strong>Validation</strong> can be used to check whether a cached response is still good after it becomes stale. For example, if the response has a Last-Modified header, a cache can make a conditional request using the If-Modified-Since header to see if it has changed.</li>
  <li><strong>Invalidation</strong> is usually a side effect of another request that passes through the cache. For example, if URL associated with a cached response subsequently gets a POST, PUT or DELETE request, the cached response will be invalidated.</li>
</ul>

<p>关于web缓存方面的内容可以参考：Caching Tutorial for Web Authors and Webmasters（<a href="https://www.mnot.net/cache_docs/#DEFINITION">英文版</a>）（<a href="http://www.chedong.com/tech/cache_docs.html">中文版</a>）</p>

<h2 id="http-2">基于HTTP的应用</h2>

<h3 id="http-3">HTTP代理</h3>

<p>（doing…）</p>

<p>参考：<a href="http://www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html">浅析HTTP协议</a></p>

<ol>
  <li>透明代理</li>
  <li>非透明代理</li>
  <li>反向代理</li>
</ol>

<h3 id="section-5">多线程下载</h3>

<p>（doing…）</p>

<p>基本过程如下：</p>

<ul>
  <li>下载工具开启多个线程，来发出HTTP请求；</li>
  <li>每个HTTP请求只请求资源文件的一部分：Content-Range:bytes 20000-40000/47000</li>
  <li>合并每个线程下载的文件</li>
</ul>

<h3 id="https">HTTPS传输协议原理</h3>

<p>（doing…）</p>

<p>参考：<a href="http://www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html">浅析HTTP协议</a></p>

<h3 id="webrequest-methods">WEB开发过程中常用的Request Methods</h3>

<p>（doing…）</p>

<p>参考：<a href="http://www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html">浅析HTTP协议</a></p>

<ul>
  <li>HEAD
  *（Head方法）要求响应与相应的GET请求的响应一样，但是没有的响应体（response body）。这用来获得响应头（response header）中的元数据信息（meta-infomation）有（很）帮助，（因为）它不需要传输所有的内容。</li>
  <li>TRACE
  *（Trace方法告诉服务器端）返回收到的请求。客户端可以（通过此方法）察看在请求过程中中间服务器添加或者改变哪些内容。</li>
  <li>OPTIONS
    <ul>
      <li>返回服务器（在指定URL上）支持的HTTP方法。通过请求“*”而不是指定的资源，这个方法可以用来检查网络服务器的功能。</li>
    </ul>
  </li>
  <li>CONNECT
    <ul>
      <li>将请求的连接转换成透明的TCP/IP通道，通常用来简化通过非加密的HTTP代理的SSL-加密通讯（HTTPS）。</li>
    </ul>
  </li>
</ul>

<h3 id="section-6">用户与服务器交互</h3>

<p>（doing…）</p>

<p>参考：<a href="http://www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html">浅析HTTP协议</a></p>

<ol>
  <li>身份认证；</li>
  <li>cookie；</li>
  <li>待条件的GET；</li>
</ol>

<h2 id="javahttp">java中的HTTP协议</h2>

<p>（doing…）</p>

<h3 id="javahttp-1">java中HTTP协议</h3>

<p>（主要两种方式：java api 和 http-common.jar?）</p>

<h3 id="servlethttp">servlet中HTTP协议</h3>

<h2 id="section-7">参考来源</h2>

<ol>
  <li><a href="http://www.w3.org/Protocols/">W3C: HTTP (HTTP Activity statement)</a></li>
  <li><a href="http://www.chinaw3c.org/about.html">W3C中文版简介</a></li>
  <li><a href="http://www.cnblogs.com/qiqibo/p/3143964.html">HTTP协议原理解析第一篇</a></li>
  <li><a href="http://www.cnblogs.com/gpcuster/archive/2009/05/25/1488749.html">浅析HTTP协议</a></li>
  <li><a href="http://www.chedong.com/tech/cache_docs.html">面向站长和网站管理员的Web缓存加速指南-翻译</a></li>
  <li><a href="http://tools.ietf.org/html/rfc2616">RFC2616</a></li>
  <li><a href="http://www.cs.tut.fi/~jkorpela/http.html">Quick reference to HTTP headers</a></li>
  <li>[O’Reilly - HTTP Pocket Reference]</li>
  <li>[Sams - HTTP Developers Handbook]</li>
</ol>

<h2 id="section-8">附录</h2>

<p>对与几个名词/组织的简介</p>

<h3 id="w3c">W3C</h3>
<p>万维网联盟（World Wide Web Consortium，简称W3C）创建与1994年，是Web技术领域，影响力较强的国际中立性，技术标准机构。其致力于开发协议、标准、指南，来确保Web的长期发展。详细信息参考：<a href="http://www.w3.org/Protocols/">W3C: HTTP (HTTP Activity statement)</a>。</p>

<h3 id="ietf">IETF</h3>
<p>互联网工程任务组（Internet Engineering Task Force，简称IETF）成立于1985年底，是全球互联网领域，极具权威的技术标准化组织，主要任务是负责互联网相关技术规范的研发和制定，当前绝大多数互联网技术标准都出自IETF。详细信息参考：<a href="http://www.ietf.org/">IETF</a>。</p>

<h3 id="rfc">RFC</h3>

<p>IETF（互联网工程任务组）产生两种文件，一个叫Internet Draft，即”互联网草案”，另一个叫RFC（Request For Comments，意见征求书、请求注解书），RFC相对Draft更为正式，一般情况下，RFC文档发布后，其内容不再做变动。</p>

<p>[O’Reilly - HTTP Pocket Reference]:		
[Sams - HTTP Developers Handbook]:		</p>


        <div id="disqus_container">
            <div style="margin-bottom:20px" class="right">
				<wb:share-button appkey="2306590132" addition="simple" type="button" ralateUid="2356527183"></wb:share-button>
            </div>
            <!--<a href="#" class="comment" onclick="return false;">点击查看评论</a>-->
            <div id="disqus_thread"></div>
        </div>
    </div>

	
    <div class="sidenav">
		<iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=2356527183&verifier=1ccfb61e&colors=d6f3f7,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe>
    </div>

</div>

<script src="/js/post.js" type="text/javascript"></script>


	<div id="gotoTop">Top</div>


    <!--*********************************************************-->
    <!--****** 宝贝儿，看见这个时候，删掉下面的统计代码哦~ ******-->
    <!--*********************************************************-->
	<script>
	  (function(i,s,o,g,r,a,m){
		  i['GoogleAnalyticsObject']=r;i[r]=i[r] || function(){
			(i[r].q=i[r].q||[]).push(arguments)}, i[r].l=1*new Date();
			a=s.createElement(o), m=s.getElementsByTagName(o)[0];
			a.async=1;
			a.src=g;
			m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-48535193-1', 'ningg.github.io');
	  ga('send', 'pageview');
	</script>
    
	
    <script type="text/javascript">
		function gotoTop(min_height){
			$("#gotoTop").click(
				function(){$('html,body').animate({scrollTop:0},700);
			}).hover(
				function(){$(this).addClass("hover");},
				function(){$(this).removeClass("hover");
			});
			min_height ? min_height = min_height : min_height = 600;
			$(window).scroll(function(){
				
				var s = $(window).scrollTop();
				
				if( s > min_height){
					$("#gotoTop").fadeIn(100);
				}else{
					$("#gotoTop").fadeOut(200);
				};
			});
		};
		gotoTop();

        $(function(){
            $('.home-follow').click(function(e){
                e.preventDefault();

                if($('.home-contact').is(':visible')){
                    $('.home-contact').slideUp(100);
                }else{
                    $('.home-contact').slideDown(100);
                }
            });
        })

    </script>
</body>
</html>
